"use strict";
/*
 Copyright (c) 42Crunch Ltd. All rights reserved.
 Licensed under the GNU Affero General Public License version 3. See LICENSE.txt in the project root for license information.
*/
Object.defineProperty(exports, "__esModule", { value: true });
exports.stringify = void 0;
const object_1 = require("./visit/object");
function stringify(value, indent = 0) {
    return indent === 0 ? stringify_plain(value) : stringify_format(value, indent);
}
exports.stringify = stringify;
function stringify_plain(value) {
    // safeguard for falsy values
    if (!value) {
        return JSON.stringify(value);
    }
    let result = "";
    (0, object_1.visitObject)(undefined, "fakeroot", value, {
        onObjectStart: (parent, key, value) => {
            result += keyed(key, "{");
        },
        onObjectEnd: () => {
            if (result.endsWith(",")) {
                result = result.slice(0, -1);
            }
            result += "},";
        },
        onArrayStart: (parent, key, value) => {
            result += keyed(key, "[");
        },
        onArrayEnd: () => {
            if (result.endsWith(",")) {
                result = result.slice(0, -1);
            }
            result += "],";
        },
        onValue: (parent, key, value, preserved) => {
            if (preserved !== undefined) {
                result += keyed(key, preserved) + ",";
            }
            else {
                result += keyed(key, JSON.stringify(value)) + ",";
            }
        },
    });
    // trim "fakeroot": and trailing comma
    return result.slice('"fakeroot":'.length, -1);
}
function stringify_format(value, indent) {
    // safeguard for falsy values
    if (!value) {
        return JSON.stringify(value);
    }
    let result = "";
    let level = 0;
    const isEmpty = [true];
    (0, object_1.visitObject)(undefined, "fakeroot", value, {
        onObjectStart: (parent, key, value) => {
            result += padding(indent, level) + keyed(key, "{\n", false);
            // new object in the parent container, therefore it's not empty
            isEmpty[isEmpty.length - 1] = false;
            // this object is empty so far
            isEmpty.push(true);
            level++;
        },
        onObjectEnd: () => {
            level--;
            if (isEmpty.pop()) {
                // remove EOL to put closing brace on the same line, there is no comma to remove
                result = result.slice(0, -1);
                result += "},\n";
            }
            else {
                // remove comma and EOL
                result = result.slice(0, -2);
                result += "\n" + padding(indent, level) + "},\n";
            }
        },
        onArrayStart: (parent, key, value) => {
            result += padding(indent, level) + keyed(key, "[\n", false);
            // new array in the parent container, therefore it's not empty
            isEmpty[isEmpty.length - 1] = false;
            // this array is empty so far
            isEmpty.push(true);
            level++;
        },
        onArrayEnd: () => {
            level--;
            if (isEmpty.pop()) {
                // remove EOL to put closing brace on the same line, there is no comma to remove
                result = result.slice(0, -1);
                result += "],\n";
            }
            else {
                // remove comma and EOL
                result = result.slice(0, -2);
                result += "\n" + padding(indent, level) + "],\n";
            }
        },
        onValue: (parent, key, value, preserved) => {
            // mark current container as non-empty
            isEmpty[isEmpty.length - 1] = false;
            if (preserved !== undefined) {
                result += padding(indent, level) + keyed(key, preserved, false) + ",\n";
            }
            else {
                result += padding(indent, level) + keyed(key, JSON.stringify(value), false) + ",\n";
            }
        },
    });
    // trim "fakeroot": and trailing comma and EOL
    return result.slice('"fakeroot": '.length, -2);
}
function keyed(key, value, tight = true) {
    const separator = tight ? ":" : ": ";
    return typeof key === "string" ? JSON.stringify(key) + separator + value : value;
}
function padding(indent, level) {
    return " ".repeat(indent * level);
}
