"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.translateToPathParameter = exports.translateToQueryParameter = exports.translateFromFormDataParameters = exports.translateToBodyParameter = exports.translateToHeaderParams = exports.translateToHeaderParam = void 0;
const json_1 = require("@stoplight/json");
const types_1 = require("@stoplight/types");
const pickBy = require("lodash.pickby");
const pick = require("lodash.pick");
const context_1 = require("../../context");
const guards_1 = require("../../guards");
const examples_1 = require("../../oas/transformers/examples");
const schema_1 = require("../../oas/transformers/schema");
const utils_1 = require("../../utils");
const accessors_1 = require("../accessors");
const guards_2 = require("../guards");
function chooseQueryParameterStyle(parameter) {
    switch (parameter.collectionFormat) {
        case 'pipes':
            return types_1.HttpParamStyles.PipeDelimited;
        case 'ssv':
            return types_1.HttpParamStyles.SpaceDelimited;
        case 'csv':
            return types_1.HttpParamStyles.CommaDelimited;
        case 'multi':
        default:
            return types_1.HttpParamStyles.Form;
    }
}
exports.translateToHeaderParam = (0, context_1.withContext)(function (param) {
    const name = param.name;
    return {
        id: this.generateId(`http_header-${this.parentId}-${name}`),
        name,
        style: types_1.HttpParamStyles.Simple,
        ...buildSchemaForParameter.call(this, param),
        ...pickBy({
            required: param.required,
        }, guards_1.isBoolean),
    };
});
const translateToHeaderParamsFromPair = function ([name, value]) {
    if (!(0, json_1.isPlainObject)(value))
        return;
    const param = { name, in: 'header', ...value };
    if (!(0, guards_2.isHeaderParam)(param))
        return;
    return exports.translateToHeaderParam.call(this, param);
};
const translateToHeaderParams = function (headers) {
    return (0, utils_1.entries)(headers).map(translateToHeaderParamsFromPair, this).filter(guards_1.isNonNullable);
};
exports.translateToHeaderParams = translateToHeaderParams;
exports.translateToBodyParameter = (0, context_1.withContext)(function (body, consumes) {
    const examples = (0, utils_1.entries)(body['x-examples'] || (0, accessors_1.getExamplesFromSchema)(body.schema)).map(([key, value]) => examples_1.translateToDefaultExample.call(this, key, value));
    return {
        id: this.generateId(`http_request_body-${this.parentId}`),
        contents: consumes.map((0, context_1.withContext)(mediaType => {
            return {
                id: this.generateId(`http_media-${this.parentId}-${mediaType}`),
                mediaType,
                examples,
                ...pickBy({
                    schema: (0, json_1.isPlainObject)(body.schema) ? schema_1.translateSchemaObject.call(this, body.schema) : void 0,
                }, guards_1.isNonNullable),
            };
        }), this),
        ...pickBy({
            required: body.required,
        }, guards_1.isBoolean),
        ...pickBy({
            description: body.description,
        }, guards_1.isString),
    };
});
exports.translateFromFormDataParameters = (0, context_1.withContext)(function (parameters, consumes) {
    const finalBody = {
        id: this.generateId(`http_request_body-${this.parentId}`),
        contents: consumes.map((0, context_1.withContext)(mediaType => ({
            id: this.generateId(`http_media-${this.parentId}-${mediaType}`),
            mediaType,
            ...pickBy({
                schema: parameters.length > 0 ? schema_1.translateSchemaObject.call(this, { type: 'object', properties: {} }) : void 0,
            }, guards_1.isNonNullable),
        })), this),
    };
    return parameters.reduce((body, parameter) => {
        var _a, _b;
        var _c;
        const { schema = {}, description } = buildSchemaForParameter.call(this, parameter);
        delete schema.$schema;
        delete schema['x-stoplight'];
        for (const content of body.contents) {
            if (typeof description === 'string' && description.length > 0) {
                schema.description = description;
            }
            content.schema.properties[parameter.name] = schema;
            if (parameter.required) {
                ((_a = (_c = content.schema).required) !== null && _a !== void 0 ? _a : (_c.required = [])).push(parameter.name);
            }
            const encoding = buildEncoding(parameter);
            if (encoding) {
                ((_b = content.encodings) !== null && _b !== void 0 ? _b : (content.encodings = [])).push(encoding);
            }
        }
        return body;
    }, finalBody);
});
function buildEncoding(parameter) {
    switch (parameter.collectionFormat) {
        case 'csv':
            return {
                property: parameter.name,
                style: types_1.HttpParamStyles.CommaDelimited,
                explode: false,
            };
        case 'pipes':
            return {
                property: parameter.name,
                style: types_1.HttpParamStyles.PipeDelimited,
                explode: false,
            };
        case 'multi':
            return {
                property: parameter.name,
                style: types_1.HttpParamStyles.Form,
                explode: true,
            };
        case 'ssv':
            return {
                property: parameter.name,
                style: types_1.HttpParamStyles.SpaceDelimited,
                explode: false,
            };
    }
    return null;
}
exports.translateToQueryParameter = (0, context_1.withContext)(function (param) {
    const name = param.name;
    return {
        id: this.generateId(`http_query-${this.parentId}-${name}`),
        name,
        style: chooseQueryParameterStyle(param),
        ...buildSchemaForParameter.call(this, param),
        ...pickBy({
            allowEmptyValue: param.allowEmptyValue,
            required: param.required,
        }, guards_1.isBoolean),
    };
});
exports.translateToPathParameter = (0, context_1.withContext)(function (param) {
    const name = param.name;
    return {
        id: this.generateId(`http_path_param-${this.parentId}-${name}`),
        name,
        style: types_1.HttpParamStyles.Simple,
        ...buildSchemaForParameter.call(this, param),
        ...pickBy({
            required: param.required,
        }, guards_1.isBoolean),
    };
});
const buildSchemaForParameter = function (param) {
    const schema = pick(param, 'type', 'format', 'default', 'enum', 'exclusiveMaximum', 'exclusiveMinimum', 'maxItems', 'maxLength', 'maximum', 'minItems', 'minimum', 'minLength', 'title', 'items', 'pattern', 'uniqueItems', 'multipleOf');
    if ('allowEmptyValue' in param && param.allowEmptyValue === false) {
        schema.minLength = 1;
    }
    return {
        ...pickBy({
            schema: Object.keys(schema).length > 0 ? schema_1.translateSchemaObject.call(this, schema) : void 0,
        }, guards_1.isNonNullable),
        ...pickBy({
            deprecated: param['x-deprecated'],
        }, guards_1.isBoolean),
        ...pickBy({
            description: param.description,
        }, guards_1.isString),
    };
};
//# sourceMappingURL=params.js.map