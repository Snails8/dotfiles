"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.convertSchema = exports.translateSchemaObject = void 0;
const json_1 = require("@stoplight/json");
const context_1 = require("../../../context");
const resolver_1 = require("../../resolver");
const keywords_1 = require("./keywords");
const keywordsKeys = Object.keys(keywords_1.default);
const CACHE = new WeakMap();
exports.translateSchemaObject = (0, context_1.withContext)(function (schema) {
    const resolvedSchema = this.maybeResolveLocalRef(schema);
    if (!(0, json_1.isPlainObject)(resolvedSchema))
        return {};
    let cached = CACHE.get(resolvedSchema);
    if (cached) {
        return { ...cached };
    }
    const actualKey = this.context === 'service' ? (0, resolver_1.getSharedKey)(resolvedSchema) : '';
    const id = this.generateId(`schema-${this.parentId}-${actualKey}`);
    cached = convertSchema(this.document, resolvedSchema);
    cached['x-stoplight'] = {
        ...((0, json_1.isPlainObject)(cached['x-stoplight']) && cached['x-stoplight']),
        id,
    };
    CACHE.set(resolvedSchema, cached);
    return cached;
});
function convertSchema(document, schema) {
    if ('jsonSchemaDialect' in document && typeof document.jsonSchemaDialect === 'string') {
        return {
            $schema: document.jsonSchemaDialect,
            ...schema,
        };
    }
    const clonedSchema = _convertSchema(schema, {
        structs: ['allOf', 'anyOf', 'oneOf', 'not', 'items', 'additionalProperties', 'additionalItems'],
    });
    clonedSchema.$schema = 'http://json-schema.org/draft-07/schema#';
    return clonedSchema;
}
exports.convertSchema = convertSchema;
function _convertSchema(schema, options) {
    const clonedSchema = { ...schema };
    for (const struct of options.structs) {
        if (Array.isArray(clonedSchema[struct])) {
            clonedSchema[struct] = clonedSchema[struct].slice();
            for (let i = 0; i < clonedSchema[struct].length; i++) {
                if (typeof clonedSchema[struct][i] === 'object' && clonedSchema[struct][i] !== null) {
                    clonedSchema[struct][i] = _convertSchema(clonedSchema[struct][i], options);
                }
                else {
                    clonedSchema[struct].splice(i, 1);
                    i--;
                }
            }
        }
        else if (clonedSchema[struct] !== null && typeof clonedSchema[struct] === 'object') {
            clonedSchema[struct] = _convertSchema(clonedSchema[struct], options);
        }
    }
    if ('properties' in clonedSchema && (0, json_1.isPlainObject)(clonedSchema.properties)) {
        convertProperties(clonedSchema, options);
    }
    for (const keyword of keywordsKeys) {
        if (keyword in schema) {
            keywords_1.default[keyword](clonedSchema);
        }
    }
    return clonedSchema;
}
function convertProperties(schema, options) {
    const props = { ...schema.properties };
    schema.properties = props;
    for (const key of Object.keys(props)) {
        const property = props[key];
        if ((0, json_1.isPlainObject)(property)) {
            props[key] = _convertSchema(property, options);
        }
    }
}
//# sourceMappingURL=index.js.map