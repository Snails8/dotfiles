import { jsx, jsxs, Fragment } from 'react/jsx-runtime';
import cn from 'clsx';
import * as _react from 'react';
import _react__default, { forwardRef, memo, useState, useRef, useCallback, useContext, useMemo, useLayoutEffect as useLayoutEffect$1, useEffect, useImperativeHandle } from 'react';
import memoize from 'nano-memoize';
import equals from 'react-fast-compare';
import { findIconDefinition, library } from '@fortawesome/fontawesome-svg-core';
import { faCaretDown, faCaretLeft, faCaretRight, faCaretUp, faCheck, faChevronDown, faChevronLeft, faChevronRight, faChevronUp, faCopy, faExclamationCircle, faExclamationTriangle, faExpandArrowsAlt, faExternalLinkAlt, faInfoCircle, faLink, faSort, faRobot } from '@fortawesome/free-solid-svg-icons';
import { FontAwesomeIcon } from '@fortawesome/react-fontawesome';
import create from 'zustand';
import { parseToHsl, parseToRgb, rgba, getLuminance, mix, readableColor } from 'polished';
import copy from 'copy-to-clipboard';
import _reactDom, { unstable_batchedUpdates } from 'react-dom';
import useSize from '@react-hook/size';
import _domHelpersOwnerDocument from 'dom-helpers/ownerDocument';
import _domHelpersQueryOffset from 'dom-helpers/query/offset';
import _domHelpersQueryScrollLeft from 'dom-helpers/query/scrollLeft';
import _domHelpersQueryScrollTop from 'dom-helpers/query/scrollTop';
import _get from 'lodash.get';
import { persist } from 'zustand/middleware';
import shallow from 'zustand/shallow';
import _domHelpersQueryPosition from 'dom-helpers/query/position';
import _domHelpersStyle from 'dom-helpers/style';
import { useWindowSize } from '@react-hook/window-size';
import { Key } from 'ts-keycode-enum';

const isPseudoObject = obj => obj && typeof obj === 'object';

const isNegative = v => {
  return v < 0 || v === '-px';
};
const buildClassname = (p, v) => {
  if (v === true) return `sl-${p}`;
  const isNeg = isNegative(v);
  return `sl-${isNeg ? '-' : ''}${p}${!p || isNeg ? '' : '-'}${v}`;
};
const computePseudoClasses = (prop, val) => {
  let classes = {}; // if val is literal true value, then we're trying to use default and do not need to append a value
  // val can be 0, account for this

  if (isPseudoObject(val)) {
    classes = {
      [buildClassname(prop, val.default)]: val.default || val.default === 0,
      [`sm:${buildClassname(prop, val.sm)}`]: val.sm || val.sm === 0,
      [`md:${buildClassname(prop, val.md)}`]: val.md || val.md === 0,
      [`first:${buildClassname(prop, val.first)}`]: val.first || val.first === 0,
      [`last:${buildClassname(prop, val.last)}`]: val.last || val.last === 0,
      [`odd:${buildClassname(prop, val.odd)}`]: val.odd || val.odd === 0,
      [`even:${buildClassname(prop, val.even)}`]: val.even || val.even === 0,
      [`hover:${buildClassname(prop, val.hover)}`]: val.hover || val.hover === 0,
      [`focus:${buildClassname(prop, val.focus)}`]: val.focus || val.focus === 0,
      [`active:${buildClassname(prop, val.active)}`]: val.active || val.active === 0,
      [`visited:${buildClassname(prop, val.visited)}`]: val.visited || val.visited === 0,
      [`group-hover:${buildClassname(prop, val.groupHover)}`]: val.groupHover || val.groupHover === 0,
      [`group-focus:${buildClassname(prop, val.groupFocus)}`]: val.groupFocus || val.groupFocus === 0,
      [`disabled:${buildClassname(prop, val.disabled)}`]: val.disabled || val.disabled === 0
    };
  } else {
    classes[`sl${prop ? `-${prop}` : ''}${val === true ? '' : '-' + val}`] = val || val === 0;
  }

  return cn(classes);
};

const borderPropNames = ['borderColor', 'border', 'borderT', 'borderR', 'borderL', 'borderB', 'rounded', 'roundedT', 'roundedR', 'roundedL', 'roundedB', 'roundedTL', 'roundedTR', 'roundedBL', 'roundedBR'];
const borderProps = props => {
  const {
    outline,
    rounded,
    roundedB,
    roundedT,
    roundedR,
    roundedL,
    roundedBL,
    roundedBR,
    roundedTL,
    roundedTR,
    borderColor,
    border,
    borderT,
    borderR,
    borderL,
    borderB,
    ...rest
  } = props;
  return {
    props: rest,
    className: _borderProps(outline, rounded, roundedB, roundedT, roundedR, roundedL, roundedBL, roundedBR, roundedTL, roundedTR, borderColor, border, borderT, borderR, borderL, borderB)
  };
};

const _borderProps = memoize((outline, rounded, roundedB, roundedT, roundedR, roundedL, roundedBL, roundedBR, roundedTL, roundedTR, borderColor, border, borderT, borderR, borderL, borderB) => {
  return cn({
    [`sl-outline-${outline}`]: outline !== void 0,
    [`sl-rounded${rounded === true ? '' : '-' + rounded}`]: rounded,
    [`sl-rounded-b${roundedB === true ? '' : '-' + roundedB}`]: roundedB,
    [`sl-rounded-t${roundedT === true ? '' : '-' + roundedT}`]: roundedT,
    [`sl-rounded-r${roundedR === true ? '' : '-' + roundedR}`]: roundedR,
    [`sl-rounded-l${roundedL === true ? '' : '-' + roundedL}`]: roundedL,
    [`sl-rounded-bl${roundedBL === true ? '' : '-' + roundedBL}`]: roundedBL,
    [`sl-rounded-br${roundedBR === true ? '' : '-' + roundedBR}`]: roundedBR,
    [`sl-rounded-tl${roundedTL === true ? '' : '-' + roundedTL}`]: roundedTL,
    [`sl-rounded-tr${roundedTR === true ? '' : '-' + roundedTR}`]: roundedTR
  }, computePseudoClasses('border', borderColor), computePseudoClasses('border', border), computePseudoClasses('border-t', borderT), computePseudoClasses('border-r', borderR), computePseudoClasses('border-l', borderL), computePseudoClasses('border-b', borderB));
}, {
  maxAge: Infinity,
  equals
});

const ringPropNames = ['ring', 'ringColor'];
const ringProps = props => {
  const {
    ring,
    ringColor,
    ringOpacity,
    ...rest
  } = props;
  return {
    props: rest,
    className: _ringProps(ring, ringColor, ringOpacity)
  };
};

const _ringProps = memoize((ring, ringColor, ringOpacity) => {
  return cn(computePseudoClasses('ring', ring), computePseudoClasses('ring', ringColor), computePseudoClasses('ring-opacity', ringOpacity));
}, {
  maxAge: Infinity,
  equals
});

const colorPropNames = ['bg', 'color' // 'placeholderColor' // not a standard box prop, this always goes on the input
];
const colorProps = props => {
  const {
    color,
    bg,
    placeholderColor,
    ...rest
  } = props;
  let skipBg = false;
  let skipColor = false; // Support hex bg values - not in the typings because adding string to typings clobbers them.. annoying typescript

  if (typeof bg === 'string' && bg.startsWith('#')) {
    // @ts-expect-error
    rest.style = Object.assign({}, rest.style || {}, {
      backgroundColor: bg
    });
    skipBg = true;
  } // Support hex color values


  if (typeof color === 'string' && color.startsWith('#')) {
    // @ts-expect-error
    rest.style = Object.assign({}, rest.style || {}, {
      color
    });
    skipColor = true;
  }

  return {
    props: rest,
    className: _colorProps(skipColor ? undefined : color, skipBg ? undefined : bg, placeholderColor)
  };
};

const _colorProps = memoize((color, bg, placeholderColor) => {
  return cn(computePseudoClasses('bg', bg), computePseudoClasses('text', color), computePseudoClasses('placeholder', placeholderColor));
}, {
  maxAge: Infinity,
  equals
});

const flexPropNames = ['flex', 'flexDirection', 'flexWrap', 'flexGrow', 'flexShrink', 'justifyContent', 'justifyItems', 'justifySelf', 'alignContent', 'alignItems', 'alignSelf'];
const flexProps = props => {
  const {
    flex,
    flexDirection,
    flexWrap,
    flexGrow,
    flexShrink,
    justifyContent,
    justifyItems,
    justifySelf,
    alignContent,
    alignItems,
    alignSelf,
    ...rest
  } = props;
  return {
    props: rest,
    className: _flexProps(flex, flexDirection, flexWrap, flexGrow, flexShrink, justifyContent, justifyItems, justifySelf, alignContent, alignItems, alignSelf)
  };
};

const _flexProps = memoize((flex, flexDirection, flexWrap, flexGrow, flexShrink, justifyContent, justifyItems, justifySelf, alignContent, alignItems, alignSelf) => {
  return cn({
    [`sl-flex-${flex}`]: flex !== void 0,
    [`sl-flex-${flexDirection}`]: flexDirection !== void 0,
    [`sl-flex-${flexWrap === true ? 'wrap' : flexWrap}`]: flexWrap !== void 0,
    [`sl-flex-grow${flexGrow === true ? '' : '-0'}`]: flexGrow !== void 0,
    [`sl-flex-shrink${flexShrink === true ? '' : '-0'}`]: flexShrink !== void 0,
    [`sl-justify-${justifyContent}`]: justifyContent !== void 0,
    [`sl-justify-items-${justifyItems}`]: justifyItems !== void 0,
    [`sl-justify-self-${justifySelf}`]: justifySelf !== void 0,
    [`sl-content-${alignContent}`]: alignContent !== void 0,
    [`sl-items-${alignItems}`]: alignItems !== void 0,
    [`sl-self-${alignSelf}`]: alignSelf !== void 0
  });
}, {
  maxAge: Infinity,
  equals
});

const interactivityPropNames = ['cursor', 'opacity', 'pointerEvents', 'resize', 'userSelect', 'visibility'];
const interactivityProps = props => {
  const {
    cursor,
    userSelect,
    pointerEvents,
    opacity,
    resize,
    visibility,
    ...rest
  } = props;
  return {
    props: rest,
    className: _interactivityProps(cursor, userSelect, pointerEvents, opacity, resize, visibility)
  };
};

const _interactivityProps = memoize((cursor, userSelect, pointerEvents, opacity, resize, visibility) => {
  return cn({
    [buildClassname('cursor', cursor)]: cursor,
    [`sl-select-${userSelect}`]: userSelect,
    [`sl-pointer-events-${pointerEvents}`]: pointerEvents,
    [buildClassname('resize', resize)]: resize
  }, // the visibility value itself is the class, no need to pass name
  computePseudoClasses('', visibility), computePseudoClasses('opacity', opacity));
}, {
  maxAge: Infinity,
  equals
});

const layoutPropNames = ['display', 'overflowX', 'overflowY', 'objectFit', 'objectPosition'];
const layoutProps = props => {
  const {
    display,
    overflowX,
    overflowY,
    objectFit,
    objectPosition,
    ...rest
  } = props;
  return {
    props: rest,
    className: _layoutProps(display, overflowX, overflowY, objectFit, objectPosition)
  };
};

const _layoutProps = memoize((display, overflowX, overflowY, objectFit, objectPosition) => {
  return cn({
    [`sl-${display}`]: display !== void 0,
    [`sl-overflow-x-${overflowX}`]: overflowX,
    [`sl-overflow-y-${overflowY}`]: overflowY,
    [`sl-object-${overflowY}`]: objectFit,
    [`sl-object-${objectPosition}`]: objectPosition
  });
}, {
  maxAge: Infinity,
  equals
});

const positionPropNames = ['bottom', 'pin', 'pinX', 'pinY', 'left', 'pos', 'right', 'top', 'zIndex'];
const positionProps = props => {
  const {
    pos,
    pin,
    pinY,
    pinX,
    top,
    left,
    right,
    bottom,
    zIndex,
    ...rest
  } = props;
  return {
    props: rest,
    className: _positionProps(pos, pin, pinY, pinX, top, left, right, bottom, zIndex)
  };
};

const _positionProps = memoize((pos, pin, pinY, pinX, top, left, right, bottom, zIndex) => {
  return cn({
    [`sl-${pos}`]: pos,
    [buildClassname('inset', pin === true ? '0' : pin)]: pin !== void 0,
    [buildClassname('inset-y', pinY === true ? '0' : pinY)]: pinY !== void 0,
    [buildClassname('inset-x', pinX === true ? '0' : pinX)]: pinX !== void 0,
    [buildClassname('top', top)]: top !== void 0,
    [buildClassname('left', left)]: left !== void 0,
    [buildClassname('right', right)]: right !== void 0,
    [buildClassname('bottom', bottom)]: bottom !== void 0
  }, computePseudoClasses('z', zIndex));
}, {
  maxAge: Infinity,
  equals
});

const shadowPropNames = ['boxShadow'];
const shadowProps = props => {
  const {
    boxShadow,
    ...rest
  } = props;
  return {
    props: rest,
    className: _shadowProps(boxShadow)
  };
};

const _shadowProps = memoize(boxShadow => {
  return cn(computePseudoClasses('shadow', boxShadow));
}, {
  maxAge: Infinity,
  equals
});

const sizePropNames = ['h', 'maxH', 'minH', 'maxW', 'minW', 'w'];
const sizeProps = props => {
  const {
    h,
    maxH,
    minH,
    w,
    maxW,
    minW,
    ...rest
  } = props;
  return {
    props: rest,
    className: _sizeProps(h, maxH, minH, w, maxW, minW)
  };
};

const _sizeProps = memoize((h, maxH, minH, w, maxW, minW) => {
  return cn({
    [`sl-w-${w}`]: w !== void 0,
    [`sl-max-w-${maxW}`]: maxW !== void 0,
    [`sl-min-w-${minW}`]: minW !== void 0,
    [`sl-h-${h}`]: h !== void 0,
    [`sl-max-h-${maxH}`]: maxH !== void 0,
    [`sl-min-h-${minH}`]: minH !== void 0
  });
}, {
  maxAge: Infinity,
  equals
});

const spacingPropNames = ['m', 'mb', 'ml', 'mr', 'mt', 'mx', 'my', 'p', 'pb', 'pl', 'pr', 'pt', 'px', 'py'];
const marginProps = props => {
  const {
    m,
    mx,
    my,
    mt,
    mr,
    mb,
    ml,
    ...rest
  } = props;
  return {
    props: rest,
    className: _marginProps(m, mx, my, mt, mr, mb, ml)
  };
};

const _marginProps = memoize((m, mx, my, mt, mr, mb, ml) => {
  return cn({
    [buildClassname('m', m)]: m !== void 0,
    [buildClassname('mx', mx)]: mx !== void 0,
    [buildClassname('my', my)]: my !== void 0,
    [buildClassname('mt', mt)]: mt !== void 0,
    [buildClassname('mr', mr)]: mr !== void 0,
    [buildClassname('mb', mb)]: mb !== void 0,
    [buildClassname('ml', ml)]: ml !== void 0
  });
}, {
  maxAge: Infinity,
  equals
});

const paddingProps = props => {
  const {
    p,
    px,
    py,
    pt,
    pr,
    pb,
    pl,
    ...rest
  } = props;
  return {
    props: rest,
    className: _paddingProps(p, px, py, pt, pr, pb, pl)
  };
};

const _paddingProps = memoize((p, px, py, pt, pr, pb, pl) => {
  return cn({
    [buildClassname('p', p)]: p !== void 0,
    [buildClassname('px', px)]: px !== void 0,
    [buildClassname('py', py)]: py !== void 0,
    [buildClassname('pt', pt)]: pt !== void 0,
    [buildClassname('pr', pr)]: pr !== void 0,
    [buildClassname('pb', pb)]: pb !== void 0,
    [buildClassname('pl', pl)]: pl !== void 0
  });
}, {
  maxAge: Infinity,
  equals
});

const transformPropNames = ['transform', 'transition', 'transitionDelay', 'transitionDuration', 'translateX', 'translateY'];
const transformProps = props => {
  const {
    transform,
    transition,
    transitionDelay,
    transitionDuration,
    translateX,
    translateY,
    ...rest
  } = props;
  return {
    props: rest,
    className: _transformProps(transform, transition, transitionDelay, transitionDuration, translateX, translateY)
  };
};

const _transformProps = memoize((transform, transition, transitionDelay, transitionDuration, translateX, translateY) => {
  return cn({
    [`sl-transform`]: transform,
    [`sl-transition`]: transition,
    [`sl-delay-${transitionDelay}`]: transitionDelay,
    [`sl-duration-${transitionDuration}`]: transitionDuration
  }, computePseudoClasses('translate-x', translateX), computePseudoClasses('translate-y', translateY));
}, {
  maxAge: Infinity,
  equals
});

const typographyPropNames = ['fontFamily', 'fontSize', 'fontStyle', 'fontWeight', 'letterSpacing', 'lineHeight', 'textAlign', 'textDecoration', 'textOverflow', 'textTransform', 'verticalAlign', 'whitespace', 'wordBreak'];
const typographyProps = props => {
  const {
    fontSize,
    lineHeight,
    letterSpacing,
    fontFamily,
    fontWeight,
    fontStyle,
    textAlign,
    textDecoration,
    textTransform,
    textOverflow,
    verticalAlign,
    whitespace,
    wordBreak,
    ...rest
  } = props;
  return {
    props: rest,
    className: _typographyProps(fontSize, lineHeight, letterSpacing, fontFamily, fontWeight, fontStyle, textAlign, textDecoration, textTransform, textOverflow, verticalAlign, whitespace, wordBreak)
  };
};

const _typographyProps = memoize((fontSize, lineHeight, letterSpacing, fontFamily, fontWeight, fontStyle, textAlign, textDecoration, textTransform, textOverflow, verticalAlign, whitespace, wordBreak) => {
  return cn({
    [`sl-text-${fontSize}`]: fontSize,
    [`sl-leading-${lineHeight}`]: lineHeight,
    [`sl-tracking-${letterSpacing}`]: letterSpacing,
    [`sl-font-${fontFamily}`]: fontFamily,
    [`sl-font-${fontWeight}`]: fontWeight,
    [`sl-${fontStyle}`]: fontStyle,
    [`sl-text-${textAlign}`]: textAlign,
    [`sl-${textDecoration}`]: textDecoration,
    [`sl-${textTransform}`]: textTransform,
    [`sl-${textOverflow}`]: textOverflow,
    [`sl-align-${verticalAlign}`]: verticalAlign,
    [`sl-whitespace-${whitespace}`]: whitespace,
    [`sl-break-${wordBreak}`]: wordBreak
  });
}, {
  maxAge: Infinity,
  equals
});

const defaultElement$c = 'div';
const Box = /*#__PURE__*/forwardRef(function Box({
  as,
  className,
  role,
  noFocusRing,
  children,
  ...props
}, ref) {
  const classNames = []; // custom pipe to just make accumulating the generated classNames, and pulling out props, easier

  const pipe = (...fns) => x => fns.reduce((v, f) => {
    const {
      props,
      className
    } = f(v);
    classNames.push(className);
    return props;
  }, x); // run the props through all the enhancers - what we're left with is the extra props that we're not specifically handling
  // these get passed on to the underlying Element as is


  const restProps = pipe(layoutProps, flexProps, positionProps, sizeProps, typographyProps, marginProps, paddingProps, colorProps, borderProps, ringProps, shadowProps, interactivityProps, transformProps)(props);

  const _className = cn(className, classNames, {
    'sl-group': role === 'group',
    'sl-no-focus-ring': noFocusRing
  });

  const Element = as || defaultElement$c;
  return jsx(Element, Object.assign({
    ref: ref
  }, restProps, {
    className: _className || undefined,
    role: role
  }, {
    children: children
  }), void 0);
}); // @ts-ignore

Box.displayName = 'Box'; // @ts-ignore

Box.defaultProps = {
  as: defaultElement$c
};

const containerSizes = {
  xs: {
    maxWidth: 300,
    p: 3
  },
  sm: {
    maxWidth: 640,
    p: 3
  },
  md: {
    maxWidth: 950,
    p: 3
  },
  lg: {
    maxWidth: 1280,
    p: 5
  },
  xl: {
    maxWidth: 1450,
    p: 5
  },
  full: {
    p: 5
  }
};
const Container = /*#__PURE__*/memo( /*#__PURE__*/forwardRef(function Container({
  size = 'full',
  className,
  style = {},
  ...props
}, ref) {
  return jsx(Box, Object.assign({
    ref: ref,
    px: containerSizes[size].p,
    mx: "auto",
    w: "full",
    style: {
      maxWidth: containerSizes[size].maxWidth,
      ...style
    },
    className: cn('Container', className)
  }, props), void 0);
}));

const Article = /*#__PURE__*/memo(function Article({
  className,
  children,
  ...props
}) {
  return jsx(Container, Object.assign({
    as: "article",
    className: cn('sl-article', className),
    size: "md",
    py: 20
  }, props, {
    children: children
  }), void 0);
});

function AspectRatio({
  ratio = 4 / 3,
  className,
  children,
  style = {},
  ...props
}) {
  // enforce single child
  const child = _react.Children.only(children);
  return jsx(Box, Object.assign({}, props, {
    pos: "relative",
    className: cn('sl-aspect-ratio', className),
    style: { ...style,
      // @ts-expect-error react css typings intentionally don't include index type, this is expected
      '--ratio': ratio
    }
  }, {
    children: child
  }), void 0);
}

const defaultElement$b = 'div';
const Flex = /*#__PURE__*/memo( /*#__PURE__*/forwardRef(({
  align,
  justify,
  wrap,
  direction,
  grow,
  shrink,
  inline,
  ...restProps
}, ref) => {
  const remapped = {
    alignItems: align,
    justifyContent: justify,
    flexWrap: wrap,
    flexDirection: direction,
    flexGrow: grow,
    flexShrink: shrink
  };
  return jsx(Box, Object.assign({
    as: defaultElement$b,
    ref: ref,
    display: inline ? 'inline-flex' : 'flex'
  }, remapped, restProps), void 0);
}));

const useIconStore = create(set => ({
  defaultStyle: 'fas',
  setDefaultStyle: style => set(state => ({ ...state,
    defaultStyle: style
  }))
}));
const _className = 'sl-icon';
let addedToLibrary = false;

const initLibrary = () => {
  library.add(faCaretDown, faCaretLeft, faCaretRight, faCaretUp, faCheck, faChevronDown, faChevronLeft, faChevronRight, faChevronUp, faCopy, faExclamationCircle, faExclamationTriangle, faExpandArrowsAlt, faExternalLinkAlt, faInfoCircle, faLink, faSort);
  addedToLibrary = true;
};

const Icon = /*#__PURE__*/memo(function Icon({
  className,
  icon,
  ...props
}) {
  const style = useIconStore(state => state.defaultStyle);
  const iconProp = normalizeIconArgs(icon, style);
  const fallBackIconStyle = props.color ? { ...props.style,
    color: props.color
  } : props.style;
  /**
   * So that if Icon is imported, the library stuff is not tree-shaken out. If `library.add` was hoisted out of this
   * function then it would be shaken out at consumer build time.
   */

  if (!addedToLibrary) initLibrary();

  if (isIconDefinition(iconProp) || findIconDefinition(iconProp)) {
    return jsx(FontAwesomeIcon, Object.assign({
      className: cn(_className, className),
      icon: iconProp
    }, props), void 0);
  } // if the icon is not bundled with the mosaic core (via library in Icon/index.ts), then render fallback <i> in
  // case font awesome kit or css is loaded on page


  return jsx("i", {
    role: "img",
    "aria-hidden": "true",
    className: cn(_className, className, iconProp.prefix, `fa-${iconProp.iconName}`, {
      'fa-spin': props.spin,
      'fa-pulse': props.pulse,
      'fa-fw': props.fixedWidth,
      [`fa-${props.size}`]: props.size
    }),
    style: fallBackIconStyle
  }, void 0);
});
function isIconDefinition(prop) {
  if (prop && typeof prop === 'object' && prop.hasOwnProperty('icon')) return true;
  return false;
}
function isIconProp(prop) {
  if (prop && typeof prop === 'string' || Array.isArray(prop)) return true;
  if (prop && typeof prop === 'object' && prop.hasOwnProperty('iconName')) return true;
  return false;
} // Adapted from https://github.com/FortAwesome/react-fontawesome/blob/master/src/utils/normalize-icon-args.js
// Adds defaultPrefix and adjusts to fix some typings issues

function normalizeIconArgs(icon, defaultPrefix = 'fas') {
  // if the icon is null, there's nothing to do
  if (icon === null) {
    return null;
  }

  if (Array.isArray(icon)) {
    // use the first item as prefix, second as icon name
    return {
      prefix: icon[0],
      iconName: icon[1]
    };
  } // if the icon is an object and has a prefix and an icon name, return it


  if (typeof icon === 'object' && icon.iconName) {
    return icon;
  } // if it's a string, use it as the icon name


  if (typeof icon === 'string') {
    return {
      prefix: defaultPrefix,
      iconName: icon
    };
  }
}

const defaultElement$a = 'span';
const Text = /*#__PURE__*/memo( /*#__PURE__*/forwardRef(({
  size,
  ...restProps
}, ref) => {
  return jsx(Box, Object.assign({
    as: defaultElement$a,
    ref: ref,
    fontSize: size
  }, restProps), void 0);
}));

const sizes$9 = {
  lg: ['md', 8],
  md: ['sm', 6],
  sm: ['xs', 5]
};
const Avatar = /*#__PURE__*/memo( /*#__PURE__*/forwardRef(function Avatar(props, ref) {
  // TODO: the union types make spreading out rest and passing through to box difficult, since we can't
  // easily pull out letter, blank, etc. they're getting sent to box right now...
  // @ts-expect-error
  let {
    className,
    size = 'md',
    bg,
    icon,
    letter,
    blank,
    ...rest
  } = props;
  let extraProps = {};

  if (bg) {
    extraProps.style = {
      color: 'white',
      backgroundColor: bg
    };
  }

  let innerElem;

  if (icon) {
    innerElem = jsx(Icon, {
      icon: icon
    }, void 0);
  } else if (letter) {
    innerElem = jsx(Text, {
      children: letter
    }, void 0);
  }

  return jsx(Flex, Object.assign({
    ref: ref,
    className: cn('sl-avatar', className),
    align: "center",
    justify: "center",
    h: sizes$9[size][0],
    w: sizes$9[size][1],
    rounded: "full"
  }, rest, extraProps, {
    children: innerElem
  }), void 0);
}));

// Number assertions
function isNumber(value) {
  return typeof value === 'number';
}
const isNotNumber = value => typeof value !== 'number' || Number.isNaN(value) || !Number.isFinite(value);
function isNumeric(value) {
  return value != null && value - parseFloat(value) + 1 >= 0;
} // Array assertions

function isArray(value) {
  return Array.isArray(value);
}
const isEmptyArray = value => isArray(value) && value.length === 0; // Function assertions

function isFunction(value) {
  return typeof value === 'function';
} // Generic assertions

const isDefined = value => typeof value !== 'undefined' && value !== undefined;
const isUndefined = value => typeof value === 'undefined' || value === undefined;
const isNil = value => isUndefined(value) || value === null; // Object assertions

const isObject = value => {
  const type = typeof value;
  return value != null && (type === 'object' || type === 'function') && !isArray(value);
};
const isEmptyObject = value => isObject(value) && Object.keys(value).length === 0;
function isNotEmptyObject(value) {
  return value && !isEmptyObject(value);
}
const isNull = value => value == null; // String assertions

function isString(value) {
  return Object.prototype.toString.call(value) === '[object String]';
} // Event assertions

function isInputEvent(value) {
  return value && isObject(value) && isObject(value.target);
} // Empty assertions

const isEmpty = value => {
  if (isArray(value)) return isEmptyArray(value);
  if (isObject(value)) return isEmptyObject(value);
  if (value == null || value === '') return true;
  return false;
}; // eslint-disable-next-line @typescript-eslint/naming-convention

const __DEV__ = process.env.NODE_ENV !== 'production';

const accumulateCollectionKeysByProp = (targetProp, targetValue) => {
  let keysHash = '[]';
  let keys = [];

  const accumulate = (nodes, newKeys) => {
    for (const node of nodes) {
      if (node.props && node.props[targetProp] === targetValue) {
        newKeys.push(node.key);
      }

      if (node.hasChildNodes) {
        accumulate(node.childNodes, newKeys);
      }
    }
  };

  const accumulator = nodes => {
    let newKeys = [];
    accumulate(nodes, newKeys);
    let newKeysHash = JSON.stringify(newKeys);

    if (keysHash !== newKeysHash) {
      keysHash = newKeysHash;
      keys = newKeys;
    }

    return keys;
  };

  return accumulator;
};

const getContrastColor = (bgLuminance, fgLuminance, targetContrast, hue, saturation = 1, lightness = 50) => {
  let targetLuminance;

  if (fgLuminance < bgLuminance) {
    targetLuminance = (bgLuminance + 0.05) / targetContrast - 0.05;
  } else {
    targetLuminance = targetContrast * (bgLuminance + 0.05) - 0.05;
  }

  return setLuminance(targetLuminance, stringifyHsl({
    h: hue,
    s: saturation,
    l: lightness
  }));
};
const parseHsl = hsl => {
  const hslRegexp = /hsl\((\d+),\s*([\d.]+)%,\s*([\d.]+)%\)/g;
  const hslaRegexp = /hsla\((\d+),\s*([\d.]+)%,\s*([\d.]+)%,\s*([\d.]+)\)/g;
  let parts = hslRegexp.exec(hsl);

  if (!parts) {
    parts = hslaRegexp.exec(hsl);
  }

  if (!parts) {
    try {
      const hslParts = parseToHsl(hsl);
      return {
        h: Math.round(hslParts.hue),
        s: parseFloat((hslParts.saturation * 100).toFixed(0)),
        l: Math.max(1, Math.min(99, Math.round(hslParts.lightness * 100))),
        // @ts-expect-error
        a: hslParts.alpha !== void 0 ? hslParts.alpha : 1
      };
    } catch (e) {
      console.warn(e);
      return {
        h: 0,
        s: 0,
        l: 100,
        a: 1
      };
    }
  }

  return {
    h: parseInt(parts[1]),
    s: parseFloat(parts[2]),
    l: parseFloat(parts[3])
  };
};
const stringifyHsl = hsl => {
  if (hsl.a !== void 0) {
    return `hsla(${hsl.h}, ${hsl.s}%, ${hsl.l}%, ${hsl.a})`;
  } else {
    return `hsl(${hsl.h}, ${hsl.s}%, ${hsl.l}%)`;
  }
};
const EPS = 1e-7;

const setLuminance = (amount, color) => {
  // @ts-expect-error
  const {
    alpha = 1
  } = parseToRgb(color);
  let rgb;

  if (amount === 0) {
    rgb = rgba(0, 0, 0, alpha);
  } else if (amount === 1) {
    rgb = rgba(255, 255, 255, alpha);
  } else {
    let maxIteration = 20;

    const test = (color1, color2) => {
      const mixed = mix(0.5, color1, color2);
      const mixedLuminance = getLuminance(mixed);

      if (Math.abs(amount - mixedLuminance) < EPS || !maxIteration--) {
        return mixed;
      }

      if (mixedLuminance > amount) {
        return test(color1, mixed);
      }

      return test(mixed, color2);
    };

    rgb = getLuminance(color) > amount ? test('#000', color) : test(color, '#fff');
  }

  return rgb;
};

const isServer = typeof document === 'undefined';
const findCss = id => {
  if (isServer) return;
  return document.head.querySelector('#' + id);
};
const appendCss = (id, css) => {
  if (isServer) return; // only inject once

  if (!findCss(id)) {
    const node = document.createElement('style');
    node.textContent = css;
    node.type = 'text/css';
    node.id = id;
    document.head.appendChild(node);
  }
};
const replaceCss = (id, css) => {
  if (isServer) return;
  let node = findCss(id);

  if (!node) {
    node = document.createElement('style');
    node.type = 'text/css';
    node.id = id;
    node.textContent = css;
    document.head.appendChild(node);
  } else {
    node.textContent = css;
  }
};

function runIfFn(valueOrFn, ...args) {
  return isFunction(valueOrFn) ? valueOrFn(...args) : valueOrFn;
}
function once(fn) {
  let result;
  return function func(...args) {
    if (fn) {
      result = fn.apply(this, args); // eslint-disable-next-line no-param-reassign

      fn = null;
    }

    return result;
  };
}
const noop = () => {};
const warn = once(options => {
  const {
    condition,
    message
  } = options;

  if (condition && __DEV__) {
    console.warn(message);
  }
});
const error = once(options => {
  const {
    condition,
    message
  } = options;

  if (condition && __DEV__) {
    console.error(message);
  }
});

const propNames = ['as', ...borderPropNames, ...colorPropNames, ...flexPropNames, ...interactivityPropNames, ...layoutPropNames, ...positionPropNames, ...shadowPropNames, ...sizePropNames, ...spacingPropNames, ...typographyPropNames, ...transformPropNames];
/**
 * Convenience method to split the Box props.
 *
 * Useful for when you want to pass all of the Box props to the root Box and
 * pass the remaining props to a child element (e.g: disabled, readOnly, required, etc).
 */

function splitBoxProps(props) {
  return splitProps(props, propNames);
}
/**
 * Utility to split props based on an array of keys
 */

function splitProps(props, keys) {
  const matchedProps = {};
  const remainingProps = {};
  const propKeys = Object.keys(props);

  for (let i = 0; i < propKeys.length; i++) {
    const propKey = propKeys[i];
    const propValue = props[propKey];

    if (keys.includes(propKey)) {
      matchedProps[propKey] = propValue;
    } else {
      remainingProps[propKey] = propValue;
    }
  }

  return {
    matchedProps,
    remainingProps
  };
}

var isMergeableObject = function isMergeableObject(value) {
	return isNonNullObject(value)
		&& !isSpecial(value)
};

function isNonNullObject(value) {
	return !!value && typeof value === 'object'
}

function isSpecial(value) {
	var stringValue = Object.prototype.toString.call(value);

	return stringValue === '[object RegExp]'
		|| stringValue === '[object Date]'
		|| isReactElement(value)
}

// see https://github.com/facebook/react/blob/b5ac963fb791d1298e7f396236383bc955f916c1/src/isomorphic/classic/element/ReactElement.js#L21-L25
var canUseSymbol = typeof Symbol === 'function' && Symbol.for;
var REACT_ELEMENT_TYPE = canUseSymbol ? Symbol.for('react.element') : 0xeac7;

function isReactElement(value) {
	return value.$$typeof === REACT_ELEMENT_TYPE
}

function emptyTarget(val) {
	return Array.isArray(val) ? [] : {}
}

function cloneUnlessOtherwiseSpecified(value, options) {
	return (options.clone !== false && options.isMergeableObject(value))
		? deepmerge(emptyTarget(value), value, options)
		: value
}

function defaultArrayMerge(target, source, options) {
	return target.concat(source).map(function(element) {
		return cloneUnlessOtherwiseSpecified(element, options)
	})
}

function getMergeFunction(key, options) {
	if (!options.customMerge) {
		return deepmerge
	}
	var customMerge = options.customMerge(key);
	return typeof customMerge === 'function' ? customMerge : deepmerge
}

function getEnumerableOwnPropertySymbols(target) {
	return Object.getOwnPropertySymbols
		? Object.getOwnPropertySymbols(target).filter(function(symbol) {
			return target.propertyIsEnumerable(symbol)
		})
		: []
}

function getKeys(target) {
	return Object.keys(target).concat(getEnumerableOwnPropertySymbols(target))
}

function propertyIsOnObject(object, property) {
	try {
		return property in object
	} catch(_) {
		return false
	}
}

// Protects from prototype poisoning and unexpected merging up the prototype chain.
function propertyIsUnsafe(target, key) {
	return propertyIsOnObject(target, key) // Properties are safe to merge if they don't exist in the target yet,
		&& !(Object.hasOwnProperty.call(target, key) // unsafe if they exist up the prototype chain,
			&& Object.propertyIsEnumerable.call(target, key)) // and also unsafe if they're nonenumerable.
}

function mergeObject(target, source, options) {
	var destination = {};
	if (options.isMergeableObject(target)) {
		getKeys(target).forEach(function(key) {
			destination[key] = cloneUnlessOtherwiseSpecified(target[key], options);
		});
	}
	getKeys(source).forEach(function(key) {
		if (propertyIsUnsafe(target, key)) {
			return
		}

		if (propertyIsOnObject(target, key) && options.isMergeableObject(source[key])) {
			destination[key] = getMergeFunction(key, options)(target[key], source[key], options);
		} else {
			destination[key] = cloneUnlessOtherwiseSpecified(source[key], options);
		}
	});
	return destination
}

function deepmerge(target, source, options) {
	options = options || {};
	options.arrayMerge = options.arrayMerge || defaultArrayMerge;
	options.isMergeableObject = options.isMergeableObject || isMergeableObject;
	// cloneUnlessOtherwiseSpecified is added to `options` so that custom arrayMerge()
	// implementations can use it. The caller may not replace it.
	options.cloneUnlessOtherwiseSpecified = cloneUnlessOtherwiseSpecified;

	var sourceIsArray = Array.isArray(source);
	var targetIsArray = Array.isArray(target);
	var sourceAndTargetTypesMatch = sourceIsArray === targetIsArray;

	if (!sourceAndTargetTypesMatch) {
		return cloneUnlessOtherwiseSpecified(source, options)
	} else if (sourceIsArray) {
		return options.arrayMerge(target, source, options)
	} else {
		return mergeObject(target, source, options)
	}
}

deepmerge.all = function deepmergeAll(array, options) {
	if (!Array.isArray(array)) {
		throw new Error('first argument should be an array')
	}

	return array.reduce(function(prev, next) {
		return deepmerge(prev, next, options)
	}, {})
};

var deepmerge_1 = deepmerge;

var cjs = deepmerge_1;

const defaultTheme = {
  colors: {
    background: 'hsl(218, 40%, 100%)',
    // text: 'hsl(214, 15%, 9%)', // defaults to compute based on background
    primary: 'hsl(202, 100%, 55%)',
    success: 'hsl(156, 95%, 37%)',
    warning: 'hsl(20, 90%, 56%)',
    danger: 'hsl(0, 84%, 63%)'
  }
};
const getCssVariable = (name, element) => {
  if (typeof document === void 0) return null;
  return getComputedStyle(element || document.body).getPropertyValue(name);
}; // so that lines don't wrap so much, hard to read

const r = Math.round;
const prefersDarkMode = () => typeof window !== 'undefined' && window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)');
/**
 * Handles figuring out what 'system' mode resolves to if user has that picked. Always returns light | dark.
 */

const getResolvedThemeMode = userMode => {
  if (userMode === 'system') {
    return prefersDarkMode() ? 'dark' : 'light';
  }

  return userMode;
};
const computeTheme = (customTheme, $mode = 'system') => {
  const mode = getResolvedThemeMode($mode);
  const theme = cjs(defaultTheme, customTheme); // when the user has a preference for dark screen, reduce the saturation and lightness

  const mult = {
    s: mode === 'dark' ? 0.8 : 1,
    l: mode === 'dark' ? 0.65 : 1
  };
  const backgroundHsl = parseHsl(theme.colors.background);

  if (mode === 'dark' && backgroundHsl.l > 20) {
    backgroundHsl.s = r(Math.min(60, backgroundHsl.s * mult.s));
    backgroundHsl.l = 8;
  } // main colors


  const cv = {
    light: backgroundHsl.l >= 50,
    background: backgroundHsl,
    text: theme.colors.text ? parseHsl(theme.colors.text) : parseHsl(readableColor(stringifyHsl(backgroundHsl), stringifyHsl({
      h: backgroundHsl.h,
      s: backgroundHsl.s,
      l: Math.max(95, backgroundHsl.l)
    }), stringifyHsl({
      h: backgroundHsl.h,
      s: backgroundHsl.s,
      l: Math.min(5, backgroundHsl.l)
    }), true)),
    primary: parseHsl(theme.colors.primary),
    success: parseHsl(theme.colors.success),
    warning: parseHsl(theme.colors.warning),
    danger: parseHsl(theme.colors.danger)
  };
  /**
   * Inverted colors
   */

  const invertedBackgroundHsl = invertColorValue(cv.background, cv.light);
  /**
   * If user is asking for dark mode, then regular background will always be dark, and we make inverted background
   * just a little lighter than regular background, to raise it (opposite of how "raise" works on light backgrounds, where you darken to give a raise effect)
   */

  if (mode === 'dark') {
    invertedBackgroundHsl.l = cv.background.l + 5;
  }
  /** Is the inverted bg a light color? */


  const icvLight = invertedBackgroundHsl.l >= 50;
  const icv = {
    light: icvLight,
    background: invertedBackgroundHsl,
    text: {
      h: cv.text.h,
      s: r(cv.text.s / 2),
      l: icvLight ? 5 : Math.max(98, cv.text.l)
    },
    primary: invertColorValue(cv.primary, icvLight),
    success: invertColorValue(cv.success, icvLight),
    warning: invertColorValue(cv.warning, icvLight),
    danger: invertColorValue(cv.danger, icvLight)
  };

  if (cv.background.s > 50) {
    // help w contrast by lowering the saturation and lightness if the background is highly saturated
    mult.s = mult.s * 0.75;
    mult.l = mult.l * 0.7;
  }

  return {
    mult,
    colorValues: cv,
    invertedColorValues: icv,
    css: `${mode === 'light' ? ':root,' : ''}
  [data-theme="${mode}"],
  [data-theme="${mode}"] .sl-inverted .sl-inverted,
  [data-theme="${mode}"] .sl-inverted .sl-inverted .sl-inverted .sl-inverted {
    color: var(--color-text);

    ${cssVariablesToStyles(computeCssVariables(cv, { ...mult
    }))}
}

  ${mode === 'light' ? ':root .sl-inverted,' : ''}
  [data-theme="${mode}"] .sl-inverted,
  [data-theme="${mode}"] .sl-inverted .sl-inverted .sl-inverted {
    color: var(--color-text);

    ${cssVariablesToStyles(computeCssVariables(icv, { ...mult,
      // lower saturation a bit more in inverted
      s: Math.min(mult.s, 0.9)
    }))}
}`
  };
};

const invertColorValue = (cv, isBgLight) => {
  return {
    h: cv.h,
    s: isBgLight ? r(cv.s * 0.8) : cv.s,
    // inverted bg is lighter based on how light regular bg is, w lightness of at least 10
    // l: isBgLight ? r(Math.max(10, 10 * ((cv.l * mult.l) / 100))) : r(100 - cv.l * 0.75),
    // inverted bg is darker if regular db is light, or darker otherwise
    l: isBgLight ? r(Math.max(10, Math.min(20, 100 - cv.l))) : r(100 - cv.l * 0.9)
  };
};

const cssVariablesToStyles = vars => {
  let styles = '';

  for (const k in vars) {
    styles += `    --${k}: ${vars[k]};\n`;
  }

  return styles;
};

const computeCssVariables = (cv, mult) => {
  const bgLuminance = getLuminance(stringifyHsl(cv.background));
  const textLuminance = getLuminance(stringifyHsl(cv.text));
  const textColor = getContrastColor(bgLuminance, textLuminance, 15, cv.text.h, cv.text.s, cv.text.l);
  cv.text = parseHsl(textColor); // if we're rendering light text, then we should also use brightened canvas + borders rather than darkened

  const brightenCanvas = cv.text.l > 50;
  const brightenBorder = brightenCanvas;
  const canvasHsl = {
    // pure is the darkest or lightest possible canvas color
    pure: {
      h: cv.background.h,
      s: cv.background.s,
      l: brightenCanvas ? Math.max(cv.background.l - 3, 3) : Math.min(cv.background.l + 10, 100)
    },
    50: {
      h: cv.background.h,
      s: r(cv.background.s * 0.8),
      l: r(cv.background.l * 0.97)
    },
    100: {
      h: cv.background.h,
      s: r(cv.background.s * 0.83),
      l: r(cv.background.l * 0.94)
    },
    200: {
      h: cv.background.h,
      s: r(cv.background.s * 0.88),
      l: r(cv.background.l * 0.91)
    },
    300: {
      h: cv.background.h,
      s: r(cv.background.s * 0.91),
      l: r(cv.background.l * 0.88)
    },
    400: {
      h: cv.background.h,
      s: r(cv.background.s * 0.93),
      l: r(cv.background.l * 0.85)
    },
    500: {
      h: cv.background.h,
      s: r(cv.background.s * 0.93),
      l: r(cv.background.l * 0.82)
    },
    dialog: {
      h: cv.background.h,
      s: cv.background.s,
      l: brightenCanvas ? Math.max(cv.background.l - 3, 3) : Math.min(cv.background.l + 10, 100)
    }
  };

  if (brightenCanvas) {
    // the darker the canvas is, the less we need to brighten things
    const brightenMult = 5 / (10 - Math.ceil(bgLuminance * 10));
    canvasHsl[50].l = r(cv.background.l + 40 * brightenMult);
    canvasHsl[100].l = r(cv.background.l + 25 * brightenMult);
    canvasHsl[200].l = r(cv.background.l + 15 * brightenMult);
    canvasHsl[300].l = r(cv.background.l + 8 * brightenMult);
    canvasHsl[400].l = r(cv.background.l + 6 * brightenMult);
    canvasHsl[500].l = r(cv.background.l + 4 * brightenMult); // on dark canvas, brighten dialog

    canvasHsl.dialog = canvasHsl[100];
  }

  let shadows = {
    sm: '0px 0px 1px rgba(67, 90, 111, 0.3)',
    md: '0px 2px 4px -2px rgba(0, 0, 0, 0.25), 0px 0px 1px rgba(67, 90, 111, 0.3)',
    lg: '0 4px 17px rgba(67, 90, 111, .2), 0 2px 3px rgba(0, 0, 0, .1), inset 0 0 0 .5px var(--color-canvas-pure), 0 0 0 .5px rgba(0, 0, 0, 0.2)',
    xl: '0px 0px 1px rgba(67, 90, 111, 0.3), 0px 8px 10px -4px rgba(67, 90, 111, 0.45)',
    '2xl': '0px 0px 1px rgba(67, 90, 111, 0.3), 0px 16px 24px -8px rgba(67, 90, 111, 0.45)'
  };
  let dropShadows = {
    default1: '0 0 0.5px rgba(0, 0, 0, 0.6)',
    default2: '0 2px 5px rgba(67, 90, 111, 0.3)'
  };

  if (brightenCanvas) {
    // darker shadows on dark canvas
    shadows = {
      sm: '0px 0px 1px rgba(11, 13, 19, 0.5)',
      md: '0px 2px 4px -2px rgba(0, 0, 0, 0.35), 0px 0px 1px rgba(11, 13, 19, 0.4)',
      lg: '0 2px 14px rgba(0,0,0,.55), 0 0 0 0.5px rgba(255,255,255,.2)',
      xl: '0px 0px 1px rgba(11, 13, 19, 0.4), 0px 8px 10px -4px rgba(11, 13, 19, 0.55)',
      '2xl': '0px 0px 1px rgba(11, 13, 19, 0.4), 0px 16px 24px -8px rgba(11, 13, 19, 0.55)'
    };
    dropShadows = {
      default1: '0 0 0.5px rgba(255, 255, 255, .5)',
      default2: '0 3px 8px rgba(0, 0, 0, 0.6)'
    };
  }

  return {
    'text-h': cv.text.h,
    'text-s': `${brightenBorder ? r(cv.text.s * 0.8) : cv.text.s}%`,
    'text-l': `${brightenBorder ? r(cv.text.l * 0.94) : cv.text.l}%`,
    'shadow-sm': shadows.sm,
    'shadow-md': shadows.md,
    'shadow-lg': shadows.lg,
    'shadow-xl': shadows.xl,
    'shadow-2xl': shadows['2xl'],
    'drop-shadow-default1': dropShadows.default1,
    'drop-shadow-default2': dropShadows.default2,
    'color-text-heading': `hsla(var(--text-h), var(--text-s), max(3, calc(var(--text-l) - 15)), 1)`,
    'color-text': `hsla(var(--text-h), var(--text-s), var(--text-l), 1)`,
    'color-text-paragraph': `hsla(var(--text-h), var(--text-s), var(--text-l), 0.9)`,
    'color-text-muted': `hsla(var(--text-h), var(--text-s), var(--text-l), 0.7)`,
    'color-text-light': `hsla(var(--text-h), var(--text-s), var(--text-l), 0.55)`,
    'color-text-disabled': `hsla(var(--text-h), var(--text-s), var(--text-l), 0.3)`,
    'canvas-h': `${cv.background.h}`,
    'canvas-s': `${cv.background.s}%`,
    'canvas-l': `${cv.background.l}%`,
    'color-canvas': `hsla(var(--canvas-h), var(--canvas-s), var(--canvas-l), 1)`,
    'color-canvas-pure': `hsla(${canvasHsl['pure'].h}, ${canvasHsl['pure'].s}%, ${r(canvasHsl['pure'].l)}%, 1)`,
    'color-canvas-tint': `hsla(${canvasHsl[50].h}, ${canvasHsl[50].s}%, ${r(canvasHsl[50].l)}%, ${brightenCanvas ? 0.2 : 0.5})`,
    'color-canvas-50': `hsla(${canvasHsl[50].h}, ${canvasHsl[50].s}%, ${r(canvasHsl[50].l * mult.l)}%, 1)`,
    'color-canvas-100': `hsla(${canvasHsl[100].h}, ${canvasHsl[100].s}%, ${r(canvasHsl[100].l * mult.l)}%, 1)`,
    'color-canvas-200': `hsla(${canvasHsl[200].h}, ${canvasHsl[200].s}%, ${r(canvasHsl[200].l * mult.l)}%, 1)`,
    'color-canvas-300': `hsla(${canvasHsl[300].h}, ${canvasHsl[300].s}%, ${r(canvasHsl[300].l * mult.l)}%, 1)`,
    'color-canvas-400': `hsla(${canvasHsl[400].h}, ${canvasHsl[400].s}%, ${r(canvasHsl[400].l * mult.l)}%, 1)`,
    'color-canvas-500': `hsla(${canvasHsl[500].h}, ${canvasHsl[500].s}%, ${r(canvasHsl[500].l * mult.l)}%, 1)`,
    'color-canvas-dialog': `hsla(${canvasHsl.dialog.h}, ${canvasHsl.dialog.s}%, ${r(canvasHsl.dialog.l * mult.l)}%, 1)`,
    'color-border-dark': `hsla(var(--canvas-h), ${r(cv.background.s * 0.75)}%, ${cv.background.l + (brightenBorder ? 13 : -28)}%, 0.5)`,
    'color-border': `hsla(var(--canvas-h), ${r(cv.background.s * 0.8)}%, ${cv.background.l + (brightenBorder ? 18 : -22)}%, 0.5)`,
    'color-border-light': `hsla(var(--canvas-h), ${r(cv.background.s * 0.6)}%, ${cv.background.l + (brightenBorder ? 24 : -16)}%, 0.5)`,
    'color-border-input': `hsla(var(--canvas-h), ${r(cv.background.s * 0.6)}%, ${cv.background.l + (brightenBorder ? 20 : -28)}%, 0.8)`,
    'color-border-button': `hsla(var(--canvas-h), ${r(cv.background.s * 0.6)}%, ${brightenBorder ? 80 : 20}%, 0.65)`,
    'primary-h': `${cv.primary.h}`,
    'primary-s': `${r(cv.primary.s * mult.s)}%`,
    'primary-l': `${r(cv.primary.l * mult.l)}%`,
    'color-text-primary': `hsla(${cv.primary.h}, ${r(cv.primary.s)}%, ${brightenBorder ? 70 : 40}%, 1)`,
    'color-primary-dark': `hsla(${cv.primary.h}, ${r(cv.primary.s * 0.8 * mult.s)}%, ${r(cv.primary.l * 0.85 * mult.l)}%, 1)`,
    'color-primary-darker': `hsla(${cv.primary.h}, ${r(cv.primary.s * 0.8 * mult.s)}%, ${r(cv.primary.l * 0.65 * mult.l)}%, 1)`,
    'color-primary': `hsla(${cv.primary.h}, ${r(cv.primary.s * mult.s)}%, ${r(cv.primary.l * mult.l)}%, 1)`,
    'color-primary-light': `hsla(${cv.primary.h}, ${r(cv.primary.s * mult.s)}%, ${r(cv.primary.l * 1.2 * mult.l)}%, 1)`,
    'color-primary-tint': `hsla(${cv.primary.h}, ${r(cv.primary.s * mult.s)}%, ${r(65 * mult.l)}%, 0.25)`,
    'color-on-primary': `hsla(${cv.primary.h}, ${cv.primary.s}%, 100%, 1)`,
    'success-h': `${cv.success.h}`,
    'success-s': `${cv.success.s}%`,
    'success-l': `${cv.success.l}%`,
    'color-text-success': `hsla(${cv.success.h}, ${r(cv.success.s * mult.s)}%, ${brightenBorder ? 60 : 40}%, 1)`,
    'color-success-dark': `hsla(${cv.success.h}, ${r(cv.success.s * 0.8 * mult.s)}%, ${r(cv.success.l * 0.85 * mult.l)}%, 1)`,
    'color-success-darker': `hsla(${cv.success.h}, ${r(cv.success.s * 0.8 * mult.s)}%, ${r(cv.success.l * 0.65 * mult.l)}%, 1)`,
    'color-success': `hsla(${cv.success.h}, ${r(cv.success.s * mult.s)}%, ${r(cv.success.l * mult.l)}%, 1)`,
    'color-success-light': `hsla(${cv.success.h}, ${r(cv.success.s * mult.s)}%, ${r(cv.success.l * 1.2 * mult.l)}%, 1)`,
    'color-success-tint': `hsla(${cv.success.h}, ${r(cv.success.s * mult.s)}%, ${r(65 * mult.l)}%, 0.25)`,
    'color-on-success': `hsla(${cv.success.h}, ${cv.success.s}%, 100%, 1)`,
    'warning-h': `${cv.warning.h}`,
    'warning-s': `${cv.warning.s}%`,
    'warning-l': `${cv.warning.l}%`,
    'color-text-warning': `hsla(${cv.warning.h}, ${r(cv.warning.s * mult.s)}%, ${brightenBorder ? 60 : 40}%, 1)`,
    'color-warning-dark': `hsla(${cv.warning.h}, ${r(cv.warning.s * 0.8 * mult.s)}%, ${r(cv.warning.l * 0.85 * mult.l)}%, 1)`,
    'color-warning-darker': `hsla(${cv.warning.h}, ${r(cv.warning.s * 0.8 * mult.s)}%, ${r(cv.warning.l * 0.65 * mult.l)}%, 1)`,
    'color-warning': `hsla(${cv.warning.h}, ${r(cv.warning.s * mult.s)}%, ${r(cv.warning.l * mult.l)}%, 1)`,
    'color-warning-light': `hsla(${cv.warning.h}, ${r(cv.warning.s * mult.s)}%, ${r(cv.warning.l * 1.2 * mult.l)}%, 1)`,
    'color-warning-tint': `hsla(${cv.warning.h}, ${r(cv.warning.s * mult.s)}%, ${r(65 * mult.l)}%, 0.25)`,
    'color-on-warning': `hsla(${cv.warning.h}, ${cv.warning.s}%, 100%, 1)`,
    'danger-h': `${cv.danger.h}`,
    'danger-s': `${cv.danger.s}%`,
    'danger-l': `${cv.danger.l}%`,
    'color-text-danger': `hsla(${cv.danger.h}, ${r(cv.danger.s * mult.s)}%, ${brightenBorder ? 60 : 40}%, 1)`,
    'color-danger-dark': `hsla(${cv.danger.h}, ${r(cv.danger.s * 0.8 * mult.s)}%, ${r(cv.danger.l * 0.85 * mult.l)}%, 1)`,
    'color-danger-darker': `hsla(${cv.danger.h}, ${r(cv.danger.s * 0.8 * mult.s)}%, ${r(cv.danger.l * 0.65 * mult.l)}%, 1)`,
    'color-danger': `hsla(${cv.danger.h}, ${r(cv.danger.s * mult.s)}%, ${r(cv.danger.l * mult.l)}%, 1)`,
    'color-danger-light': `hsla(${cv.danger.h}, ${r(cv.danger.s * mult.s)}%, ${r(cv.danger.l * 1.2 * mult.l)}%, 1)`,
    'color-danger-tint': `hsla(${cv.danger.h}, ${r(cv.danger.s * mult.s)}%, ${r(65 * mult.l)}%, 0.25)`,
    'color-on-danger': `hsla(${cv.danger.h}, ${cv.danger.s}%, 100%, 1)`
  };
};

function useControlledState(value, defaultValue, onChange) {
  let [stateValue, setStateValue] = useState(value || defaultValue);
  let ref = useRef(value !== undefined);
  let wasControlled = ref.current;
  let isControlled = value !== undefined; // Internal state reference for useCallback

  let stateRef = useRef(stateValue);

  if (wasControlled !== isControlled) {
    console.warn("WARN: A component changed from " + (wasControlled ? 'controlled' : 'uncontrolled') + " to " + (isControlled ? 'controlled' : 'uncontrolled') + ".");
  }

  ref.current = isControlled;
  let setValue = useCallback(function (value) {
    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }

    let onChangeCaller = function onChangeCaller(value) {
      if (onChange) {
        if (!Object.is(stateRef.current, value)) {
          for (var _len2 = arguments.length, onChangeArgs = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
            onChangeArgs[_key2 - 1] = arguments[_key2];
          }

          onChange(value, ...onChangeArgs);
        }
      }

      if (!isControlled) {
        stateRef.current = value;
      }
    };

    if (typeof value === 'function') {
      // this supports functional updates https://reactjs.org/docs/hooks-reference.html#functional-updates
      // when someone using useControlledState calls setControlledState(myFunc)
      // this will call our useState setState with a function as well which invokes myFunc and calls onChange with the value from myFunc
      // if we're in an uncontrolled state, then we also return the value of myFunc which to setState looks as though it was just called with myFunc from the beginning
      // otherwise we just return the controlled value, which won't cause a rerender because React knows to bail out when the value is the same
      let updateFunction = function updateFunction(oldValue) {
        for (var _len3 = arguments.length, functionArgs = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
          functionArgs[_key3 - 1] = arguments[_key3];
        }

        let interceptedValue = value(isControlled ? stateRef.current : oldValue, ...functionArgs);
        onChangeCaller(interceptedValue, ...args);

        if (!isControlled) {
          return interceptedValue;
        }

        return oldValue;
      };

      setStateValue(updateFunction);
    } else {
      if (!isControlled) {
        setStateValue(value);
      }

      onChangeCaller(value, ...args);
    }
  }, [isControlled, onChange]); // If a controlled component's value prop changes, we need to update stateRef

  if (isControlled) {
    stateRef.current = value;
  } else {
    value = stateValue;
  }

  return [value, setValue];
}

// Default context value to use in case there is no SSRProvider. This is fine for
// client-only apps. In order to support multiple copies of React Aria potentially
// being on the page at once, the prefix is set to a random number. SSRProvider
// will reset this to zero for consistency between server and client, so in the
// SSR case multiple copies of React Aria is not supported.
const $f01a183cc7bdff77849e49ad26eb904$var$defaultContext = {
  prefix: Math.round(Math.random() * 10000000000),
  current: 0
};

const $f01a183cc7bdff77849e49ad26eb904$var$SSRContext = /*#__PURE__*/_react__default.createContext($f01a183cc7bdff77849e49ad26eb904$var$defaultContext);

/**
 * When using SSR with React Aria, applications must be wrapped in an SSRProvider.
 * This ensures that auto generated ids are consistent between the client and server.
 */
function SSRProvider(props) {
  let cur = useContext($f01a183cc7bdff77849e49ad26eb904$var$SSRContext);
  let value = useMemo(() => ({
    // If this is the first SSRProvider, set to zero, otherwise increment.
    prefix: cur === $f01a183cc7bdff77849e49ad26eb904$var$defaultContext ? 0 : ++cur.prefix,
    current: 0
  }), [cur]);
  return /*#__PURE__*/_react__default.createElement($f01a183cc7bdff77849e49ad26eb904$var$SSRContext.Provider, {
    value: value
  }, props.children);
}
let $f01a183cc7bdff77849e49ad26eb904$var$canUseDOM = Boolean(typeof window !== 'undefined' && window.document && window.document.createElement);
/** @private */

function useSSRSafeId(defaultId) {
  let ctx = useContext($f01a183cc7bdff77849e49ad26eb904$var$SSRContext); // If we are rendering in a non-DOM environment, and there's no SSRProvider,
  // provide a warning to hint to the developer to add one.

  if (ctx === $f01a183cc7bdff77849e49ad26eb904$var$defaultContext && !$f01a183cc7bdff77849e49ad26eb904$var$canUseDOM) {
    console.warn('When server rendering, you must wrap your application in an <SSRProvider> to ensure consistent ids are generated between the client and server.');
  }

  return useMemo(() => defaultId || "react-aria-" + ctx.prefix + "-" + ++ctx.current, [defaultId]);
}
/**
 * Returns whether the component is currently being server side rendered or
 * hydrated on the client. Can be used to delay browser-specific rendering
 * until after hydration.
 */

function useIsSSR() {
  let cur = useContext($f01a183cc7bdff77849e49ad26eb904$var$SSRContext);
  let isInSSRContext = cur !== $f01a183cc7bdff77849e49ad26eb904$var$defaultContext;
  let [isSSR, setIsSSR] = useState(isInSSRContext); // If on the client, and the component was initially server rendered,
  // then schedule a layout effect to update the component after hydration.

  if (typeof window !== 'undefined' && isInSSRContext) {
    // This if statement technically breaks the rules of hooks, but is safe
    // because the condition never changes after mounting.
    // eslint-disable-next-line react-hooks/rules-of-hooks
    useLayoutEffect$1(() => {
      setIsSSR(false);
    }, []);
  }

  return isSSR;
}

// During SSR, React emits a warning when calling useLayoutEffect.
// Since neither useLayoutEffect nor useEffect run on the server,
// we can suppress this by replace it with a noop on the server.
const useLayoutEffect = typeof window !== 'undefined' ? _react__default.useLayoutEffect : () => {};
let $f8b5fdd96fb429d7102983f777c41307$var$idsUpdaterMap = new Map();
/**
 * If a default is not provided, generate an id.
 * @param defaultId - Default component id.
 */

function useId(defaultId) {
  let isRendering = useRef(true);
  isRendering.current = true;
  let [value, setValue] = useState(defaultId);
  let nextId = useRef(null); // don't memo this, we want it new each render so that the Effects always run

  let updateValue = val => {
    if (!isRendering.current) {
      setValue(val);
    } else {
      nextId.current = val;
    }
  };

  useLayoutEffect(() => {
    isRendering.current = false;
  }, [updateValue]);
  useEffect(() => {
    let newId = nextId.current;

    if (newId) {
      setValue(newId);
      nextId.current = null;
    }
  }, [setValue, updateValue]);
  let res = useSSRSafeId(value);
  $f8b5fdd96fb429d7102983f777c41307$var$idsUpdaterMap.set(res, updateValue);
  return res;
}
/**
 * Merges two ids.
 * Different ids will trigger a side-effect and re-render components hooked up with `useId`.
 */

function mergeIds(idA, idB) {
  if (idA === idB) {
    return idA;
  }

  let setIdA = $f8b5fdd96fb429d7102983f777c41307$var$idsUpdaterMap.get(idA);

  if (setIdA) {
    setIdA(idB);
    return idB;
  }

  let setIdB = $f8b5fdd96fb429d7102983f777c41307$var$idsUpdaterMap.get(idB);

  if (setIdB) {
    setIdB(idA);
    return idA;
  }

  return idB;
}
/**
 * Used to generate an id, and after render, check if that id is rendered so we know
 * if we can use it in places such as labelledby.
 */

function useSlotId() {
  let [id, setId] = useState(useId());
  useLayoutEffect(() => {
    let setCurr = $f8b5fdd96fb429d7102983f777c41307$var$idsUpdaterMap.get(id);

    if (setCurr && !document.getElementById(id)) {
      setId(null);
    }
  }, [id]);
  return id;
}

/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */

/**
 * Calls all functions in the order they were chained with the same arguments.
 */
function chain() {
  for (var _len = arguments.length, callbacks = new Array(_len), _key = 0; _key < _len; _key++) {
    callbacks[_key] = arguments[_key];
  }

  return function () {
    for (let callback of callbacks) {
      if (typeof callback === 'function') {
        callback(...arguments);
      }
    }
  };
}

/**
 * Merges multiple props objects together. Event handlers are chained,
 * classNames are combined, and ids are deduplicated - different ids
 * will trigger a side-effect and re-render components hooked up with `useId`.
 * For all other props, the last prop object overrides all previous ones.
 * @param args - Multiple sets of props to merge together.
 */
function mergeProps() {
  let result = {};

  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }

  for (let props of args) {
    for (let key in result) {
      // Chain events
      if (/^on[A-Z]/.test(key) && typeof result[key] === 'function' && typeof props[key] === 'function') {
        result[key] = chain(result[key], props[key]); // Merge classnames, sometimes classNames are empty string which eval to false, so we just need to do a type check
      } else if (key === 'className' && typeof result.className === 'string' && typeof props.className === 'string') {
        result[key] = cn(result.className, props.className);
      } else if (key === 'UNSAFE_className' && typeof result.UNSAFE_className === 'string' && typeof props.UNSAFE_className === 'string') {
        result[key] = cn(result.UNSAFE_className, props.UNSAFE_className);
      } else if (key === 'id' && result.id && props.id) {
        result.id = mergeIds(result.id, props.id); // Override others
      } else {
        result[key] = props[key] !== undefined ? props[key] : result[key];
      }
    } // Add props from b that are not in a


    for (let key in props) {
      if (result[key] === undefined) {
        result[key] = props[key];
      }
    }
  }

  return result;
}
const $f6a965352cabf1a7c37e8c1337e5eab$var$DOMPropNames = new Set(['id']);
const $f6a965352cabf1a7c37e8c1337e5eab$var$labelablePropNames = new Set(['aria-label', 'aria-labelledby', 'aria-describedby', 'aria-details']);
const $f6a965352cabf1a7c37e8c1337e5eab$var$propRe = /^(data-.*)$/;
/**
 * Filters out all props that aren't valid DOM props or defined via override prop obj.
 * @param props - The component props to be filtered.
 * @param opts - Props to override.
 */

function filterDOMProps(props, opts) {
  if (opts === void 0) {
    opts = {};
  }

  let {
    labelable,
    propNames
  } = opts;
  let filteredProps = {};

  for (const prop in props) {
    if (Object.prototype.hasOwnProperty.call(props, prop) && ($f6a965352cabf1a7c37e8c1337e5eab$var$DOMPropNames.has(prop) || labelable && $f6a965352cabf1a7c37e8c1337e5eab$var$labelablePropNames.has(prop) || propNames != null && propNames.has(prop) || $f6a965352cabf1a7c37e8c1337e5eab$var$propRe.test(prop))) {
      filteredProps[prop] = props[prop];
    }
  }

  return filteredProps;
}
// Currently necessary for Safari and old Edge:
// https://caniuse.com/#feat=mdn-api_htmlelement_focus_preventscroll_option
// See https://bugs.webkit.org/show_bug.cgi?id=178583
//
// Original licensing for the following methods can be found in the
// NOTICE file in the root directory of this source tree.
// See https://github.com/calvellido/focus-options-polyfill
function focusWithoutScrolling(element) {
  if ($bc7c9c3af78f5218ff72cecce15730$var$supportsPreventScroll()) {
    element.focus({
      preventScroll: true
    });
  } else {
    let scrollableElements = $bc7c9c3af78f5218ff72cecce15730$var$getScrollableElements(element);
    element.focus();
    $bc7c9c3af78f5218ff72cecce15730$var$restoreScrollPosition(scrollableElements);
  }
}
let $bc7c9c3af78f5218ff72cecce15730$var$supportsPreventScrollCached = null;

function $bc7c9c3af78f5218ff72cecce15730$var$supportsPreventScroll() {
  if ($bc7c9c3af78f5218ff72cecce15730$var$supportsPreventScrollCached == null) {
    $bc7c9c3af78f5218ff72cecce15730$var$supportsPreventScrollCached = false;

    try {
      var focusElem = document.createElement('div');
      focusElem.focus({
        get preventScroll() {
          $bc7c9c3af78f5218ff72cecce15730$var$supportsPreventScrollCached = true;
          return true;
        }

      });
    } catch (e) {// Ignore
    }
  }

  return $bc7c9c3af78f5218ff72cecce15730$var$supportsPreventScrollCached;
}

function $bc7c9c3af78f5218ff72cecce15730$var$getScrollableElements(element) {
  var parent = element.parentNode;
  var scrollableElements = [];
  var rootScrollingElement = document.scrollingElement || document.documentElement;

  while (parent instanceof HTMLElement && parent !== rootScrollingElement) {
    if (parent.offsetHeight < parent.scrollHeight || parent.offsetWidth < parent.scrollWidth) {
      scrollableElements.push({
        element: parent,
        scrollTop: parent.scrollTop,
        scrollLeft: parent.scrollLeft
      });
    }

    parent = parent.parentNode;
  }

  if (rootScrollingElement instanceof HTMLElement) {
    scrollableElements.push({
      element: rootScrollingElement,
      scrollTop: rootScrollingElement.scrollTop,
      scrollLeft: rootScrollingElement.scrollLeft
    });
  }

  return scrollableElements;
}

function $bc7c9c3af78f5218ff72cecce15730$var$restoreScrollPosition(scrollableElements) {
  for (let {
    element,
    scrollTop,
    scrollLeft
  } of scrollableElements) {
    element.scrollTop = scrollTop;
    element.scrollLeft = scrollLeft;
  }
}
// mapped to a set of CSS properties that are transitioning for that element.
// This is necessary rather than a simple count of transitions because of browser
// bugs, e.g. Chrome sometimes fires both transitionend and transitioncancel rather
// than one or the other. So we need to track what's actually transitioning so that
// we can ignore these duplicate events.
let $b3e8d5c5f32fa26afa6df1b81f09b6b8$var$transitionsByElement = new Map(); // A list of callbacks to call once there are no transitioning elements.

let $b3e8d5c5f32fa26afa6df1b81f09b6b8$var$transitionCallbacks = new Set();

function $b3e8d5c5f32fa26afa6df1b81f09b6b8$var$setupGlobalEvents() {
  if (typeof window === 'undefined') {
    return;
  }

  let onTransitionStart = e => {
    // Add the transitioning property to the list for this element.
    let transitions = $b3e8d5c5f32fa26afa6df1b81f09b6b8$var$transitionsByElement.get(e.target);

    if (!transitions) {
      transitions = new Set();
      $b3e8d5c5f32fa26afa6df1b81f09b6b8$var$transitionsByElement.set(e.target, transitions); // The transitioncancel event must be registered on the element itself, rather than as a global
      // event. This enables us to handle when the node is deleted from the document while it is transitioning.
      // In that case, the cancel event would have nowhere to bubble to so we need to handle it directly.

      e.target.addEventListener('transitioncancel', onTransitionEnd);
    }

    transitions.add(e.propertyName);
  };

  let onTransitionEnd = e => {
    // Remove property from list of transitioning properties.
    let properties = $b3e8d5c5f32fa26afa6df1b81f09b6b8$var$transitionsByElement.get(e.target);

    if (!properties) {
      return;
    }

    properties.delete(e.propertyName); // If empty, remove transitioncancel event, and remove the element from the list of transitioning elements.

    if (properties.size === 0) {
      e.target.removeEventListener('transitioncancel', onTransitionEnd);
      $b3e8d5c5f32fa26afa6df1b81f09b6b8$var$transitionsByElement.delete(e.target);
    } // If no transitioning elements, call all of the queued callbacks.


    if ($b3e8d5c5f32fa26afa6df1b81f09b6b8$var$transitionsByElement.size === 0) {
      for (let cb of $b3e8d5c5f32fa26afa6df1b81f09b6b8$var$transitionCallbacks) {
        cb();
      }

      $b3e8d5c5f32fa26afa6df1b81f09b6b8$var$transitionCallbacks.clear();
    }
  };

  document.body.addEventListener('transitionrun', onTransitionStart);
  document.body.addEventListener('transitionend', onTransitionEnd);
}

if (typeof document !== 'undefined') {
  if (document.readyState !== 'loading') {
    $b3e8d5c5f32fa26afa6df1b81f09b6b8$var$setupGlobalEvents();
  } else {
    document.addEventListener('DOMContentLoaded', $b3e8d5c5f32fa26afa6df1b81f09b6b8$var$setupGlobalEvents);
  }
}

function runAfterTransition(fn) {
  // Wait one frame to see if an animation starts, e.g. a transition on mount.
  requestAnimationFrame(() => {
    // If no transitions are running, call the function immediately.
    // Otherwise, add it to a list of callbacks to run at the end of the animation.
    if ($b3e8d5c5f32fa26afa6df1b81f09b6b8$var$transitionsByElement.size === 0) {
      fn();
    } else {
      $b3e8d5c5f32fa26afa6df1b81f09b6b8$var$transitionCallbacks.add(fn);
    }
  });
}
function useGlobalListeners() {
  let globalListeners = useRef(new Map());
  let addGlobalListener = useCallback((eventTarget, type, listener, options) => {
    globalListeners.current.set(listener, {
      type,
      eventTarget,
      options
    });
    eventTarget.addEventListener(type, listener, options);
  }, []);
  let removeGlobalListener = useCallback((eventTarget, type, listener, options) => {
    eventTarget.removeEventListener(type, listener, options);
    globalListeners.current.delete(listener);
  }, []);
  let removeAllGlobalListeners = useCallback(() => {
    globalListeners.current.forEach((value, key) => {
      removeGlobalListener(value.eventTarget, value.type, key, value.options);
    });
  }, [removeGlobalListener]); // eslint-disable-next-line arrow-body-style

  useEffect(() => {
    return removeAllGlobalListeners;
  }, [removeAllGlobalListeners]);
  return {
    addGlobalListener,
    removeGlobalListener,
    removeAllGlobalListeners
  };
}

/**
 * Merges aria-label and aria-labelledby into aria-labelledby when both exist.
 * @param props - Aria label props.
 * @param defaultLabel - Default value for aria-label when not present.
 */
function useLabels(props, defaultLabel) {
  let {
    id,
    'aria-label': label,
    'aria-labelledby': labelledBy
  } = props; // If there is both an aria-label and aria-labelledby,
  // combine them by pointing to the element itself.

  id = useId(id);

  if (labelledBy && label) {
    let ids = new Set([...labelledBy.trim().split(/\s+/), id]);
    labelledBy = [...ids].join(' ');
  } else if (labelledBy) {
    labelledBy = labelledBy.trim().split(/\s+/).join(' ');
  } // If no labels are provided, use the default


  if (!label && !labelledBy && defaultLabel) {
    label = defaultLabel;
  }

  return {
    id,
    'aria-label': label,
    'aria-labelledby': labelledBy
  };
}
// Syncs ref from context with ref passed to hook
function useSyncRef(context, ref) {
  useLayoutEffect(() => {
    if (context && context.ref && ref) {
      context.ref.current = ref.current;
      return () => {
        context.ref.current = null;
      };
    }
  }, [context, ref]);
}
function getScrollParent(node) {
  while (node && !$a164c39662575b65a0b01a73e313e5$var$isScrollable(node)) {
    node = node.parentElement;
  }

  return node || document.scrollingElement || document.documentElement;
}

function $a164c39662575b65a0b01a73e313e5$var$isScrollable(node) {
  let style = window.getComputedStyle(node);
  return /(auto|scroll)/.test(style.overflow + style.overflowX + style.overflowY);
}

function $b0986c1243f71db8e992f67117a1ed9$var$testUserAgent(re) {
  return typeof window !== 'undefined' && window.navigator != null ? re.test(window.navigator.userAgent) : false;
}

function $b0986c1243f71db8e992f67117a1ed9$var$testPlatform(re) {
  return typeof window !== 'undefined' && window.navigator != null ? re.test(window.navigator.platform) : false;
}

function isMac() {
  return $b0986c1243f71db8e992f67117a1ed9$var$testPlatform(/^Mac/);
}
function isIPhone() {
  return $b0986c1243f71db8e992f67117a1ed9$var$testPlatform(/^iPhone/);
}
function isIPad() {
  return $b0986c1243f71db8e992f67117a1ed9$var$testPlatform(/^iPad/) || // iPadOS 13 lies and says it's a Mac, but we can distinguish by detecting touch support.
  isMac() && navigator.maxTouchPoints > 1;
}
function isIOS() {
  return isIPhone() || isIPad();
}
function isWebKit() {
  return $b0986c1243f71db8e992f67117a1ed9$var$testUserAgent(/AppleWebKit/) && !isChrome();
}
function isChrome() {
  return $b0986c1243f71db8e992f67117a1ed9$var$testUserAgent(/Chrome/);
}

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */
// https://en.wikipedia.org/wiki/Right-to-left
const $d26e725ad56fbcb2c25f52b7de27$var$RTL_SCRIPTS = new Set(['Arab', 'Syrc', 'Samr', 'Mand', 'Thaa', 'Mend', 'Nkoo', 'Adlm', 'Rohg', 'Hebr']);
const $d26e725ad56fbcb2c25f52b7de27$var$RTL_LANGS = new Set(['ae', 'ar', 'arc', 'bcc', 'bqi', 'ckb', 'dv', 'fa', 'glk', 'he', 'ku', 'mzn', 'nqo', 'pnb', 'ps', 'sd', 'ug', 'ur', 'yi']);
/**
 * Determines if a locale is read right to left using [Intl.Locale]{@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl/Locale}.
 */

function $d26e725ad56fbcb2c25f52b7de27$export$isRTL(locale) {
  // If the Intl.Locale API is available, use it to get the script for the locale.
  // This is more accurate than guessing by language, since languages can be written in multiple scripts.
  // @ts-ignore
  if (Intl.Locale) {
    // @ts-ignore
    let script = new Intl.Locale(locale).maximize().script;
    return $d26e725ad56fbcb2c25f52b7de27$var$RTL_SCRIPTS.has(script);
  } // If not, just guess by the language (first part of the locale)


  let lang = locale.split('-')[0];
  return $d26e725ad56fbcb2c25f52b7de27$var$RTL_LANGS.has(lang);
}

/**
 * Gets the locale setting of the browser.
 */
function $e851d0b81d46abd5f971c8e95c27f1$export$getDefaultLocale() {
  // @ts-ignore
  let locale = typeof navigator !== 'undefined' && (navigator.language || navigator.userLanguage) || 'en-US';
  return {
    locale,
    direction: $d26e725ad56fbcb2c25f52b7de27$export$isRTL(locale) ? 'rtl' : 'ltr'
  };
}

let $e851d0b81d46abd5f971c8e95c27f1$var$currentLocale = $e851d0b81d46abd5f971c8e95c27f1$export$getDefaultLocale();
let $e851d0b81d46abd5f971c8e95c27f1$var$listeners = new Set();

function $e851d0b81d46abd5f971c8e95c27f1$var$updateLocale() {
  $e851d0b81d46abd5f971c8e95c27f1$var$currentLocale = $e851d0b81d46abd5f971c8e95c27f1$export$getDefaultLocale();

  for (let listener of $e851d0b81d46abd5f971c8e95c27f1$var$listeners) {
    listener($e851d0b81d46abd5f971c8e95c27f1$var$currentLocale);
  }
}
/**
 * Returns the current browser/system language, and updates when it changes.
 */


function $e851d0b81d46abd5f971c8e95c27f1$export$useDefaultLocale() {
  let isSSR = useIsSSR();
  let [defaultLocale, setDefaultLocale] = useState($e851d0b81d46abd5f971c8e95c27f1$var$currentLocale);
  useEffect(() => {
    if ($e851d0b81d46abd5f971c8e95c27f1$var$listeners.size === 0) {
      window.addEventListener('languagechange', $e851d0b81d46abd5f971c8e95c27f1$var$updateLocale);
    }

    $e851d0b81d46abd5f971c8e95c27f1$var$listeners.add(setDefaultLocale);
    return () => {
      $e851d0b81d46abd5f971c8e95c27f1$var$listeners.delete(setDefaultLocale);

      if ($e851d0b81d46abd5f971c8e95c27f1$var$listeners.size === 0) {
        window.removeEventListener('languagechange', $e851d0b81d46abd5f971c8e95c27f1$var$updateLocale);
      }
    };
  }, []); // We cannot determine the browser's language on the server, so default to
  // en-US. This will be updated after hydration on the client to the correct value.

  if (isSSR) {
    return {
      locale: 'en-US',
      direction: 'ltr'
    };
  }

  return defaultLocale;
}

const $cff8541df3b5c83067b2ab3ee0d20$var$I18nContext = /*#__PURE__*/_react__default.createContext(null);
/**
 * Returns the current locale and layout direction.
 */

function useLocale() {
  let defaultLocale = $e851d0b81d46abd5f971c8e95c27f1$export$useDefaultLocale();
  let context = useContext($cff8541df3b5c83067b2ab3ee0d20$var$I18nContext);
  return context || defaultLocale;
}
let $a4045a18d7252bf6de9312e613c4e$var$cache = new Map();
/**
 * Provides localized string collation for the current locale. Automatically updates when the locale changes,
 * and handles caching of the collator for performance.
 * @param options - Collator options.
 */

function useCollator(options) {
  let {
    locale
  } = useLocale();
  let cacheKey = locale + (options ? Object.entries(options).sort((a, b) => a[0] < b[0] ? -1 : 1).join() : '');

  if ($a4045a18d7252bf6de9312e613c4e$var$cache.has(cacheKey)) {
    return $a4045a18d7252bf6de9312e613c4e$var$cache.get(cacheKey);
  }

  let formatter = new Intl.Collator(locale, options);
  $a4045a18d7252bf6de9312e613c4e$var$cache.set(cacheKey, formatter);
  return formatter;
}

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

function createDOMRef(ref) {
  return {
    UNSAFE_getDOMNode() {
      return ref.current;
    }

  };
}
function createFocusableRef(domRef, focusableRef) {
  if (focusableRef === void 0) {
    focusableRef = domRef;
  }

  return _extends({}, createDOMRef(domRef), {
    focus() {
      if (focusableRef.current) {
        focusableRef.current.focus();
      }
    }

  });
}
function useDOMRef(ref) {
  let domRef = useRef(null);
  useImperativeHandle(ref, () => createDOMRef(domRef));
  return domRef;
}
function useFocusableRef(ref, focusableRef) {
  let domRef = useRef(null);
  useImperativeHandle(ref, () => createFocusableRef(domRef, focusableRef));
  return domRef;
}
function unwrapDOMRef(ref) {
  return {
    get current() {
      return ref.current && ref.current.UNSAFE_getDOMNode();
    }

  };
}
function useUnwrapDOMRef(ref) {
  return useMemo(() => unwrapDOMRef(ref), [ref]);
}

const $f838b598b03ac1d3fd85d427f7d189$var$Context = /*#__PURE__*/_react__default.createContext(null);

$f838b598b03ac1d3fd85d427f7d189$var$Context.displayName = 'BreakpointContext';
const baseStyleProps = {
  margin: ['margin', dimensionValue],
  marginStart: [$e8ff0135e78060c4cd2a3148981a7a3$var$rtl('marginLeft', 'marginRight'), dimensionValue],
  marginEnd: [$e8ff0135e78060c4cd2a3148981a7a3$var$rtl('marginRight', 'marginLeft'), dimensionValue],
  // marginLeft: ['marginLeft', dimensionValue],
  // marginRight: ['marginRight', dimensionValue],
  marginTop: ['marginTop', dimensionValue],
  marginBottom: ['marginBottom', dimensionValue],
  marginX: [['marginLeft', 'marginRight'], dimensionValue],
  marginY: [['marginTop', 'marginBottom'], dimensionValue],
  width: ['width', dimensionValue],
  height: ['height', dimensionValue],
  minWidth: ['minWidth', dimensionValue],
  minHeight: ['minHeight', dimensionValue],
  maxWidth: ['maxWidth', dimensionValue],
  maxHeight: ['maxHeight', dimensionValue],
  isHidden: ['display', $e8ff0135e78060c4cd2a3148981a7a3$var$hiddenValue],
  alignSelf: ['alignSelf', passthroughStyle],
  justifySelf: ['justifySelf', passthroughStyle],
  position: ['position', $e8ff0135e78060c4cd2a3148981a7a3$var$anyValue],
  zIndex: ['zIndex', $e8ff0135e78060c4cd2a3148981a7a3$var$anyValue],
  top: ['top', dimensionValue],
  bottom: ['bottom', dimensionValue],
  start: [$e8ff0135e78060c4cd2a3148981a7a3$var$rtl('left', 'right'), dimensionValue],
  end: [$e8ff0135e78060c4cd2a3148981a7a3$var$rtl('right', 'left'), dimensionValue],
  left: ['left', dimensionValue],
  right: ['right', dimensionValue],
  order: ['order', $e8ff0135e78060c4cd2a3148981a7a3$var$anyValue],
  flex: ['flex', $e8ff0135e78060c4cd2a3148981a7a3$var$flexValue],
  flexGrow: ['flexGrow', passthroughStyle],
  flexShrink: ['flexShrink', passthroughStyle],
  flexBasis: ['flexBasis', passthroughStyle],
  gridArea: ['gridArea', passthroughStyle],
  gridColumn: ['gridColumn', passthroughStyle],
  gridColumnEnd: ['gridColumnEnd', passthroughStyle],
  gridColumnStart: ['gridColumnStart', passthroughStyle],
  gridRow: ['gridRow', passthroughStyle],
  gridRowEnd: ['gridRowEnd', passthroughStyle],
  gridRowStart: ['gridRowStart', passthroughStyle]
};
_extends({}, baseStyleProps, {
  backgroundColor: ['backgroundColor', $e8ff0135e78060c4cd2a3148981a7a3$var$backgroundColorValue],
  borderWidth: ['borderWidth', $e8ff0135e78060c4cd2a3148981a7a3$var$borderSizeValue],
  borderStartWidth: [$e8ff0135e78060c4cd2a3148981a7a3$var$rtl('borderLeftWidth', 'borderRightWidth'), $e8ff0135e78060c4cd2a3148981a7a3$var$borderSizeValue],
  borderEndWidth: [$e8ff0135e78060c4cd2a3148981a7a3$var$rtl('borderRightWidth', 'borderLeftWidth'), $e8ff0135e78060c4cd2a3148981a7a3$var$borderSizeValue],
  borderLeftWidth: ['borderLeftWidth', $e8ff0135e78060c4cd2a3148981a7a3$var$borderSizeValue],
  borderRightWidth: ['borderRightWidth', $e8ff0135e78060c4cd2a3148981a7a3$var$borderSizeValue],
  borderTopWidth: ['borderTopWidth', $e8ff0135e78060c4cd2a3148981a7a3$var$borderSizeValue],
  borderBottomWidth: ['borderBottomWidth', $e8ff0135e78060c4cd2a3148981a7a3$var$borderSizeValue],
  borderXWidth: [['borderLeftWidth', 'borderRightWidth'], $e8ff0135e78060c4cd2a3148981a7a3$var$borderSizeValue],
  borderYWidth: [['borderTopWidth', 'borderBottomWidth'], $e8ff0135e78060c4cd2a3148981a7a3$var$borderSizeValue],
  borderColor: ['borderColor', $e8ff0135e78060c4cd2a3148981a7a3$var$borderColorValue],
  borderStartColor: [$e8ff0135e78060c4cd2a3148981a7a3$var$rtl('borderLeftColor', 'borderRightColor'), $e8ff0135e78060c4cd2a3148981a7a3$var$borderColorValue],
  borderEndColor: [$e8ff0135e78060c4cd2a3148981a7a3$var$rtl('borderRightColor', 'borderLeftColor'), $e8ff0135e78060c4cd2a3148981a7a3$var$borderColorValue],
  borderLeftColor: ['borderLeftColor', $e8ff0135e78060c4cd2a3148981a7a3$var$borderColorValue],
  borderRightColor: ['borderRightColor', $e8ff0135e78060c4cd2a3148981a7a3$var$borderColorValue],
  borderTopColor: ['borderTopColor', $e8ff0135e78060c4cd2a3148981a7a3$var$borderColorValue],
  borderBottomColor: ['borderBottomColor', $e8ff0135e78060c4cd2a3148981a7a3$var$borderColorValue],
  borderXColor: [['borderLeftColor', 'borderRightColor'], $e8ff0135e78060c4cd2a3148981a7a3$var$borderColorValue],
  borderYColor: [['borderTopColor', 'borderBottomColor'], $e8ff0135e78060c4cd2a3148981a7a3$var$borderColorValue],
  borderRadius: ['borderRadius', $e8ff0135e78060c4cd2a3148981a7a3$var$borderRadiusValue],
  borderTopStartRadius: [$e8ff0135e78060c4cd2a3148981a7a3$var$rtl('borderTopLeftRadius', 'borderTopRightRadius'), $e8ff0135e78060c4cd2a3148981a7a3$var$borderRadiusValue],
  borderTopEndRadius: [$e8ff0135e78060c4cd2a3148981a7a3$var$rtl('borderTopRightRadius', 'borderTopLeftRadius'), $e8ff0135e78060c4cd2a3148981a7a3$var$borderRadiusValue],
  borderBottomStartRadius: [$e8ff0135e78060c4cd2a3148981a7a3$var$rtl('borderBottomLeftRadius', 'borderBottomRightRadius'), $e8ff0135e78060c4cd2a3148981a7a3$var$borderRadiusValue],
  borderBottomEndRadius: [$e8ff0135e78060c4cd2a3148981a7a3$var$rtl('borderBottomRightRadius', 'borderBottomLeftRadius'), $e8ff0135e78060c4cd2a3148981a7a3$var$borderRadiusValue],
  borderTopLeftRadius: ['borderTopLeftRadius', $e8ff0135e78060c4cd2a3148981a7a3$var$borderRadiusValue],
  borderTopRightRadius: ['borderTopRightRadius', $e8ff0135e78060c4cd2a3148981a7a3$var$borderRadiusValue],
  borderBottomLeftRadius: ['borderBottomLeftRadius', $e8ff0135e78060c4cd2a3148981a7a3$var$borderRadiusValue],
  borderBottomRightRadius: ['borderBottomRightRadius', $e8ff0135e78060c4cd2a3148981a7a3$var$borderRadiusValue],
  padding: ['padding', dimensionValue],
  paddingStart: [$e8ff0135e78060c4cd2a3148981a7a3$var$rtl('paddingLeft', 'paddingRight'), dimensionValue],
  paddingEnd: [$e8ff0135e78060c4cd2a3148981a7a3$var$rtl('paddingRight', 'paddingLeft'), dimensionValue],
  paddingLeft: ['paddingLeft', dimensionValue],
  paddingRight: ['paddingRight', dimensionValue],
  paddingTop: ['paddingTop', dimensionValue],
  paddingBottom: ['paddingBottom', dimensionValue],
  paddingX: [['paddingLeft', 'paddingRight'], dimensionValue],
  paddingY: [['paddingTop', 'paddingBottom'], dimensionValue],
  overflow: ['overflow', passthroughStyle]
});

function $e8ff0135e78060c4cd2a3148981a7a3$var$rtl(ltr, rtl) {
  return direction => direction === 'rtl' ? rtl : ltr;
}

const $e8ff0135e78060c4cd2a3148981a7a3$var$UNIT_RE = /(%|px|em|rem|vw|vh|auto|cm|mm|in|pt|pc|ex|ch|rem|vmin|vmax|fr)$/;
const $e8ff0135e78060c4cd2a3148981a7a3$var$FUNC_RE = /^\s*\w+\(/;
const $e8ff0135e78060c4cd2a3148981a7a3$var$SPECTRUM_VARIABLE_RE = /(static-)?size-\d+|single-line-(height|width)/g;
function dimensionValue(value) {
  if (typeof value === 'number') {
    return value + 'px';
  }

  if ($e8ff0135e78060c4cd2a3148981a7a3$var$UNIT_RE.test(value)) {
    return value;
  }

  if ($e8ff0135e78060c4cd2a3148981a7a3$var$FUNC_RE.test(value)) {
    return value.replace($e8ff0135e78060c4cd2a3148981a7a3$var$SPECTRUM_VARIABLE_RE, 'var(--spectrum-global-dimension-$&, var(--spectrum-alias-$&))');
  }

  return "var(--spectrum-global-dimension-" + value + ", var(--spectrum-alias-" + value + "))";
}

function $e8ff0135e78060c4cd2a3148981a7a3$var$colorValue(value, type) {
  if (type === void 0) {
    type = 'default';
  }

  return "var(--spectrum-global-color-" + value + ", var(--spectrum-semantic-" + value + "-color-" + type + "))";
}

function $e8ff0135e78060c4cd2a3148981a7a3$var$backgroundColorValue(value) {
  return "var(--spectrum-alias-background-color-" + value + ", " + $e8ff0135e78060c4cd2a3148981a7a3$var$colorValue(value, 'background') + ")";
}

function $e8ff0135e78060c4cd2a3148981a7a3$var$borderColorValue(value) {
  if (value === 'default') {
    return 'var(--spectrum-alias-border-color)';
  }

  return "var(--spectrum-alias-border-color-" + value + ", " + $e8ff0135e78060c4cd2a3148981a7a3$var$colorValue(value, 'border') + ")";
}

function $e8ff0135e78060c4cd2a3148981a7a3$var$borderSizeValue(value) {
  return "var(--spectrum-alias-border-size-" + value + ")";
}

function $e8ff0135e78060c4cd2a3148981a7a3$var$borderRadiusValue(value) {
  return "var(--spectrum-alias-border-radius-" + value + ")";
}

function $e8ff0135e78060c4cd2a3148981a7a3$var$hiddenValue(value) {
  return value ? 'none' : undefined;
}

function $e8ff0135e78060c4cd2a3148981a7a3$var$anyValue(value) {
  return value;
}

function $e8ff0135e78060c4cd2a3148981a7a3$var$flexValue(value) {
  if (typeof value === 'boolean') {
    return value ? '1' : undefined;
  }

  return '' + value;
}
function passthroughStyle(value) {
  return value;
}
// This hook works like `useState`, but when setting the value, you pass a generator function
// that can yield multiple values. Each yielded value updates the state and waits for the next
// layout effect, then continues the generator. This allows sequential updates to state to be
// written linearly.
function useValueEffect(defaultValue) {
  let [value, setValue] = useState(defaultValue);
  let effect = useRef(null); // Store the function in a ref so we can always access the current version
  // which has the proper `value` in scope.

  let nextRef = useRef(null);

  nextRef.current = () => {
    // Run the generator to the next yield.
    let newValue = effect.current.next(); // If the generator is done, reset the effect.

    if (newValue.done) {
      effect.current = null;
      return;
    } // If the value is the same as the current value,
    // then continue to the next yield. Otherwise,
    // set the value in state and wait for the next layout effect.


    if (value === newValue.value) {
      nextRef.current();
    } else {
      setValue(newValue.value);
    }
  };

  useLayoutEffect(() => {
    // If there is an effect currently running, continue to the next yield.
    if (effect.current) {
      nextRef.current();
    }
  });
  let queue = useCallback(fn => {
    effect.current = fn();
    nextRef.current();
  }, [effect, nextRef]);
  return [value, queue];
}

const WithDomRef = /*#__PURE__*/forwardRef(function WithDomRef({
  children
}, ref) {
  return /*#__PURE__*/_react.cloneElement(children, {
    ref: useDOMRef(ref)
  });
});

const sizes$8 = {
  lg: {
    h: 'md',
    px: 3,
    py: 0.5,
    fontSize: 'lg',
    rounded: 'full',
    leftIconMx: -2,
    leftIconMr: 2,
    rightIconMl: 1,
    rightIconMr: -0.5,
    iconSize: '15px'
  },
  md: {
    h: 'sm',
    px: 2,
    py: 0.5,
    fontSize: 'base',
    rounded: 'full',
    leftIconMx: -1,
    leftIconMr: 1.5,
    rightIconMl: 0.5,
    rightIconMr: -0.5,
    iconSize: '13px'
  },
  sm: {
    h: 'xs',
    px: 1.5,
    py: 0.5,
    fontSize: 'sm',
    rounded: 'full',
    leftIconMx: -1,
    leftIconMr: 1,
    rightIconMl: 0.5,
    rightIconMr: -0.5,
    iconSize: '13px'
  }
};
const variants$6 = {
  solid: {
    default: {
      border: 0,
      color: 'paragraph',
      fontSize: 'paragraph-tiny',
      bg: {
        default: 'canvas-100'
      },
      borderColor: {
        default: 'input'
      }
    },
    success: {
      color: 'on-success',
      borderColor: 'success',
      bg: {
        default: 'success'
      }
    },
    warning: {
      color: 'on-warning',
      borderColor: 'warning',
      bg: {
        default: 'warning'
      }
    },
    danger: {
      color: 'on-danger',
      borderColor: 'danger',
      bg: {
        default: 'danger'
      }
    }
  },
  minimal: {
    default: {
      color: 'paragraph',
      fontSize: 'paragraph-tiny',
      bg: {
        default: 'transparent'
      },
      borderColor: 'transparent'
    },
    success: {
      color: 'success'
    },
    warning: {
      color: 'warning'
    },
    danger: {
      color: 'danger'
    }
  },
  outline: {
    default: {
      color: 'paragraph',
      fontSize: 'paragraph-tiny',
      bg: {
        default: 'canvas'
      },
      borderColor: {
        default: 'input'
      },
      ring: false
    },
    success: {
      borderColor: 'success',
      color: 'success'
    },
    warning: {
      borderColor: 'warning',
      color: 'warning'
    },
    danger: {
      borderColor: 'danger',
      color: 'danger'
    }
  }
};

const defaultElement$9 = 'span';
const Badge = /*#__PURE__*/_react.memo( /*#__PURE__*/forwardRef(function Input({
  appearance = 'solid',
  size = 'md',
  as = defaultElement$9,
  className,
  intent,
  icon,
  iconRight,
  onRemove,
  children,
  ...props
}, ref) {
  const {
    remainingProps
  } = splitBoxProps(props);
  const stateProps = { ...variants$6[appearance].default,
    ...variants$6[appearance][intent]
  };
  return jsx(Box, Object.assign({
    ref: ref,
    as: as,
    h: sizes$8[size].h,
    px: sizes$8[size].px,
    py: sizes$8[size].py,
    fontSize: sizes$8[size].fontSize,
    rounded: sizes$8[size].rounded,
    borderColor: "on-primary",
    className: cn('sl-badge', className, {
      'sl-badge--remove': !!onRemove
    })
  }, stateProps, remainingProps, {
    children: jsxs(Flex, Object.assign({
      justifyItems: "start",
      alignItems: "center"
    }, {
      children: [icon ? jsx(BadgeIcon, {
        icon: icon,
        size: size,
        hasContent: !!children
      }, void 0) : null, jsx(Flex, {
        children: children
      }, void 0), iconRight && !onRemove ? jsx(BadgeRightIcon, {
        icon: iconRight,
        size: size
      }, void 0) : null, onRemove ? jsx(Box, Object.assign({
        as: 'a',
        onClick: onRemove,
        ml: 0.5
      }, {
        children: jsx(BadgeRightIcon, {
          icon: ['fas', 'times-circle'],
          size: size
        }, void 0)
      }), void 0) : null]
    }), void 0)
  }), void 0);
}));

const BadgeIcon = ({
  icon,
  size,
  hasContent,
  pulse
}) => {
  let elem = icon;

  if (isIconProp(icon)) {
    elem = jsx(Icon, {
      icon: icon,
      style: {
        fontSize: sizes$8[size].iconSize
      },
      pulse: pulse,
      fixedWidth: true
    }, void 0);
  }

  return jsx(Box, Object.assign({
    "data-testid": "icon",
    mr: hasContent ? sizes$8[size].leftIconMr : undefined,
    mx: hasContent ? undefined : sizes$8[size].leftIconMx
  }, {
    children: elem
  }), void 0);
};

const BadgeRightIcon = ({
  icon,
  size
}) => {
  let elem = icon;

  if (isIconProp(icon)) {
    elem = jsx(Icon, {
      icon: icon,
      style: {
        fontSize: sizes$8[size].iconSize
      },
      fixedWidth: true
    }, void 0);
  }

  return jsx(Box, Object.assign({
    "data-testid": "iconright",
    ml: sizes$8[size].rightIconMl,
    mr: sizes$8[size].rightIconMr
  }, {
    children: elem
  }), void 0);
};

let $e17c9db826984f8ab8e5d837bf0b8$var$state = 'default';
let $e17c9db826984f8ab8e5d837bf0b8$var$savedUserSelect = '';

function $e17c9db826984f8ab8e5d837bf0b8$export$disableTextSelection() {
  if ($e17c9db826984f8ab8e5d837bf0b8$var$state === 'default') {
    $e17c9db826984f8ab8e5d837bf0b8$var$savedUserSelect = document.documentElement.style.webkitUserSelect;
    document.documentElement.style.webkitUserSelect = 'none';
  }

  $e17c9db826984f8ab8e5d837bf0b8$var$state = 'disabled';
}

function $e17c9db826984f8ab8e5d837bf0b8$export$restoreTextSelection() {
  // If the state is already default, there's nothing to do.
  // If it is restoring, then there's no need to queue a second restore.
  if ($e17c9db826984f8ab8e5d837bf0b8$var$state !== 'disabled') {
    return;
  }

  $e17c9db826984f8ab8e5d837bf0b8$var$state = 'restoring'; // There appears to be a delay on iOS where selection still might occur
  // after pointer up, so wait a bit before removing user-select.

  setTimeout(() => {
    // Wait for any CSS transitions to complete so we don't recompute style
    // for the whole page in the middle of the animation and cause jank.
    runAfterTransition(() => {
      // Avoid race conditions
      if ($e17c9db826984f8ab8e5d837bf0b8$var$state === 'restoring') {
        if (document.documentElement.style.webkitUserSelect === 'none') {
          document.documentElement.style.webkitUserSelect = $e17c9db826984f8ab8e5d837bf0b8$var$savedUserSelect || '';
        }

        $e17c9db826984f8ab8e5d837bf0b8$var$savedUserSelect = '';
        $e17c9db826984f8ab8e5d837bf0b8$var$state = 'default';
      }
    });
  }, 300);
}

/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */
// Original licensing for the following method can be found in the
// NOTICE file in the root directory of this source tree.
// See https://github.com/facebook/react/blob/3c713d513195a53788b3f8bb4b70279d68b15bcc/packages/react-interactions/events/src/dom/shared/index.js#L74-L87
// Keyboards, Assistive Technologies, and element.click() all produce a "virtual"
// click event. This is a method of inferring such clicks. Every browser except
// IE 11 only sets a zero value of "detail" for click events that are "virtual".
// However, IE 11 uses a zero value for all click events. For IE 11 we rely on
// the quirk that it produces click events that are of type PointerEvent, and
// where only the "virtual" click lacks a pointerType field.
function $f67ef9f1b8ed09b4b00fd0840cd8b94b$export$isVirtualClick(event) {
  // JAWS/NVDA with Firefox.
  if (event.mozInputSource === 0 && event.isTrusted) {
    return true;
  }

  return event.detail === 0 && !event.pointerType;
}

const $a3ff51240de6f955c79cf17a88e349$export$PressResponderContext = /*#__PURE__*/_react__default.createContext(null);

$a3ff51240de6f955c79cf17a88e349$export$PressResponderContext.displayName = 'PressResponderContext';

function $ffc54430b1dbeee65879852feaaff07d$var$usePressResponderContext(props) {
  // Consume context from <PressResponder> and merge with props.
  let context = useContext($a3ff51240de6f955c79cf17a88e349$export$PressResponderContext);

  if (context) {
    let {
      register
    } = context,
        contextProps = _objectWithoutPropertiesLoose(context, ["register"]);

    props = mergeProps(contextProps, props);
    register();
  }

  useSyncRef(context, props.ref);
  return props;
}
/**
 * Handles press interactions across mouse, touch, keyboard, and screen readers.
 * It normalizes behavior across browsers and platforms, and handles many nuances
 * of dealing with pointer and keyboard events.
 */


function usePress(props) {
  let _usePressResponderCon = $ffc54430b1dbeee65879852feaaff07d$var$usePressResponderContext(props),
      {
    onPress,
    onPressChange,
    onPressStart,
    onPressEnd,
    onPressUp,
    isDisabled,
    isPressed: isPressedProp,
    preventFocusOnPress
  } = _usePressResponderCon,
      domProps = _objectWithoutPropertiesLoose(_usePressResponderCon, ["onPress", "onPressChange", "onPressStart", "onPressEnd", "onPressUp", "isDisabled", "isPressed", "preventFocusOnPress", "ref"]);

  let propsRef = useRef(null);
  propsRef.current = {
    onPress,
    onPressChange,
    onPressStart,
    onPressEnd,
    onPressUp,
    isDisabled
  };
  let [isPressed, setPressed] = useState(false);
  let ref = useRef({
    isPressed: false,
    ignoreEmulatedMouseEvents: false,
    ignoreClickAfterPress: false,
    didFirePressStart: false,
    activePointerId: null,
    target: null,
    isOverTarget: false,
    pointerType: null
  });
  let {
    addGlobalListener,
    removeAllGlobalListeners
  } = useGlobalListeners();
  let pressProps = useMemo(() => {
    let state = ref.current;

    let triggerPressStart = (originalEvent, pointerType) => {
      let {
        onPressStart,
        onPressChange,
        isDisabled
      } = propsRef.current;

      if (isDisabled || state.didFirePressStart) {
        return;
      }

      if (onPressStart) {
        onPressStart({
          type: 'pressstart',
          pointerType,
          target: originalEvent.currentTarget,
          shiftKey: originalEvent.shiftKey,
          metaKey: originalEvent.metaKey,
          ctrlKey: originalEvent.ctrlKey
        });
      }

      if (onPressChange) {
        onPressChange(true);
      }

      state.didFirePressStart = true;
      setPressed(true);
    };

    let triggerPressEnd = function triggerPressEnd(originalEvent, pointerType, wasPressed) {
      if (wasPressed === void 0) {
        wasPressed = true;
      }

      let {
        onPressEnd,
        onPressChange,
        onPress,
        isDisabled
      } = propsRef.current;

      if (!state.didFirePressStart) {
        return;
      }

      state.ignoreClickAfterPress = true;
      state.didFirePressStart = false;

      if (onPressEnd) {
        onPressEnd({
          type: 'pressend',
          pointerType,
          target: originalEvent.currentTarget,
          shiftKey: originalEvent.shiftKey,
          metaKey: originalEvent.metaKey,
          ctrlKey: originalEvent.ctrlKey
        });
      }

      if (onPressChange) {
        onPressChange(false);
      }

      setPressed(false);

      if (onPress && wasPressed && !isDisabled) {
        onPress({
          type: 'press',
          pointerType,
          target: originalEvent.currentTarget,
          shiftKey: originalEvent.shiftKey,
          metaKey: originalEvent.metaKey,
          ctrlKey: originalEvent.ctrlKey
        });
      }
    };

    let triggerPressUp = (originalEvent, pointerType) => {
      let {
        onPressUp,
        isDisabled
      } = propsRef.current;

      if (isDisabled) {
        return;
      }

      if (onPressUp) {
        onPressUp({
          type: 'pressup',
          pointerType,
          target: originalEvent.currentTarget,
          shiftKey: originalEvent.shiftKey,
          metaKey: originalEvent.metaKey,
          ctrlKey: originalEvent.ctrlKey
        });
      }
    };

    let cancel = e => {
      if (state.isPressed) {
        if (state.isOverTarget) {
          triggerPressEnd($ffc54430b1dbeee65879852feaaff07d$var$createEvent(state.target, e), state.pointerType, false);
        }

        state.isPressed = false;
        state.isOverTarget = false;
        state.activePointerId = null;
        state.pointerType = null;
        removeAllGlobalListeners();
        $e17c9db826984f8ab8e5d837bf0b8$export$restoreTextSelection();
      }
    };

    let pressProps = {
      onKeyDown(e) {
        if ($ffc54430b1dbeee65879852feaaff07d$var$isValidKeyboardEvent(e.nativeEvent) && e.currentTarget.contains(e.target)) {
          e.preventDefault();
          e.stopPropagation(); // If the event is repeating, it may have started on a different element
          // after which focus moved to the current element. Ignore these events and
          // only handle the first key down event.

          if (!state.isPressed && !e.repeat) {
            state.target = e.currentTarget;
            state.isPressed = true;
            triggerPressStart(e, 'keyboard'); // Focus may move before the key up event, so register the event on the document
            // instead of the same element where the key down event occurred.

            addGlobalListener(document, 'keyup', onKeyUp, false);
          }
        }
      },

      onKeyUp(e) {
        if ($ffc54430b1dbeee65879852feaaff07d$var$isValidKeyboardEvent(e.nativeEvent) && !e.repeat && e.currentTarget.contains(e.target)) {
          triggerPressUp($ffc54430b1dbeee65879852feaaff07d$var$createEvent(state.target, e), 'keyboard');
        }
      },

      onClick(e) {
        if (e && !e.currentTarget.contains(e.target)) {
          return;
        }

        if (e && e.button === 0) {
          e.stopPropagation();

          if (isDisabled) {
            e.preventDefault();
          } // If triggered from a screen reader or by using element.click(),
          // trigger as if it were a keyboard click.


          if (!state.ignoreClickAfterPress && !state.ignoreEmulatedMouseEvents && $f67ef9f1b8ed09b4b00fd0840cd8b94b$export$isVirtualClick(e.nativeEvent)) {
            // Ensure the element receives focus (VoiceOver on iOS does not do this)
            if (!isDisabled && !preventFocusOnPress) {
              focusWithoutScrolling(e.currentTarget);
            }

            triggerPressStart(e, 'virtual');
            triggerPressUp(e, 'virtual');
            triggerPressEnd(e, 'virtual');
          }

          state.ignoreEmulatedMouseEvents = false;
          state.ignoreClickAfterPress = false;
        }
      }

    };

    let onKeyUp = e => {
      if (state.isPressed && $ffc54430b1dbeee65879852feaaff07d$var$isValidKeyboardEvent(e)) {
        e.preventDefault();
        e.stopPropagation();
        state.isPressed = false;
        triggerPressEnd($ffc54430b1dbeee65879852feaaff07d$var$createEvent(state.target, e), 'keyboard', e.target === state.target);
        removeAllGlobalListeners(); // If the target is a link, trigger the click method to open the URL,
        // but defer triggering pressEnd until onClick event handler.

        if (e.target === state.target && $ffc54430b1dbeee65879852feaaff07d$var$isHTMLAnchorLink(state.target) || state.target.getAttribute('role') === 'link') {
          state.target.click();
        }
      }
    };

    if (typeof PointerEvent !== 'undefined') {
      pressProps.onPointerDown = e => {
        // Only handle left clicks, and ignore events that bubbled through portals.
        if (e.button !== 0 || !e.currentTarget.contains(e.target)) {
          return;
        } // Due to browser inconsistencies, especially on mobile browsers, we prevent
        // default on pointer down and handle focusing the pressable element ourselves.


        if ($ffc54430b1dbeee65879852feaaff07d$var$shouldPreventDefault(e.target)) {
          e.preventDefault();
        } // iOS safari fires pointer events from VoiceOver (but only when outside an iframe...)
        // https://bugs.webkit.org/show_bug.cgi?id=222627


        state.pointerType = $ffc54430b1dbeee65879852feaaff07d$var$isVirtualPointerEvent(e.nativeEvent) ? 'virtual' : e.pointerType;
        e.stopPropagation();

        if (!state.isPressed) {
          state.isPressed = true;
          state.isOverTarget = true;
          state.activePointerId = e.pointerId;
          state.target = e.currentTarget;

          if (!isDisabled && !preventFocusOnPress) {
            focusWithoutScrolling(e.currentTarget);
          }

          $e17c9db826984f8ab8e5d837bf0b8$export$disableTextSelection();
          triggerPressStart(e, state.pointerType);
          addGlobalListener(document, 'pointermove', onPointerMove, false);
          addGlobalListener(document, 'pointerup', onPointerUp, false);
          addGlobalListener(document, 'pointercancel', onPointerCancel, false);
        }
      };

      pressProps.onMouseDown = e => {
        if (!e.currentTarget.contains(e.target)) {
          return;
        }

        if (e.button === 0) {
          // Chrome and Firefox on touch Windows devices require mouse down events
          // to be canceled in addition to pointer events, or an extra asynchronous
          // focus event will be fired.
          if ($ffc54430b1dbeee65879852feaaff07d$var$shouldPreventDefault(e.target)) {
            e.preventDefault();
          }

          e.stopPropagation();
        }
      };

      pressProps.onPointerUp = e => {
        if (!e.currentTarget.contains(e.target)) {
          return;
        } // Only handle left clicks
        // Safari on iOS sometimes fires pointerup events, even
        // when the touch isn't over the target, so double check.


        if (e.button === 0 && $ffc54430b1dbeee65879852feaaff07d$var$isOverTarget(e, e.currentTarget)) {
          triggerPressUp(e, state.pointerType);
        }
      }; // Safari on iOS < 13.2 does not implement pointerenter/pointerleave events correctly.
      // Use pointer move events instead to implement our own hit testing.
      // See https://bugs.webkit.org/show_bug.cgi?id=199803


      let onPointerMove = e => {
        if (e.pointerId !== state.activePointerId) {
          return;
        }

        if ($ffc54430b1dbeee65879852feaaff07d$var$isOverTarget(e, state.target)) {
          if (!state.isOverTarget) {
            state.isOverTarget = true;
            triggerPressStart($ffc54430b1dbeee65879852feaaff07d$var$createEvent(state.target, e), state.pointerType);
          }
        } else if (state.isOverTarget) {
          state.isOverTarget = false;
          triggerPressEnd($ffc54430b1dbeee65879852feaaff07d$var$createEvent(state.target, e), state.pointerType, false);
        }
      };

      let onPointerUp = e => {
        if (e.pointerId === state.activePointerId && state.isPressed && e.button === 0) {
          if ($ffc54430b1dbeee65879852feaaff07d$var$isOverTarget(e, state.target)) {
            triggerPressEnd($ffc54430b1dbeee65879852feaaff07d$var$createEvent(state.target, e), state.pointerType);
          } else if (state.isOverTarget) {
            triggerPressEnd($ffc54430b1dbeee65879852feaaff07d$var$createEvent(state.target, e), state.pointerType, false);
          }

          state.isPressed = false;
          state.isOverTarget = false;
          state.activePointerId = null;
          state.pointerType = null;
          removeAllGlobalListeners();
          $e17c9db826984f8ab8e5d837bf0b8$export$restoreTextSelection();
        }
      };

      let onPointerCancel = e => {
        cancel(e);
      };

      pressProps.onDragStart = e => {
        if (!e.currentTarget.contains(e.target)) {
          return;
        } // Safari does not call onPointerCancel when a drag starts, whereas Chrome and Firefox do.


        cancel(e);
      };
    } else {
      pressProps.onMouseDown = e => {
        // Only handle left clicks
        if (e.button !== 0 || !e.currentTarget.contains(e.target)) {
          return;
        } // Due to browser inconsistencies, especially on mobile browsers, we prevent
        // default on mouse down and handle focusing the pressable element ourselves.


        if ($ffc54430b1dbeee65879852feaaff07d$var$shouldPreventDefault(e.target)) {
          e.preventDefault();
        }

        e.stopPropagation();

        if (state.ignoreEmulatedMouseEvents) {
          return;
        }

        state.isPressed = true;
        state.isOverTarget = true;
        state.target = e.currentTarget;
        state.pointerType = $f67ef9f1b8ed09b4b00fd0840cd8b94b$export$isVirtualClick(e.nativeEvent) ? 'virtual' : 'mouse';

        if (!isDisabled && !preventFocusOnPress) {
          focusWithoutScrolling(e.currentTarget);
        }

        triggerPressStart(e, state.pointerType);
        addGlobalListener(document, 'mouseup', onMouseUp, false);
      };

      pressProps.onMouseEnter = e => {
        if (!e.currentTarget.contains(e.target)) {
          return;
        }

        e.stopPropagation();

        if (state.isPressed && !state.ignoreEmulatedMouseEvents) {
          state.isOverTarget = true;
          triggerPressStart(e, state.pointerType);
        }
      };

      pressProps.onMouseLeave = e => {
        if (!e.currentTarget.contains(e.target)) {
          return;
        }

        e.stopPropagation();

        if (state.isPressed && !state.ignoreEmulatedMouseEvents) {
          state.isOverTarget = false;
          triggerPressEnd(e, state.pointerType, false);
        }
      };

      pressProps.onMouseUp = e => {
        if (!e.currentTarget.contains(e.target)) {
          return;
        }

        if (!state.ignoreEmulatedMouseEvents && e.button === 0) {
          triggerPressUp(e, state.pointerType);
        }
      };

      let onMouseUp = e => {
        // Only handle left clicks
        if (e.button !== 0) {
          return;
        }

        state.isPressed = false;
        removeAllGlobalListeners();

        if (state.ignoreEmulatedMouseEvents) {
          state.ignoreEmulatedMouseEvents = false;
          return;
        }

        if ($ffc54430b1dbeee65879852feaaff07d$var$isOverTarget(e, state.target)) {
          triggerPressEnd($ffc54430b1dbeee65879852feaaff07d$var$createEvent(state.target, e), state.pointerType);
        } else if (state.isOverTarget) {
          triggerPressEnd($ffc54430b1dbeee65879852feaaff07d$var$createEvent(state.target, e), state.pointerType, false);
        }

        state.isOverTarget = false;
      };

      pressProps.onTouchStart = e => {
        if (!e.currentTarget.contains(e.target)) {
          return;
        }

        e.stopPropagation();
        let touch = $ffc54430b1dbeee65879852feaaff07d$var$getTouchFromEvent(e.nativeEvent);

        if (!touch) {
          return;
        }

        state.activePointerId = touch.identifier;
        state.ignoreEmulatedMouseEvents = true;
        state.isOverTarget = true;
        state.isPressed = true;
        state.target = e.currentTarget;
        state.pointerType = 'touch'; // Due to browser inconsistencies, especially on mobile browsers, we prevent default
        // on the emulated mouse event and handle focusing the pressable element ourselves.

        if (!isDisabled && !preventFocusOnPress) {
          focusWithoutScrolling(e.currentTarget);
        }

        $e17c9db826984f8ab8e5d837bf0b8$export$disableTextSelection();
        triggerPressStart(e, state.pointerType);
        addGlobalListener(window, 'scroll', onScroll, true);
      };

      pressProps.onTouchMove = e => {
        if (!e.currentTarget.contains(e.target)) {
          return;
        }

        e.stopPropagation();

        if (!state.isPressed) {
          return;
        }

        let touch = $ffc54430b1dbeee65879852feaaff07d$var$getTouchById(e.nativeEvent, state.activePointerId);

        if (touch && $ffc54430b1dbeee65879852feaaff07d$var$isOverTarget(touch, e.currentTarget)) {
          if (!state.isOverTarget) {
            state.isOverTarget = true;
            triggerPressStart(e, state.pointerType);
          }
        } else if (state.isOverTarget) {
          state.isOverTarget = false;
          triggerPressEnd(e, state.pointerType, false);
        }
      };

      pressProps.onTouchEnd = e => {
        if (!e.currentTarget.contains(e.target)) {
          return;
        }

        e.stopPropagation();

        if (!state.isPressed) {
          return;
        }

        let touch = $ffc54430b1dbeee65879852feaaff07d$var$getTouchById(e.nativeEvent, state.activePointerId);

        if (touch && $ffc54430b1dbeee65879852feaaff07d$var$isOverTarget(touch, e.currentTarget)) {
          triggerPressUp(e, state.pointerType);
          triggerPressEnd(e, state.pointerType);
        } else if (state.isOverTarget) {
          triggerPressEnd(e, state.pointerType, false);
        }

        state.isPressed = false;
        state.activePointerId = null;
        state.isOverTarget = false;
        state.ignoreEmulatedMouseEvents = true;
        $e17c9db826984f8ab8e5d837bf0b8$export$restoreTextSelection();
        removeAllGlobalListeners();
      };

      pressProps.onTouchCancel = e => {
        if (!e.currentTarget.contains(e.target)) {
          return;
        }

        e.stopPropagation();

        if (state.isPressed) {
          cancel(e);
        }
      };

      let onScroll = e => {
        if (state.isPressed && e.target.contains(state.target)) {
          cancel({
            currentTarget: state.target,
            shiftKey: false,
            ctrlKey: false,
            metaKey: false
          });
        }
      };

      pressProps.onDragStart = e => {
        if (!e.currentTarget.contains(e.target)) {
          return;
        }

        cancel(e);
      };
    }

    return pressProps;
  }, [addGlobalListener, isDisabled, preventFocusOnPress, removeAllGlobalListeners]); // Remove user-select: none in case component unmounts immediately after pressStart
  // eslint-disable-next-line arrow-body-style

  useEffect(() => {
    return () => $e17c9db826984f8ab8e5d837bf0b8$export$restoreTextSelection();
  }, []);
  return {
    isPressed: isPressedProp || isPressed,
    pressProps: mergeProps(domProps, pressProps)
  };
}

function $ffc54430b1dbeee65879852feaaff07d$var$isHTMLAnchorLink(target) {
  return target.tagName === 'A' && target.hasAttribute('href');
}

function $ffc54430b1dbeee65879852feaaff07d$var$isValidKeyboardEvent(event) {
  const {
    key,
    target
  } = event;
  const element = target;
  const {
    tagName,
    isContentEditable
  } = element;
  const role = element.getAttribute('role'); // Accessibility for keyboards. Space and Enter only.
  // "Spacebar" is for IE 11

  return (key === 'Enter' || key === ' ' || key === 'Spacebar') && tagName !== 'INPUT' && tagName !== 'TEXTAREA' && isContentEditable !== true && ( // A link with a valid href should be handled natively,
  // unless it also has role='button' and was triggered using Space.
  !$ffc54430b1dbeee65879852feaaff07d$var$isHTMLAnchorLink(element) || role === 'button' && key !== 'Enter') && // An element with role='link' should only trigger with Enter key
  !(role === 'link' && key !== 'Enter');
}

function $ffc54430b1dbeee65879852feaaff07d$var$getTouchFromEvent(event) {
  const {
    targetTouches
  } = event;

  if (targetTouches.length > 0) {
    return targetTouches[0];
  }

  return null;
}

function $ffc54430b1dbeee65879852feaaff07d$var$getTouchById(event, pointerId) {
  const changedTouches = event.changedTouches;

  for (let i = 0; i < changedTouches.length; i++) {
    const touch = changedTouches[i];

    if (touch.identifier === pointerId) {
      return touch;
    }
  }

  return null;
}

function $ffc54430b1dbeee65879852feaaff07d$var$createEvent(target, e) {
  return {
    currentTarget: target,
    shiftKey: e.shiftKey,
    ctrlKey: e.ctrlKey,
    metaKey: e.metaKey
  };
}

function $ffc54430b1dbeee65879852feaaff07d$var$getPointClientRect(point) {
  let offsetX = point.width / 2 || point.radiusX || 0;
  let offsetY = point.height / 2 || point.radiusY || 0;
  return {
    top: point.clientY - offsetY,
    right: point.clientX + offsetX,
    bottom: point.clientY + offsetY,
    left: point.clientX - offsetX
  };
}

function $ffc54430b1dbeee65879852feaaff07d$var$areRectanglesOverlapping(a, b) {
  // check if they cannot overlap on x axis
  if (a.left > b.right || b.left > a.right) {
    return false;
  } // check if they cannot overlap on y axis


  if (a.top > b.bottom || b.top > a.bottom) {
    return false;
  }

  return true;
}

function $ffc54430b1dbeee65879852feaaff07d$var$isOverTarget(point, target) {
  let rect = target.getBoundingClientRect();
  let pointRect = $ffc54430b1dbeee65879852feaaff07d$var$getPointClientRect(point);
  return $ffc54430b1dbeee65879852feaaff07d$var$areRectanglesOverlapping(rect, pointRect);
}

function $ffc54430b1dbeee65879852feaaff07d$var$shouldPreventDefault(target) {
  // We cannot prevent default if the target is inside a draggable element.
  return !target.closest('[draggable="true"]');
}

function $ffc54430b1dbeee65879852feaaff07d$var$isVirtualPointerEvent(event) {
  // If the pointer size is zero, then we assume it's from a screen reader.
  return event.width === 0 && event.height === 0;
}

const Pressable = /*#__PURE__*/_react__default.forwardRef((_ref, ref) => {
  var _ref2;

  let {
    children
  } = _ref,
      props = _objectWithoutPropertiesLoose(_ref, ["children"]);

  let newRef = useRef();
  ref = (_ref2 = ref) != null ? _ref2 : newRef;
  let {
    pressProps
  } = usePress(_extends({}, props, {
    ref
  }));

  let child = _react__default.Children.only(children);

  return /*#__PURE__*/_react__default.cloneElement(child, // @ts-ignore
  _extends({
    ref
  }, mergeProps(child.props, pressProps)));
});
const PressResponder = /*#__PURE__*/_react__default.forwardRef((_ref, ref) => {
  let {
    children
  } = _ref,
      props = _objectWithoutPropertiesLoose(_ref, ["children"]);

  let isRegistered = useRef(false);
  let prevContext = useContext($a3ff51240de6f955c79cf17a88e349$export$PressResponderContext);
  let context = mergeProps(prevContext || {}, _extends({}, props, {
    ref: ref || (prevContext == null ? void 0 : prevContext.ref),

    register() {
      isRegistered.current = true;

      if (prevContext) {
        prevContext.register();
      }
    }

  }));
  useSyncRef(prevContext, ref);
  useEffect(() => {
    if (!isRegistered.current) {
      console.warn('A PressResponder was rendered without a pressable child. ' + 'Either call the usePress hook, or wrap your DOM node with <Pressable> component.');
    }
  }, []);
  return /*#__PURE__*/_react__default.createElement($a3ff51240de6f955c79cf17a88e349$export$PressResponderContext.Provider, {
    value: context
  }, children);
});
// NOTICE file in the root directory of this source tree.
// See https://github.com/facebook/react/tree/cc7c1aece46a6b69b41958d731e0fd27c94bfc6c/packages/react-interactions

/**
 * Handles focus events for the immediate target.
 * Focus events on child elements will be ignored.
 */
function useFocus(props) {
  if (props.isDisabled) {
    return {
      focusProps: {}
    };
  }

  let onFocus, onBlur;

  if (props.onFocus || props.onFocusChange) {
    onFocus = e => {
      if (e.target === e.currentTarget) {
        if (props.onFocus) {
          props.onFocus(e);
        }

        if (props.onFocusChange) {
          props.onFocusChange(true);
        }
      }
    };
  }

  if (props.onBlur || props.onFocusChange) {
    onBlur = e => {
      if (e.target === e.currentTarget) {
        if (props.onBlur) {
          props.onBlur(e);
        }

        if (props.onFocusChange) {
          props.onFocusChange(false);
        }
      }
    };
  }

  return {
    focusProps: {
      onFocus,
      onBlur
    }
  };
}
let $d01f69bb2ab5f70dfd0005370a2a2cbc$var$currentModality = null;
let $d01f69bb2ab5f70dfd0005370a2a2cbc$var$changeHandlers = new Set();
let $d01f69bb2ab5f70dfd0005370a2a2cbc$var$hasSetupGlobalListeners = false;
let $d01f69bb2ab5f70dfd0005370a2a2cbc$var$hasEventBeforeFocus = false;
let $d01f69bb2ab5f70dfd0005370a2a2cbc$var$hasBlurredWindowRecently = false; // Only Tab or Esc keys will make focus visible on text input elements

const $d01f69bb2ab5f70dfd0005370a2a2cbc$var$FOCUS_VISIBLE_INPUT_KEYS = {
  Tab: true,
  Escape: true
};

function $d01f69bb2ab5f70dfd0005370a2a2cbc$var$triggerChangeHandlers(modality, e) {
  for (let handler of $d01f69bb2ab5f70dfd0005370a2a2cbc$var$changeHandlers) {
    handler(modality, e);
  }
}
/**
 * Helper function to determine if a KeyboardEvent is unmodified and could make keyboard focus styles visible.
 */


function $d01f69bb2ab5f70dfd0005370a2a2cbc$var$isValidKey(e) {
  // Control and Shift keys trigger when navigating back to the tab with keyboard.
  return !(e.metaKey || !isMac() && e.altKey || e.ctrlKey || e.type === 'keyup' && (e.key === 'Control' || e.key === 'Shift'));
}

function $d01f69bb2ab5f70dfd0005370a2a2cbc$var$handleKeyboardEvent(e) {
  $d01f69bb2ab5f70dfd0005370a2a2cbc$var$hasEventBeforeFocus = true;

  if ($d01f69bb2ab5f70dfd0005370a2a2cbc$var$isValidKey(e)) {
    $d01f69bb2ab5f70dfd0005370a2a2cbc$var$currentModality = 'keyboard';
    $d01f69bb2ab5f70dfd0005370a2a2cbc$var$triggerChangeHandlers('keyboard', e);
  }
}

function $d01f69bb2ab5f70dfd0005370a2a2cbc$var$handlePointerEvent(e) {
  $d01f69bb2ab5f70dfd0005370a2a2cbc$var$currentModality = 'pointer';

  if (e.type === 'mousedown' || e.type === 'pointerdown') {
    $d01f69bb2ab5f70dfd0005370a2a2cbc$var$hasEventBeforeFocus = true;
    $d01f69bb2ab5f70dfd0005370a2a2cbc$var$triggerChangeHandlers('pointer', e);
  }
}

function $d01f69bb2ab5f70dfd0005370a2a2cbc$var$handleClickEvent(e) {
  if ($f67ef9f1b8ed09b4b00fd0840cd8b94b$export$isVirtualClick(e)) {
    $d01f69bb2ab5f70dfd0005370a2a2cbc$var$hasEventBeforeFocus = true;
    $d01f69bb2ab5f70dfd0005370a2a2cbc$var$currentModality = 'virtual';
  }
}

function $d01f69bb2ab5f70dfd0005370a2a2cbc$var$handleFocusEvent(e) {
  // Firefox fires two extra focus events when the user first clicks into an iframe:
  // first on the window, then on the document. We ignore these events so they don't
  // cause keyboard focus rings to appear.
  if (e.target === window || e.target === document) {
    return;
  } // If a focus event occurs without a preceding keyboard or pointer event, switch to virtual modality.
  // This occurs, for example, when navigating a form with the next/previous buttons on iOS.


  if (!$d01f69bb2ab5f70dfd0005370a2a2cbc$var$hasEventBeforeFocus && !$d01f69bb2ab5f70dfd0005370a2a2cbc$var$hasBlurredWindowRecently) {
    $d01f69bb2ab5f70dfd0005370a2a2cbc$var$currentModality = 'virtual';
    $d01f69bb2ab5f70dfd0005370a2a2cbc$var$triggerChangeHandlers('virtual', e);
  }

  $d01f69bb2ab5f70dfd0005370a2a2cbc$var$hasEventBeforeFocus = false;
  $d01f69bb2ab5f70dfd0005370a2a2cbc$var$hasBlurredWindowRecently = false;
}

function $d01f69bb2ab5f70dfd0005370a2a2cbc$var$handleWindowBlur() {
  // When the window is blurred, reset state. This is necessary when tabbing out of the window,
  // for example, since a subsequent focus event won't be fired.
  $d01f69bb2ab5f70dfd0005370a2a2cbc$var$hasEventBeforeFocus = false;
  $d01f69bb2ab5f70dfd0005370a2a2cbc$var$hasBlurredWindowRecently = true;
}
/**
 * Setup global event listeners to control when keyboard focus style should be visible.
 */


function $d01f69bb2ab5f70dfd0005370a2a2cbc$var$setupGlobalFocusEvents() {
  if (typeof window === 'undefined' || $d01f69bb2ab5f70dfd0005370a2a2cbc$var$hasSetupGlobalListeners) {
    return;
  } // Programmatic focus() calls shouldn't affect the current input modality.
  // However, we need to detect other cases when a focus event occurs without
  // a preceding user event (e.g. screen reader focus). Overriding the focus
  // method on HTMLElement.prototype is a bit hacky, but works.


  let focus = HTMLElement.prototype.focus;

  HTMLElement.prototype.focus = function () {
    $d01f69bb2ab5f70dfd0005370a2a2cbc$var$hasEventBeforeFocus = true;
    focus.apply(this, arguments);
  };

  document.addEventListener('keydown', $d01f69bb2ab5f70dfd0005370a2a2cbc$var$handleKeyboardEvent, true);
  document.addEventListener('keyup', $d01f69bb2ab5f70dfd0005370a2a2cbc$var$handleKeyboardEvent, true);
  document.addEventListener('click', $d01f69bb2ab5f70dfd0005370a2a2cbc$var$handleClickEvent, true); // Register focus events on the window so they are sure to happen
  // before React's event listeners (registered on the document).

  window.addEventListener('focus', $d01f69bb2ab5f70dfd0005370a2a2cbc$var$handleFocusEvent, true);
  window.addEventListener('blur', $d01f69bb2ab5f70dfd0005370a2a2cbc$var$handleWindowBlur, false);

  if (typeof PointerEvent !== 'undefined') {
    document.addEventListener('pointerdown', $d01f69bb2ab5f70dfd0005370a2a2cbc$var$handlePointerEvent, true);
    document.addEventListener('pointermove', $d01f69bb2ab5f70dfd0005370a2a2cbc$var$handlePointerEvent, true);
    document.addEventListener('pointerup', $d01f69bb2ab5f70dfd0005370a2a2cbc$var$handlePointerEvent, true);
  } else {
    document.addEventListener('mousedown', $d01f69bb2ab5f70dfd0005370a2a2cbc$var$handlePointerEvent, true);
    document.addEventListener('mousemove', $d01f69bb2ab5f70dfd0005370a2a2cbc$var$handlePointerEvent, true);
    document.addEventListener('mouseup', $d01f69bb2ab5f70dfd0005370a2a2cbc$var$handlePointerEvent, true);
  }

  $d01f69bb2ab5f70dfd0005370a2a2cbc$var$hasSetupGlobalListeners = true;
}

if (typeof document !== 'undefined') {
  if (document.readyState !== 'loading') {
    $d01f69bb2ab5f70dfd0005370a2a2cbc$var$setupGlobalFocusEvents();
  } else {
    document.addEventListener('DOMContentLoaded', $d01f69bb2ab5f70dfd0005370a2a2cbc$var$setupGlobalFocusEvents);
  }
}
/**
 * If true, keyboard focus is visible.
 */


function isFocusVisible() {
  return $d01f69bb2ab5f70dfd0005370a2a2cbc$var$currentModality !== 'pointer';
}
function getInteractionModality$1() {
  return $d01f69bb2ab5f70dfd0005370a2a2cbc$var$currentModality;
}
function setInteractionModality(modality) {
  $d01f69bb2ab5f70dfd0005370a2a2cbc$var$currentModality = modality;
  $d01f69bb2ab5f70dfd0005370a2a2cbc$var$triggerChangeHandlers(modality, null);
}
/**
 * Keeps state of the current modality.
 */

function useInteractionModality$1() {
  $d01f69bb2ab5f70dfd0005370a2a2cbc$var$setupGlobalFocusEvents();
  let [modality, setModality] = useState($d01f69bb2ab5f70dfd0005370a2a2cbc$var$currentModality);
  useEffect(() => {
    let handler = () => {
      setModality($d01f69bb2ab5f70dfd0005370a2a2cbc$var$currentModality);
    };

    $d01f69bb2ab5f70dfd0005370a2a2cbc$var$changeHandlers.add(handler);
    return () => {
      $d01f69bb2ab5f70dfd0005370a2a2cbc$var$changeHandlers.delete(handler);
    };
  }, []);
  return modality;
}
/**
 * If this is attached to text input component, return if the event is a focus event (Tab/Escape keys pressed) so that
 * focus visible style can be properly set.
 */

function $d01f69bb2ab5f70dfd0005370a2a2cbc$var$isKeyboardFocusEvent(isTextInput, modality, e) {
  return !(isTextInput && modality === 'keyboard' && e instanceof KeyboardEvent && !$d01f69bb2ab5f70dfd0005370a2a2cbc$var$FOCUS_VISIBLE_INPUT_KEYS[e.key]);
}
/**
 * Listens for trigger change and reports if focus is visible (i.e., modality is not pointer).
 */

function useFocusVisibleListener(fn, deps, opts) {
  $d01f69bb2ab5f70dfd0005370a2a2cbc$var$setupGlobalFocusEvents();
  useEffect(() => {
    let handler = (modality, e) => {
      if (!$d01f69bb2ab5f70dfd0005370a2a2cbc$var$isKeyboardFocusEvent(opts == null ? void 0 : opts.isTextInput, modality, e)) {
        return;
      }

      fn(isFocusVisible());
    };

    $d01f69bb2ab5f70dfd0005370a2a2cbc$var$changeHandlers.add(handler);
    return () => $d01f69bb2ab5f70dfd0005370a2a2cbc$var$changeHandlers.delete(handler);
  }, deps);
}

/**
 * Handles focus events for the target and its descendants.
 */
function useFocusWithin(props) {
  let state = useRef({
    isFocusWithin: false
  }).current;

  if (props.isDisabled) {
    return {
      focusWithinProps: {}
    };
  }

  let onFocus = e => {
    if (!state.isFocusWithin) {
      if (props.onFocusWithin) {
        props.onFocusWithin(e);
      }

      if (props.onFocusWithinChange) {
        props.onFocusWithinChange(true);
      }

      state.isFocusWithin = true;
    }
  };

  let onBlur = e => {
    // We don't want to trigger onBlurWithin and then immediately onFocusWithin again
    // when moving focus inside the element. Only trigger if the currentTarget doesn't
    // include the relatedTarget (where focus is moving).
    if (state.isFocusWithin && !e.currentTarget.contains(e.relatedTarget)) {
      if (props.onBlurWithin) {
        props.onBlurWithin(e);
      }

      if (props.onFocusWithinChange) {
        props.onFocusWithinChange(false);
      }

      state.isFocusWithin = false;
    }
  };

  return {
    focusWithinProps: {
      onFocus: onFocus,
      onBlur: onBlur
    }
  };
}
// iOS fires onPointerEnter twice: once with pointerType="touch" and again with pointerType="mouse".
// We want to ignore these emulated events so they do not trigger hover behavior.
// See https://bugs.webkit.org/show_bug.cgi?id=214609.
let $b1a784c66b81d90efa4f74e05b$var$globalIgnoreEmulatedMouseEvents = false;
let $b1a784c66b81d90efa4f74e05b$var$hoverCount = 0;

function $b1a784c66b81d90efa4f74e05b$var$setGlobalIgnoreEmulatedMouseEvents() {
  $b1a784c66b81d90efa4f74e05b$var$globalIgnoreEmulatedMouseEvents = true; // Clear globalIgnoreEmulatedMouseEvents after a short timeout. iOS fires onPointerEnter
  // with pointerType="mouse" immediately after onPointerUp and before onFocus. On other
  // devices that don't have this quirk, we don't want to ignore a mouse hover sometime in
  // the distant future because a user previously touched the element.

  setTimeout(() => {
    $b1a784c66b81d90efa4f74e05b$var$globalIgnoreEmulatedMouseEvents = false;
  }, 50);
}

function $b1a784c66b81d90efa4f74e05b$var$handleGlobalPointerEvent(e) {
  if (e.pointerType === 'touch') {
    $b1a784c66b81d90efa4f74e05b$var$setGlobalIgnoreEmulatedMouseEvents();
  }
}

function $b1a784c66b81d90efa4f74e05b$var$setupGlobalTouchEvents() {
  if (typeof document === 'undefined') {
    return;
  }

  if (typeof PointerEvent !== 'undefined') {
    document.addEventListener('pointerup', $b1a784c66b81d90efa4f74e05b$var$handleGlobalPointerEvent);
  } else {
    document.addEventListener('touchend', $b1a784c66b81d90efa4f74e05b$var$setGlobalIgnoreEmulatedMouseEvents);
  }

  $b1a784c66b81d90efa4f74e05b$var$hoverCount++;
  return () => {
    $b1a784c66b81d90efa4f74e05b$var$hoverCount--;

    if ($b1a784c66b81d90efa4f74e05b$var$hoverCount > 0) {
      return;
    }

    if (typeof PointerEvent !== 'undefined') {
      document.removeEventListener('pointerup', $b1a784c66b81d90efa4f74e05b$var$handleGlobalPointerEvent);
    } else {
      document.removeEventListener('touchend', $b1a784c66b81d90efa4f74e05b$var$setGlobalIgnoreEmulatedMouseEvents);
    }
  };
}
/**
 * Handles pointer hover interactions for an element. Normalizes behavior
 * across browsers and platforms, and ignores emulated mouse events on touch devices.
 */


function useHover(props) {
  let {
    onHoverStart,
    onHoverChange,
    onHoverEnd,
    isDisabled
  } = props;
  let [isHovered, setHovered] = useState(false);
  let state = useRef({
    isHovered: false,
    ignoreEmulatedMouseEvents: false,
    pointerType: '',
    target: null
  }).current;
  useEffect($b1a784c66b81d90efa4f74e05b$var$setupGlobalTouchEvents, []);
  let {
    hoverProps,
    triggerHoverEnd
  } = useMemo(() => {
    let triggerHoverStart = (event, pointerType) => {
      state.pointerType = pointerType;

      if (isDisabled || pointerType === 'touch' || state.isHovered || !event.currentTarget.contains(event.target)) {
        return;
      }

      state.isHovered = true;
      let target = event.target;
      state.target = target;

      if (onHoverStart) {
        onHoverStart({
          type: 'hoverstart',
          target,
          pointerType
        });
      }

      if (onHoverChange) {
        onHoverChange(true);
      }

      setHovered(true);
    };

    let triggerHoverEnd = (event, pointerType) => {
      state.pointerType = '';
      state.target = null;

      if (pointerType === 'touch' || !state.isHovered) {
        return;
      }

      state.isHovered = false;
      let target = event.target;

      if (onHoverEnd) {
        onHoverEnd({
          type: 'hoverend',
          target,
          pointerType
        });
      }

      if (onHoverChange) {
        onHoverChange(false);
      }

      setHovered(false);
    };

    let hoverProps = {};

    if (typeof PointerEvent !== 'undefined') {
      hoverProps.onPointerEnter = e => {
        if ($b1a784c66b81d90efa4f74e05b$var$globalIgnoreEmulatedMouseEvents && e.pointerType === 'mouse') {
          return;
        }

        triggerHoverStart(e, e.pointerType);
      };

      hoverProps.onPointerLeave = e => {
        if (!isDisabled && e.currentTarget.contains(e.target)) {
          triggerHoverEnd(e, e.pointerType);
        }
      };
    } else {
      hoverProps.onTouchStart = () => {
        state.ignoreEmulatedMouseEvents = true;
      };

      hoverProps.onMouseEnter = e => {
        if (!state.ignoreEmulatedMouseEvents && !$b1a784c66b81d90efa4f74e05b$var$globalIgnoreEmulatedMouseEvents) {
          triggerHoverStart(e, 'mouse');
        }

        state.ignoreEmulatedMouseEvents = false;
      };

      hoverProps.onMouseLeave = e => {
        if (!isDisabled && e.currentTarget.contains(e.target)) {
          triggerHoverEnd(e, 'mouse');
        }
      };
    }

    return {
      hoverProps,
      triggerHoverEnd
    };
  }, [onHoverStart, onHoverChange, onHoverEnd, isDisabled, state]);
  useEffect(() => {
    // Call the triggerHoverEnd as soon as isDisabled changes to true
    // Safe to call triggerHoverEnd, it will early return if we aren't currently hovering
    if (isDisabled) {
      triggerHoverEnd({
        target: state.target
      }, state.pointerType);
    }
  }, [isDisabled]);
  return {
    hoverProps,
    isHovered
  };
}

/**
 * Example, used in components like Dialogs and Popovers so they can close
 * when a user clicks outside them.
 */
function useInteractOutside(props) {
  let {
    ref,
    onInteractOutside,
    isDisabled,
    onInteractOutsideStart
  } = props;
  let stateRef = useRef({
    isPointerDown: false,
    ignoreEmulatedMouseEvents: false
  });
  let state = stateRef.current;
  useEffect(() => {
    let onPointerDown = e => {
      if (isDisabled) {
        return;
      }

      if ($e415bb64ab27cb8fbfac2f417412022f$var$isValidEvent(e, ref) && onInteractOutside) {
        if (onInteractOutsideStart) {
          onInteractOutsideStart(e);
        }

        state.isPointerDown = true;
      }
    }; // Use pointer events if available. Otherwise, fall back to mouse and touch events.


    if (typeof PointerEvent !== 'undefined') {
      let onPointerUp = e => {
        if (isDisabled) {
          return;
        }

        if (state.isPointerDown && onInteractOutside && $e415bb64ab27cb8fbfac2f417412022f$var$isValidEvent(e, ref)) {
          state.isPointerDown = false;
          onInteractOutside(e);
        }
      }; // changing these to capture phase fixed combobox


      document.addEventListener('pointerdown', onPointerDown, true);
      document.addEventListener('pointerup', onPointerUp, true);
      return () => {
        document.removeEventListener('pointerdown', onPointerDown, true);
        document.removeEventListener('pointerup', onPointerUp, true);
      };
    } else {
      let onMouseUp = e => {
        if (isDisabled) {
          return;
        }

        if (state.ignoreEmulatedMouseEvents) {
          state.ignoreEmulatedMouseEvents = false;
        } else if (state.isPointerDown && onInteractOutside && $e415bb64ab27cb8fbfac2f417412022f$var$isValidEvent(e, ref)) {
          state.isPointerDown = false;
          onInteractOutside(e);
        }
      };

      let onTouchEnd = e => {
        if (isDisabled) {
          return;
        }

        state.ignoreEmulatedMouseEvents = true;

        if (onInteractOutside && state.isPointerDown && $e415bb64ab27cb8fbfac2f417412022f$var$isValidEvent(e, ref)) {
          state.isPointerDown = false;
          onInteractOutside(e);
        }
      };

      document.addEventListener('mousedown', onPointerDown, true);
      document.addEventListener('mouseup', onMouseUp, true);
      document.addEventListener('touchstart', onPointerDown, true);
      document.addEventListener('touchend', onTouchEnd, true);
      return () => {
        document.removeEventListener('mousedown', onPointerDown, true);
        document.removeEventListener('mouseup', onMouseUp, true);
        document.removeEventListener('touchstart', onPointerDown, true);
        document.removeEventListener('touchend', onTouchEnd, true);
      };
    }
  }, [onInteractOutside, ref, state.ignoreEmulatedMouseEvents, state.isPointerDown, isDisabled]);
}

function $e415bb64ab27cb8fbfac2f417412022f$var$isValidEvent(event, ref) {
  if (event.button > 0) {
    return false;
  } // if the event target is no longer in the document


  if (event.target) {
    const ownerDocument = event.target.ownerDocument;

    if (!ownerDocument || !ownerDocument.documentElement.contains(event.target)) {
      return false;
    }
  }

  return ref.current && !ref.current.contains(event.target);
}

/**
 * This function wraps a React event handler to make stopPropagation the default, and support continuePropagation instead.
 */
function $dc0d75166de722fbf58eb6c3552$export$createEventHandler(handler) {
  if (!handler) {
    return;
  }

  let shouldStopPropagation = true;
  return e => {
    let event = _extends({}, e, {
      preventDefault() {
        e.preventDefault();
      },

      isDefaultPrevented() {
        return e.isDefaultPrevented();
      },

      stopPropagation() {
        console.error('stopPropagation is now the default behavior for events in React Spectrum. You can use continuePropagation() to revert this behavior.');
      },

      continuePropagation() {
        shouldStopPropagation = false;
      }

    });

    handler(event);

    if (shouldStopPropagation) {
      e.stopPropagation();
    }
  };
}

/**
 * Handles keyboard interactions for a focusable element.
 */
function useKeyboard(props) {
  return {
    keyboardProps: props.isDisabled ? {} : {
      onKeyDown: $dc0d75166de722fbf58eb6c3552$export$createEventHandler(props.onKeyDown),
      onKeyUp: $dc0d75166de722fbf58eb6c3552$export$createEventHandler(props.onKeyUp)
    }
  };
}

/**
 * Handles move interactions across mouse, touch, and keyboard, including dragging with
 * the mouse or touch, and using the arrow keys. Normalizes behavior across browsers and
 * platforms, and ignores emulated mouse events on touch devices.
 */
function useMove(props) {
  let {
    onMoveStart,
    onMove,
    onMoveEnd
  } = props;
  let state = useRef({
    didMove: false,
    lastPosition: null,
    id: null
  });
  let {
    addGlobalListener,
    removeGlobalListener
  } = useGlobalListeners();
  let moveProps = useMemo(() => {
    let moveProps = {};

    let start = () => {
      $e17c9db826984f8ab8e5d837bf0b8$export$disableTextSelection();
      state.current.didMove = false;
    };

    let move = (pointerType, deltaX, deltaY) => {
      if (deltaX === 0 && deltaY === 0) {
        return;
      }

      if (!state.current.didMove) {
        state.current.didMove = true;
        onMoveStart == null ? void 0 : onMoveStart({
          type: 'movestart',
          pointerType
        });
      }

      onMove({
        type: 'move',
        pointerType,
        deltaX: deltaX,
        deltaY: deltaY
      });
    };

    let end = pointerType => {
      $e17c9db826984f8ab8e5d837bf0b8$export$restoreTextSelection();

      if (state.current.didMove) {
        onMoveEnd == null ? void 0 : onMoveEnd({
          type: 'moveend',
          pointerType
        });
      }
    };

    if (typeof PointerEvent === 'undefined') {
      let onMouseMove = e => {
        if (e.button === 0) {
          move('mouse', e.pageX - state.current.lastPosition.pageX, e.pageY - state.current.lastPosition.pageY);
          state.current.lastPosition = {
            pageX: e.pageX,
            pageY: e.pageY
          };
        }
      };

      let onMouseUp = e => {
        if (e.button === 0) {
          end('mouse');
          removeGlobalListener(window, 'mousemove', onMouseMove, false);
          removeGlobalListener(window, 'mouseup', onMouseUp, false);
        }
      };

      moveProps.onMouseDown = e => {
        if (e.button === 0) {
          start();
          e.stopPropagation();
          e.preventDefault();
          state.current.lastPosition = {
            pageX: e.pageX,
            pageY: e.pageY
          };
          addGlobalListener(window, 'mousemove', onMouseMove, false);
          addGlobalListener(window, 'mouseup', onMouseUp, false);
        }
      };

      let onTouchMove = e => {
        // @ts-ignore
        let touch = [...e.changedTouches].findIndex((_ref) => {
          let {
            identifier
          } = _ref;
          return identifier === state.current.id;
        });

        if (touch >= 0) {
          let {
            pageX,
            pageY
          } = e.changedTouches[touch];
          move('touch', pageX - state.current.lastPosition.pageX, pageY - state.current.lastPosition.pageY);
          state.current.lastPosition = {
            pageX,
            pageY
          };
        }
      };

      let onTouchEnd = e => {
        // @ts-ignore
        let touch = [...e.changedTouches].findIndex((_ref2) => {
          let {
            identifier
          } = _ref2;
          return identifier === state.current.id;
        });

        if (touch >= 0) {
          end('touch');
          state.current.id = null;
          removeGlobalListener(window, 'touchmove', onTouchMove);
          removeGlobalListener(window, 'touchend', onTouchEnd);
          removeGlobalListener(window, 'touchcancel', onTouchEnd);
        }
      };

      moveProps.onTouchStart = e => {
        if (e.changedTouches.length === 0 || state.current.id != null) {
          return;
        }

        let {
          pageX,
          pageY,
          identifier
        } = e.changedTouches[0];
        start();
        e.stopPropagation();
        e.preventDefault();
        state.current.lastPosition = {
          pageX,
          pageY
        };
        state.current.id = identifier;
        addGlobalListener(window, 'touchmove', onTouchMove, false);
        addGlobalListener(window, 'touchend', onTouchEnd, false);
        addGlobalListener(window, 'touchcancel', onTouchEnd, false);
      };
    } else {
      let onPointerMove = e => {
        if (e.pointerId === state.current.id) {
          // @ts-ignore
          let pointerType = e.pointerType || 'mouse'; // Problems with PointerEvent#movementX/movementY:
          // 1. it is always 0 on macOS Safari.
          // 2. On Chrome Android, it's scaled by devicePixelRatio, but not on Chrome macOS

          move(pointerType, e.pageX - state.current.lastPosition.pageX, e.pageY - state.current.lastPosition.pageY);
          state.current.lastPosition = {
            pageX: e.pageX,
            pageY: e.pageY
          };
        }
      };

      let onPointerUp = e => {
        if (e.pointerId === state.current.id) {
          // @ts-ignore
          let pointerType = e.pointerType || 'mouse';
          end(pointerType);
          state.current.id = null;
          removeGlobalListener(window, 'pointermove', onPointerMove, false);
          removeGlobalListener(window, 'pointerup', onPointerUp, false);
          removeGlobalListener(window, 'pointercancel', onPointerUp, false);
        }
      };

      moveProps.onPointerDown = e => {
        if (e.button === 0 && state.current.id == null) {
          start();
          e.stopPropagation();
          e.preventDefault();
          state.current.lastPosition = {
            pageX: e.pageX,
            pageY: e.pageY
          };
          state.current.id = e.pointerId;
          addGlobalListener(window, 'pointermove', onPointerMove, false);
          addGlobalListener(window, 'pointerup', onPointerUp, false);
          addGlobalListener(window, 'pointercancel', onPointerUp, false);
        }
      };
    }

    let triggerKeyboardMove = (deltaX, deltaY) => {
      start();
      move('keyboard', deltaX, deltaY);
      end('keyboard');
    };

    moveProps.onKeyDown = e => {
      switch (e.key) {
        case 'Left':
        case 'ArrowLeft':
          e.preventDefault();
          e.stopPropagation();
          triggerKeyboardMove(-1, 0);
          break;

        case 'Right':
        case 'ArrowRight':
          e.preventDefault();
          e.stopPropagation();
          triggerKeyboardMove(1, 0);
          break;

        case 'Up':
        case 'ArrowUp':
          e.preventDefault();
          e.stopPropagation();
          triggerKeyboardMove(0, -1);
          break;

        case 'Down':
        case 'ArrowDown':
          e.preventDefault();
          e.stopPropagation();
          triggerKeyboardMove(0, 1);
          break;
      }
    };

    return moveProps;
  }, [state, onMoveStart, onMove, onMoveEnd, addGlobalListener, removeGlobalListener]);
  return {
    moveProps
  };
}

/**
 * A utility function that focuses an element while avoiding undesired side effects such
 * as page scrolling and screen reader issues with CSS transitions.
 */
function focusSafely(element) {
  // If the user is interacting with a virtual cursor, e.g. screen reader, then
  // wait until after any animated transitions that are currently occurring on
  // the page before shifting focus. This avoids issues with VoiceOver on iOS
  // causing the page to scroll when moving focus if the element is transitioning
  // from off the screen.
  if (getInteractionModality$1() === 'virtual') {
    let lastFocusedElement = document.activeElement;
    runAfterTransition(() => {
      // If focus did not move and the element is still in the document, focus it.
      if (document.activeElement === lastFocusedElement && document.contains(element)) {
        focusWithoutScrolling(element);
      }
    });
  } else {
    focusWithoutScrolling(element);
  }
}

/*
 * Copyright 2021 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */
function $ee5e90cbb4a22466973155c14222fa1$var$isStyleVisible(element) {
  if (!(element instanceof HTMLElement) && !(element instanceof SVGElement)) {
    return false;
  }

  let {
    display,
    visibility
  } = element.style;
  let isVisible = display !== 'none' && visibility !== 'hidden' && visibility !== 'collapse';

  if (isVisible) {
    const {
      getComputedStyle
    } = element.ownerDocument.defaultView;
    let {
      display: computedDisplay,
      visibility: computedVisibility
    } = getComputedStyle(element);
    isVisible = computedDisplay !== 'none' && computedVisibility !== 'hidden' && computedVisibility !== 'collapse';
  }

  return isVisible;
}

function $ee5e90cbb4a22466973155c14222fa1$var$isAttributeVisible(element, childElement) {
  return !element.hasAttribute('hidden') && (element.nodeName === 'DETAILS' && childElement && childElement.nodeName !== 'SUMMARY' ? element.hasAttribute('open') : true);
}
/**
 * Adapted from https://github.com/testing-library/jest-dom and 
 * https://github.com/vuejs/vue-test-utils-next/.
 * Licensed under the MIT License.
 * @param element - Element to evaluate for display or visibility.
 */


function $ee5e90cbb4a22466973155c14222fa1$export$isElementVisible(element, childElement) {
  return element.nodeName !== '#comment' && $ee5e90cbb4a22466973155c14222fa1$var$isStyleVisible(element) && $ee5e90cbb4a22466973155c14222fa1$var$isAttributeVisible(element, childElement) && (!element.parentElement || $ee5e90cbb4a22466973155c14222fa1$export$isElementVisible(element.parentElement, element));
}

const $c9e8f80f5bb1841844f54e4ad30b$var$FocusContext = /*#__PURE__*/_react__default.createContext(null);

let $c9e8f80f5bb1841844f54e4ad30b$var$activeScope = null;
let $c9e8f80f5bb1841844f54e4ad30b$var$scopes = new Set(); // This is a hacky DOM-based implementation of a FocusScope until this RFC lands in React:
// https://github.com/reactjs/rfcs/pull/109
// For now, it relies on the DOM tree order rather than the React tree order, and is probably
// less optimized for performance.

/**
 * A FocusScope manages focus for its descendants. It supports containing focus inside
 * the scope, restoring focus to the previously focused element on unmount, and auto
 * focusing children on mount. It also acts as a container for a programmatic focus
 * management interface that can be used to move focus forward and back in response
 * to user events.
 */

function FocusScope(props) {
  let {
    children,
    contain,
    restoreFocus,
    autoFocus
  } = props;
  let startRef = useRef();
  let endRef = useRef();
  let scopeRef = useRef([]);
  useLayoutEffect(() => {
    // Find all rendered nodes between the sentinels and add them to the scope.
    let node = startRef.current.nextSibling;
    let nodes = [];

    while (node && node !== endRef.current) {
      nodes.push(node);
      node = node.nextSibling;
    }

    scopeRef.current = nodes;
    $c9e8f80f5bb1841844f54e4ad30b$var$scopes.add(scopeRef);
    return () => {
      $c9e8f80f5bb1841844f54e4ad30b$var$scopes.delete(scopeRef);
    };
  }, [children]);
  $c9e8f80f5bb1841844f54e4ad30b$var$useFocusContainment(scopeRef, contain);
  $c9e8f80f5bb1841844f54e4ad30b$var$useRestoreFocus(scopeRef, restoreFocus, contain);
  $c9e8f80f5bb1841844f54e4ad30b$var$useAutoFocus(scopeRef, autoFocus);
  let focusManager = $c9e8f80f5bb1841844f54e4ad30b$var$createFocusManagerForScope(scopeRef);
  return /*#__PURE__*/_react__default.createElement($c9e8f80f5bb1841844f54e4ad30b$var$FocusContext.Provider, {
    value: focusManager
  }, /*#__PURE__*/_react__default.createElement("span", {
    hidden: true,
    ref: startRef
  }), children, /*#__PURE__*/_react__default.createElement("span", {
    hidden: true,
    ref: endRef
  }));
}

function $c9e8f80f5bb1841844f54e4ad30b$var$createFocusManagerForScope(scopeRef) {
  return {
    focusNext(opts) {
      if (opts === void 0) {
        opts = {};
      }

      let scope = scopeRef.current;
      let {
        from,
        tabbable,
        wrap
      } = opts;
      let node = from || document.activeElement;
      let sentinel = scope[0].previousElementSibling;
      let walker = getFocusableTreeWalker($c9e8f80f5bb1841844f54e4ad30b$var$getScopeRoot(scope), {
        tabbable
      }, scope);
      walker.currentNode = $c9e8f80f5bb1841844f54e4ad30b$var$isElementInScope(node, scope) ? node : sentinel;
      let nextNode = walker.nextNode();

      if (!nextNode && wrap) {
        walker.currentNode = sentinel;
        nextNode = walker.nextNode();
      }

      if (nextNode) {
        $c9e8f80f5bb1841844f54e4ad30b$var$focusElement(nextNode, true);
      }

      return nextNode;
    },

    focusPrevious(opts) {
      if (opts === void 0) {
        opts = {};
      }

      let scope = scopeRef.current;
      let {
        from,
        tabbable,
        wrap
      } = opts;
      let node = from || document.activeElement;
      let sentinel = scope[scope.length - 1].nextElementSibling;
      let walker = getFocusableTreeWalker($c9e8f80f5bb1841844f54e4ad30b$var$getScopeRoot(scope), {
        tabbable
      }, scope);
      walker.currentNode = $c9e8f80f5bb1841844f54e4ad30b$var$isElementInScope(node, scope) ? node : sentinel;
      let previousNode = walker.previousNode();

      if (!previousNode && wrap) {
        walker.currentNode = sentinel;
        previousNode = walker.previousNode();
      }

      if (previousNode) {
        $c9e8f80f5bb1841844f54e4ad30b$var$focusElement(previousNode, true);
      }

      return previousNode;
    }

  };
}

const $c9e8f80f5bb1841844f54e4ad30b$var$focusableElements = ['input:not([disabled]):not([type=hidden])', 'select:not([disabled])', 'textarea:not([disabled])', 'button:not([disabled])', 'a[href]', 'area[href]', 'summary', 'iframe', 'object', 'embed', 'audio[controls]', 'video[controls]', '[contenteditable]'];
const $c9e8f80f5bb1841844f54e4ad30b$var$FOCUSABLE_ELEMENT_SELECTOR = $c9e8f80f5bb1841844f54e4ad30b$var$focusableElements.join(':not([hidden]),') + ',[tabindex]:not([disabled]):not([hidden])';
$c9e8f80f5bb1841844f54e4ad30b$var$focusableElements.push('[tabindex]:not([tabindex="-1"]):not([disabled])');
const $c9e8f80f5bb1841844f54e4ad30b$var$TABBABLE_ELEMENT_SELECTOR = $c9e8f80f5bb1841844f54e4ad30b$var$focusableElements.join(':not([hidden]):not([tabindex="-1"]),');

function $c9e8f80f5bb1841844f54e4ad30b$var$getScopeRoot(scope) {
  return scope[0].parentElement;
}

function $c9e8f80f5bb1841844f54e4ad30b$var$useFocusContainment(scopeRef, contain) {
  let focusedNode = useRef();
  let raf = useRef(null);
  useEffect(() => {
    let scope = scopeRef.current;

    if (!contain) {
      return;
    } // Handle the Tab key to contain focus within the scope


    let onKeyDown = e => {
      if (e.key !== 'Tab' || e.altKey || e.ctrlKey || e.metaKey) {
        return;
      }

      let focusedElement = document.activeElement;

      if (!$c9e8f80f5bb1841844f54e4ad30b$var$isElementInScope(focusedElement, scope)) {
        return;
      }

      let walker = getFocusableTreeWalker($c9e8f80f5bb1841844f54e4ad30b$var$getScopeRoot(scope), {
        tabbable: true
      }, scope);
      walker.currentNode = focusedElement;
      let nextElement = e.shiftKey ? walker.previousNode() : walker.nextNode();

      if (!nextElement) {
        walker.currentNode = e.shiftKey ? scope[scope.length - 1].nextElementSibling : scope[0].previousElementSibling;
        nextElement = e.shiftKey ? walker.previousNode() : walker.nextNode();
      }

      e.preventDefault();

      if (nextElement) {
        $c9e8f80f5bb1841844f54e4ad30b$var$focusElement(nextElement, true);
      }
    };

    let onFocus = e => {
      // If a focus event occurs outside the active scope (e.g. user tabs from browser location bar),
      // restore focus to the previously focused node or the first tabbable element in the active scope.
      let isInAnyScope = $c9e8f80f5bb1841844f54e4ad30b$var$isElementInAnyScope(e.target, $c9e8f80f5bb1841844f54e4ad30b$var$scopes);

      if (!isInAnyScope) {
        if (focusedNode.current) {
          focusedNode.current.focus();
        } else if ($c9e8f80f5bb1841844f54e4ad30b$var$activeScope) {
          $c9e8f80f5bb1841844f54e4ad30b$var$focusFirstInScope($c9e8f80f5bb1841844f54e4ad30b$var$activeScope.current);
        }
      } else {
        $c9e8f80f5bb1841844f54e4ad30b$var$activeScope = scopeRef;
        focusedNode.current = e.target;
      }
    };

    let onBlur = e => {
      // Firefox doesn't shift focus back to the Dialog properly without this
      raf.current = requestAnimationFrame(() => {
        // Use document.activeElement instead of e.relatedTarget so we can tell if user clicked into iframe
        let isInAnyScope = $c9e8f80f5bb1841844f54e4ad30b$var$isElementInAnyScope(document.activeElement, $c9e8f80f5bb1841844f54e4ad30b$var$scopes);

        if (!isInAnyScope) {
          $c9e8f80f5bb1841844f54e4ad30b$var$activeScope = scopeRef;
          focusedNode.current = e.target;
          focusedNode.current.focus();
        }
      });
    };

    document.addEventListener('keydown', onKeyDown, false);
    document.addEventListener('focusin', onFocus, false);
    scope.forEach(element => element.addEventListener('focusin', onFocus, false));
    scope.forEach(element => element.addEventListener('focusout', onBlur, false));
    return () => {
      document.removeEventListener('keydown', onKeyDown, false);
      document.removeEventListener('focusin', onFocus, false);
      scope.forEach(element => element.removeEventListener('focusin', onFocus, false));
      scope.forEach(element => element.removeEventListener('focusout', onBlur, false));
    };
  }, [scopeRef, contain]); // eslint-disable-next-line arrow-body-style

  useEffect(() => {
    return () => cancelAnimationFrame(raf.current);
  }, [raf]);
}

function $c9e8f80f5bb1841844f54e4ad30b$var$isElementInAnyScope(element, scopes) {
  for (let scope of scopes.values()) {
    if ($c9e8f80f5bb1841844f54e4ad30b$var$isElementInScope(element, scope.current)) {
      return true;
    }
  }

  return false;
}

function $c9e8f80f5bb1841844f54e4ad30b$var$isElementInScope(element, scope) {
  return scope.some(node => node.contains(element));
}

function $c9e8f80f5bb1841844f54e4ad30b$var$focusElement(element, scroll) {
  if (scroll === void 0) {
    scroll = false;
  }

  if (element != null && !scroll) {
    try {
      focusSafely(element);
    } catch (err) {// ignore
    }
  } else if (element != null) {
    try {
      element.focus();
    } catch (err) {// ignore
    }
  }
}

function $c9e8f80f5bb1841844f54e4ad30b$var$focusFirstInScope(scope) {
  let sentinel = scope[0].previousElementSibling;
  let walker = getFocusableTreeWalker($c9e8f80f5bb1841844f54e4ad30b$var$getScopeRoot(scope), {
    tabbable: true
  }, scope);
  walker.currentNode = sentinel;
  $c9e8f80f5bb1841844f54e4ad30b$var$focusElement(walker.nextNode());
}

function $c9e8f80f5bb1841844f54e4ad30b$var$useAutoFocus(scopeRef, autoFocus) {
  useEffect(() => {
    if (autoFocus) {
      $c9e8f80f5bb1841844f54e4ad30b$var$activeScope = scopeRef;

      if (!$c9e8f80f5bb1841844f54e4ad30b$var$isElementInScope(document.activeElement, $c9e8f80f5bb1841844f54e4ad30b$var$activeScope.current)) {
        $c9e8f80f5bb1841844f54e4ad30b$var$focusFirstInScope(scopeRef.current);
      }
    }
  }, [scopeRef, autoFocus]);
}

function $c9e8f80f5bb1841844f54e4ad30b$var$useRestoreFocus(scopeRef, restoreFocus, contain) {
  // useLayoutEffect instead of useEffect so the active element is saved synchronously instead of asynchronously.
  useLayoutEffect(() => {
    let scope = scopeRef.current;
    let nodeToRestore = document.activeElement; // Handle the Tab key so that tabbing out of the scope goes to the next element
    // after the node that had focus when the scope mounted. This is important when
    // using portals for overlays, so that focus goes to the expected element when
    // tabbing out of the overlay.

    let onKeyDown = e => {
      if (e.key !== 'Tab' || e.altKey || e.ctrlKey || e.metaKey) {
        return;
      }

      let focusedElement = document.activeElement;

      if (!$c9e8f80f5bb1841844f54e4ad30b$var$isElementInScope(focusedElement, scope)) {
        return;
      } // Create a DOM tree walker that matches all tabbable elements


      let walker = getFocusableTreeWalker(document.body, {
        tabbable: true
      }); // Find the next tabbable element after the currently focused element

      walker.currentNode = focusedElement;
      let nextElement = e.shiftKey ? walker.previousNode() : walker.nextNode();

      if (!document.body.contains(nodeToRestore) || nodeToRestore === document.body) {
        nodeToRestore = null;
      } // If there is no next element, or it is outside the current scope, move focus to the
      // next element after the node to restore to instead.


      if ((!nextElement || !$c9e8f80f5bb1841844f54e4ad30b$var$isElementInScope(nextElement, scope)) && nodeToRestore) {
        walker.currentNode = nodeToRestore; // Skip over elements within the scope, in case the scope immediately follows the node to restore.

        do {
          nextElement = e.shiftKey ? walker.previousNode() : walker.nextNode();
        } while ($c9e8f80f5bb1841844f54e4ad30b$var$isElementInScope(nextElement, scope));

        e.preventDefault();
        e.stopPropagation();

        if (nextElement) {
          $c9e8f80f5bb1841844f54e4ad30b$var$focusElement(nextElement, true);
        } else {
          // If there is no next element, blur the focused element to move focus to the body.
          focusedElement.blur();
        }
      }
    };

    if (!contain) {
      document.addEventListener('keydown', onKeyDown, true);
    }

    return () => {
      if (!contain) {
        document.removeEventListener('keydown', onKeyDown, true);
      }

      if (restoreFocus && nodeToRestore && $c9e8f80f5bb1841844f54e4ad30b$var$isElementInScope(document.activeElement, scope)) {
        requestAnimationFrame(() => {
          if (document.body.contains(nodeToRestore)) {
            $c9e8f80f5bb1841844f54e4ad30b$var$focusElement(nodeToRestore);
          }
        });
      }
    };
  }, [scopeRef, restoreFocus, contain]);
}
/**
 * Create a [TreeWalker]{@link https://developer.mozilla.org/en-US/docs/Web/API/TreeWalker}
 * that matches all focusable/tabbable elements.
 */


function getFocusableTreeWalker(root, opts, scope) {
  let selector = opts != null && opts.tabbable ? $c9e8f80f5bb1841844f54e4ad30b$var$TABBABLE_ELEMENT_SELECTOR : $c9e8f80f5bb1841844f54e4ad30b$var$FOCUSABLE_ELEMENT_SELECTOR;
  let walker = document.createTreeWalker(root, NodeFilter.SHOW_ELEMENT, {
    acceptNode(node) {
      var _opts$from;

      // Skip nodes inside the starting node.
      if (opts != null && (_opts$from = opts.from) != null && _opts$from.contains(node)) {
        return NodeFilter.FILTER_REJECT;
      }

      if (node.matches(selector) && $ee5e90cbb4a22466973155c14222fa1$export$isElementVisible(node) && (!scope || $c9e8f80f5bb1841844f54e4ad30b$var$isElementInScope(node, scope))) {
        return NodeFilter.FILTER_ACCEPT;
      }

      return NodeFilter.FILTER_SKIP;
    }

  });

  if (opts != null && opts.from) {
    walker.currentNode = opts.from;
  }

  return walker;
}

/**
 * Determines whether a focus ring should be shown to indicate keyboard focus.
 * Focus rings are visible only when the user is interacting with a keyboard,
 * not with a mouse, touch, or other input methods.
 */
function useFocusRing(props) {
  if (props === void 0) {
    props = {};
  }

  let {
    autoFocus = false,
    isTextInput,
    within
  } = props;
  let state = useRef({
    isFocused: false,
    isFocusVisible: autoFocus || isFocusVisible()
  }).current;
  let [isFocusVisibleState, setFocusVisible] = useState(() => state.isFocused && state.isFocusVisible);

  let updateState = () => setFocusVisible(state.isFocused && state.isFocusVisible);

  let onFocusChange = isFocused => {
    state.isFocused = isFocused;
    updateState();
  };

  useFocusVisibleListener(isFocusVisible => {
    state.isFocusVisible = isFocusVisible;
    updateState();
  }, [], {
    isTextInput
  });
  let {
    focusProps
  } = useFocus({
    isDisabled: within,
    onFocusChange
  });
  let {
    focusWithinProps
  } = useFocusWithin({
    isDisabled: !within,
    onFocusWithinChange: onFocusChange
  });
  return {
    isFocused: state.isFocused,
    isFocusVisible: state.isFocused && isFocusVisibleState,
    focusProps: within ? focusWithinProps : focusProps
  };
}

/**
 * A utility component that applies a CSS class when an element has keyboard focus.
 * Focus rings are visible only when the user is interacting with a keyboard,
 * not with a mouse, touch, or other input methods.
 */
function FocusRing(props) {
  let {
    children,
    focusClass,
    focusRingClass
  } = props;
  let {
    isFocused,
    isFocusVisible,
    focusProps
  } = useFocusRing(props);

  let child = _react__default.Children.only(children);

  return /*#__PURE__*/_react__default.cloneElement(child, mergeProps(child.props, _extends({}, focusProps, {
    className: cn({
      [focusClass || '']: isFocused,
      [focusRingClass || '']: isFocusVisible
    })
  })));
}

let $e11539c8317b2d21639df611cb5658f$var$FocusableContext = /*#__PURE__*/_react__default.createContext(null);

function $e11539c8317b2d21639df611cb5658f$var$useFocusableContext(ref) {
  let context = useContext($e11539c8317b2d21639df611cb5658f$var$FocusableContext) || {};
  useSyncRef(context, ref);
  return context;
}
/**
 * Provides DOM props to the nearest focusable child.
 */


function $e11539c8317b2d21639df611cb5658f$var$FocusableProvider(props, ref) {
  let {
    children
  } = props,
      otherProps = _objectWithoutPropertiesLoose(props, ["children"]);

  let context = _extends({}, otherProps, {
    ref
  });

  return /*#__PURE__*/_react__default.createElement($e11539c8317b2d21639df611cb5658f$var$FocusableContext.Provider, {
    value: context
  }, children);
}

let FocusableProvider = /*#__PURE__*/_react__default.forwardRef($e11539c8317b2d21639df611cb5658f$var$FocusableProvider);

/**
 * Used to make an element focusable and capable of auto focus.
 */
function useFocusable(props, domRef) {
  let {
    focusProps
  } = useFocus(props);
  let {
    keyboardProps
  } = useKeyboard(props);
  let interactions = mergeProps(focusProps, keyboardProps);
  let domProps = $e11539c8317b2d21639df611cb5658f$var$useFocusableContext(domRef);
  let interactionProps = props.isDisabled ? {} : domProps;
  useEffect(() => {
    if (props.autoFocus && domRef.current) {
      domRef.current.focus();
    }
  }, [props.autoFocus, domRef]);
  return {
    focusableProps: mergeProps(_extends({}, interactions, {
      tabIndex: props.excludeFromTabOrder && !props.isDisabled ? -1 : undefined
    }), interactionProps)
  };
}

/**
 * Provides the behavior and accessibility implementation for a button component. Handles mouse, keyboard, and touch interactions,
 * focus behavior, and ARIA props for both native button elements and custom element types.
 * @param props - Props to be applied to the button.
 * @param ref - A ref to a DOM element for the button.
 */
function useButton(props, ref) {
  /* eslint-enable no-redeclare */
  let {
    elementType = 'button',
    isDisabled,
    onPress,
    onPressStart,
    onPressEnd,
    onPressChange,
    // @ts-ignore - undocumented
    preventFocusOnPress,
    // @ts-ignore
    onClick: deprecatedOnClick,
    href,
    target,
    rel,
    type = 'button'
  } = props;
  let additionalProps;

  if (elementType === 'button') {
    additionalProps = {
      type,
      disabled: isDisabled
    };
  } else {
    additionalProps = {
      role: 'button',
      tabIndex: isDisabled ? undefined : 0,
      href: elementType === 'a' && isDisabled ? undefined : href,
      target: elementType === 'a' ? target : undefined,
      type: elementType === 'input' ? type : undefined,
      disabled: elementType === 'input' ? isDisabled : undefined,
      'aria-disabled': !isDisabled || elementType === 'input' ? undefined : isDisabled,
      rel: elementType === 'a' ? rel : undefined
    };
  }

  let {
    pressProps,
    isPressed
  } = usePress({
    onPressStart,
    onPressEnd,
    onPressChange,
    onPress,
    isDisabled,
    preventFocusOnPress,
    ref
  });
  let {
    focusableProps
  } = useFocusable(props, ref);
  let buttonProps = mergeProps(focusableProps, pressProps);
  buttonProps = mergeProps(buttonProps, filterDOMProps(props, {
    labelable: true
  }));
  return {
    isPressed,
    // Used to indicate press state for visual
    buttonProps: mergeProps(additionalProps, buttonProps, {
      'aria-haspopup': props['aria-haspopup'],
      'aria-expanded': props['aria-expanded'],
      'aria-controls': props['aria-controls'],
      'aria-pressed': props['aria-pressed'],
      onClick: e => {
        if (deprecatedOnClick) {
          deprecatedOnClick(e);
          console.warn('onClick is deprecated, please use onPress');
        }
      }
    })
  };
}

const sizes$7 = {
  md: {
    px: 2.5,
    fontSize: 'base',
    rounded: true,
    iconSize: 'xs',
    leftIconMx: -1,
    leftIconMr: 1.5,
    rightIconMl: 1.5,
    rightIconMr: -0.5
  },
  sm: {
    px: 1.5,
    fontSize: 'base',
    rounded: true,
    iconSize: 'xs',
    leftIconMx: 0,
    leftIconMr: 1,
    rightIconMl: 1,
    rightIconMr: -0.5
  }
};
const variants$5 = {
  default: {
    default: {
      borderColor: 'button',
      bg: {
        default: 'canvas',
        hover: 'canvas-50',
        active: 'canvas-100'
      },
      opacity: {
        disabled: 60
      }
    },
    success: {
      borderColor: 'success',
      ringColor: 'success'
    },
    warning: {
      borderColor: 'warning',
      ringColor: 'warning'
    },
    danger: {
      borderColor: 'danger',
      ringColor: 'danger'
    }
  },
  minimal: {
    default: {
      color: {
        default: 'muted',
        hover: 'body',
        focus: 'body'
      },
      bg: {
        hover: 'canvas-50',
        active: 'canvas-100'
      },
      borderColor: 'transparent',
      opacity: {
        disabled: 70
      }
    },
    success: {
      color: 'success'
    },
    warning: {
      color: 'warning'
    },
    danger: {
      color: 'danger'
    }
  },
  primary: {
    default: {
      color: {
        default: 'on-primary',
        disabled: 'body'
      },
      bg: {
        default: 'primary',
        hover: 'primary-dark',
        active: 'primary-darker',
        disabled: 'canvas-100'
      },
      borderColor: 'transparent',
      opacity: {
        disabled: 70
      }
    },
    success: {
      color: {
        default: 'on-success',
        disabled: 'body'
      },
      bg: {
        default: 'success',
        hover: 'success-dark',
        active: 'success-darker',
        disabled: 'canvas-100'
      }
    },
    warning: {
      color: {
        default: 'on-warning',
        disabled: 'body'
      },
      bg: {
        default: 'warning',
        hover: 'warning-dark',
        active: 'warning-darker'
      }
    },
    danger: {
      color: {
        default: 'on-danger',
        disabled: 'body'
      },
      bg: {
        default: 'danger',
        hover: 'danger-dark',
        active: 'danger-darker'
      }
    }
  }
};
const fieldButtonVariants = {
  minimal: {
    default: {
      fontWeight: 'normal',
      color: {
        default: 'body'
      },
      ring: false,
      bg: {
        default: 'transparent'
      },
      borderColor: {
        default: 'transparent',
        hover: 'input',
        focus: 'primary',
        active: 'primary'
      }
    },
    success: {
      color: 'success',
      borderColor: {
        default: 'transparent',
        hover: 'success',
        focus: 'success'
      }
    },
    warning: {
      color: 'warning',
      borderColor: {
        default: 'transparent',
        hover: 'warning',
        focus: 'warning'
      }
    },
    danger: {
      color: 'danger',
      borderColor: {
        default: 'transparent',
        hover: 'danger',
        focus: 'danger'
      }
    }
  },
  outlined: {
    default: {
      borderColor: {
        default: 'input',
        hover: 'input',
        focus: 'primary',
        active: 'primary'
      }
    },
    success: {
      borderColor: {
        default: 'success',
        hover: 'success',
        focus: 'success'
      }
    },
    warning: {
      borderColor: {
        default: 'warning',
        hover: 'warning',
        focus: 'warning'
      }
    },
    danger: {
      borderColor: {
        default: 'danger',
        hover: 'danger',
        focus: 'danger'
      }
    }
  }
};

const defaultElement$8 = 'button';

function Button({
  appearance = 'default',
  intent = 'default',
  size = 'md',
  disabled,
  loading,
  className,
  icon,
  iconRight,
  label,
  children,
  active,
  autoFocus,
  onPress,
  onPressChange,
  onPressEnd,
  onPressStart,
  onPressUp,
  noFocusRing,
  fullWidth,
  ...props
}, ref) {
  var _a, _b, _c, _d, _e;

  const domRef = useFocusableRef(ref);
  const {
    buttonProps
  } = useButton({
    isDisabled: disabled,
    onPress,
    onPressChange,
    onPressEnd,
    onPressStart,
    onPressUp,
    ...props
  }, domRef);
  const {
    hoverProps
  } = useHover({
    isDisabled: disabled,
    ...props
  });
  const {
    matchedProps,
    remainingProps
  } = splitBoxProps(props);
  const stateProps = { ...variants$5.default.default,
    ...variants$5.default[intent],
    ...((_a = variants$5[appearance]) === null || _a === void 0 ? void 0 : _a.default),
    ...((_b = variants$5[appearance]) === null || _b === void 0 ? void 0 : _b[intent])
  };
  /**
   * If active, remove other state effects
   */

  if (active) {
    for (const i in stateProps) {
      const prop = stateProps[i];

      if (prop && typeof prop === 'object') {
        if (prop.hasOwnProperty('active')) {
          stateProps[i] = prop.active;
        } else if (prop.hasOwnProperty('hover')) {
          // remove props immutably
          const {
            hover,
            ...newProps
          } = stateProps[i];
          stateProps[i] = newProps;
        }
      }
    }
  }
  /**
   * If in loading or disabled states, remove other ui effects like hover
   */


  if (loading || disabled) {
    for (const i in stateProps) {
      const prop = stateProps[i];

      if (prop && typeof prop === 'object') {
        // remove props immutably
        const {
          active,
          hover,
          ...newProps
        } = stateProps[i];
        stateProps[i] = newProps;
      }
    }
  }

  const {
    color,
    ...propsWithoutColor
  } = mergeProps(matchedProps, buttonProps, hoverProps);

  const elem = jsxs(Box, Object.assign({
    as: defaultElement$8,
    px: (_c = sizes$7[size]) === null || _c === void 0 ? void 0 : _c.px,
    fontSize: (_d = sizes$7[size]) === null || _d === void 0 ? void 0 : _d.fontSize,
    fontWeight: "medium",
    rounded: (_e = sizes$7[size]) === null || _e === void 0 ? void 0 : _e.rounded,
    h: size,
    borderColor: "button",
    className: cn('sl-button', className),
    disabled: loading || disabled,
    cursor: loading ? 'wait' : disabled ? 'not-allowed' : undefined,
    border: true,
    opacity: loading ? 70 : undefined,
    w: fullWidth ? 'full' : undefined,
    justifyContent: fullWidth ? 'center' : undefined
  }, remainingProps, stateProps, propsWithoutColor, {
    ref: domRef
  }, {
    children: [loading ? jsx(ButtonIcon, {
      icon: "spinner",
      pulse: true,
      size: size,
      hasContent: !!children
    }, void 0) : null, icon && !loading ? jsx(ButtonIcon, {
      icon: icon,
      size: size,
      hasContent: !!children
    }, void 0) : null, children, iconRight ? jsx(ButtonRightIcon, {
      icon: iconRight,
      size: size
    }, void 0) : null]
  }), void 0);

  if (noFocusRing) {
    return elem;
  }

  return jsx(FocusRing, Object.assign({
    focusRingClass: "sl-focus-ring",
    autoFocus: autoFocus
  }, {
    children: elem
  }), void 0);
}

const _Button = /*#__PURE__*/forwardRef(Button);

const ButtonIcon = ({
  icon,
  size,
  hasContent,
  pulse
}) => {
  var _a, _b;

  let elem = icon;

  if (isIconProp(icon)) {
    elem = jsx(Icon, {
      icon: icon,
      size: size === 'sm' ? 'sm' : undefined,
      pulse: pulse,
      fixedWidth: true
    }, void 0);
  }

  return jsx(Box, Object.assign({
    mr: hasContent ? (_a = sizes$7[size]) === null || _a === void 0 ? void 0 : _a.leftIconMr : undefined,
    mx: hasContent ? undefined : (_b = sizes$7[size]) === null || _b === void 0 ? void 0 : _b.leftIconMx
  }, {
    children: elem
  }), void 0);
};

const ButtonRightIcon = ({
  icon,
  size
}) => {
  var _a, _b, _c;

  let elem = icon;

  if (isIconProp(icon)) {
    elem = jsx(Icon, {
      icon: icon,
      fixedWidth: true
    }, void 0);
  }

  return jsx(Box, Object.assign({
    ml: (_a = sizes$7[size]) === null || _a === void 0 ? void 0 : _a.rightIconMl,
    mr: (_b = sizes$7[size]) === null || _b === void 0 ? void 0 : _b.rightIconMr,
    fontSize: (_c = sizes$7[size]) === null || _c === void 0 ? void 0 : _c.iconSize
  }, {
    children: elem
  }), void 0);
};

const defaultElement$7 = 'div';
const ButtonGroup = /*#__PURE__*/memo( /*#__PURE__*/forwardRef(({
  children,
  className,
  ...rest
}, ref) => {
  return jsx(Flex, Object.assign({
    as: defaultElement$7
  }, rest, {
    justifyItems: "start",
    alignItems: "center",
    className: cn('sl-button-group', className),
    ref: ref
  }, {
    children: children
  }), void 0);
}));

function useClipboard(text, timeout = 1500) {
  const [hasCopied, setHasCopied] = useState(false);
  const onCopy = useCallback(() => {
    const didCopy = copy(text);
    setHasCopied(didCopy);
  }, [text]);
  useEffect(() => {
    if (hasCopied) {
      const id = setTimeout(() => {
        setHasCopied(false);
      }, timeout);
      return () => clearTimeout(id);
    }
  }, [timeout, hasCopied]);
  return {
    value: text,
    onCopy,
    hasCopied
  };
}

function useCollectionKeyAccumulator(nodes, targetProp, targetValue) {
  const accumulator = useRef(accumulateCollectionKeysByProp(targetProp, targetValue));
  return accumulator.current(nodes);
}

/* eslint-disable react-hooks/exhaustive-deps */
function useControllableProp(prop, state) {
  const {
    current: isControlled
  } = _react.useRef(prop !== undefined);
  const value = isControlled && typeof prop !== 'undefined' ? prop : state;
  return [isControlled, value];
}
const defaultPropsMap = {
  value: 'value',
  defaultValue: 'defaultValue',
  onChange: 'onChange'
};
/**
 * React hook for using controlling component state.
 * @param props
 */

function useControllableState(props) {
  const {
    value: valueProp,
    defaultValue,
    onChange,
    name = 'Component',
    propsMap = defaultPropsMap
  } = props;
  const [valueState, setValue] = _react.useState(defaultValue);
  const {
    current: isControlled
  } = _react.useRef(valueProp !== undefined); // don't switch from controlled to uncontrolled

  _react.useEffect(() => {
    const nextIsControlled = valueProp !== undefined;
    const nextMode = nextIsControlled ? 'a controlled' : 'an uncontrolled';
    const mode = isControlled ? 'a controlled' : 'an uncontrolled';
    warn({
      condition: isControlled !== nextIsControlled,
      message: `Warning: ${name} is changing from ${mode} to ${nextMode} component. ` + `Components should not switch from controlled to uncontrolled (or vice versa). ` + `Use the '${propsMap.value}' with an '${propsMap.onChange}' handler. ` + `If you want an uncontrolled component, remove the ${propsMap.value} prop and use '${propsMap.defaultValue}' instead. "` + `More info: https://fb.me/react-controlled-components`
    });
  }, [valueProp, isControlled, name]);
  const {
    current: initialDefaultValue
  } = _react.useRef(defaultValue);
  _react.useEffect(() => {
    warn({
      condition: initialDefaultValue !== defaultValue,
      message: `Warning: A component is changing the default value of an uncontrolled ${name} after being initialized. ` + `To suppress this warning opt to use a controlled ${name}.`
    });
  }, [JSON.stringify(defaultValue)]);
  const value = isControlled ? valueProp : valueState;
  const updateValue = _react.useCallback(next => {
    const nextValue = runIfFn(next, value);
    if (!isControlled) setValue(nextValue);
    onChange === null || onChange === void 0 ? void 0 : onChange(nextValue);
  }, [onChange]);
  return [value, updateValue];
}

const useModalityStore = create(set => ({
  currentModality: null,
  setInteractionModality: modality => set(state => {
    return { ...state,
      currentModality: modality
    };
  })
}));
function useInteractionModality() {
  return useModalityStore(state => state.currentModality);
}
function getInteractionModality() {
  return useModalityStore.getState().currentModality;
}
/**
 * Helper function to determine if a KeyboardEvent is unmodified and could make keyboard focus styles visible.
 */

function isValidKey(e) {
  // Control and Shift keys trigger when navigating back to the tab with keyboard.
  return !(e.metaKey || !isMac() && e.altKey || e.ctrlKey || e.type === 'keyup' && (e.key === 'Control' || e.key === 'Shift'));
}

function handleKeyboardEvent(e) {
  if (isValidKey(e)) {
    const {
      currentModality
    } = useModalityStore.getState();

    if (currentModality !== 'keyboard') {
      unstable_batchedUpdates(() => {
        useModalityStore.getState().setInteractionModality('keyboard');
      });
    }
  }
}

function handlePointerEvent() {
  const state = useModalityStore.getState();

  if (state.currentModality !== 'pointer') {
    unstable_batchedUpdates(() => {
      useModalityStore.getState().setInteractionModality('pointer');
    });
  }
}

function isVirtualClick(event) {
  // JAWS/NVDA with Firefox.
  if (event.mozInputSource === 0 && event.isTrusted) {
    return true;
  }

  return event.detail === 0 && !event.pointerType;
}

function handleClickEvent(e) {
  if (isVirtualClick(e)) {
    const state = useModalityStore.getState();

    if (state.currentModality !== 'virtual') {
      unstable_batchedUpdates(() => {
        useModalityStore.getState().setInteractionModality('virtual');
      });
    }
  }
}

let hasSetupGlobalListeners = false;

function setupGlobalFocusEvents() {
  if (typeof window === 'undefined' || hasSetupGlobalListeners) {
    return;
  }

  document.addEventListener('keydown', handleKeyboardEvent, true);
  document.addEventListener('keyup', handleKeyboardEvent, true);
  document.addEventListener('click', handleClickEvent, true);

  if (typeof PointerEvent !== 'undefined') {
    document.addEventListener('pointerdown', handlePointerEvent, true);
    document.addEventListener('pointermove', handlePointerEvent, true);
    document.addEventListener('pointerup', handlePointerEvent, true);
  } else {
    document.addEventListener('mousedown', handlePointerEvent, true);
    document.addEventListener('mousemove', handlePointerEvent, true);
    document.addEventListener('mouseup', handlePointerEvent, true);
  }

  hasSetupGlobalListeners = true;
}

if (typeof document !== 'undefined') {
  if (document.readyState !== 'loading') {
    setupGlobalFocusEvents();
  } else {
    document.addEventListener('DOMContentLoaded', setupGlobalFocusEvents);
  }
}

const defaultMosaicContext = {
  componentOverrides: {}
};
const MosaicContext = /*#__PURE__*/_react.createContext(defaultMosaicContext);

const useMosaicContext = () => {
  return useContext(MosaicContext);
};

const visibleOverlays = [];
/**
 * Provides the behavior for overlays such as dialogs, popovers, and menus.
 * Hides the overlay when the user interacts outside it, when the Escape key is pressed,
 * or optionally, on blur. Only the top-most overlay will close at once.
 */

function useOverlay(props, ref) {
  let {
    onClose,
    shouldCloseOnBlur,
    isOpen,
    isDismissable = false,
    isKeyboardDismissDisabled = false,
    shouldCloseOnInteractOutside
  } = props; // Add the overlay ref to the stack of visible overlays on mount, and remove on unmount.

  useEffect(() => {
    if (isOpen) {
      visibleOverlays.push(ref);
    }

    return () => {
      let index = visibleOverlays.indexOf(ref);

      if (index >= 0) {
        visibleOverlays.splice(index, 1);
      }
    };
  }, [isOpen, ref]); // Only hide the overlay when it is the topmost visible overlay in the stack.

  let onHide = () => {
    if (visibleOverlays[visibleOverlays.length - 1] === ref && onClose) {
      onClose();
    }
  };

  let onInteractOutsideStart = e => {
    if (!shouldCloseOnInteractOutside || shouldCloseOnInteractOutside(e.target)) {
      const modality = getInteractionModality$1();

      if (modality !== 'pointer' && visibleOverlays[visibleOverlays.length - 1] === ref) {
        e.stopPropagation();
        e.preventDefault();
      }
    }
  };

  let onInteractOutside = e => {
    if (!shouldCloseOnInteractOutside || shouldCloseOnInteractOutside(e.target)) {
      const modality = getInteractionModality$1();

      if (modality !== 'pointer' && visibleOverlays[visibleOverlays.length - 1] === ref) {
        e.stopPropagation();
        e.preventDefault();
      }

      onHide();
    }
  }; // Handle the escape key


  let onKeyDown = e => {
    if (e.key === 'Escape' && !isKeyboardDismissDisabled) {
      e.preventDefault();
      onHide();
    }
  }; // Handle clicking outside the overlay to close it


  useInteractOutside({
    ref,
    onInteractOutside: isDismissable ? onInteractOutside : null,
    onInteractOutsideStart
  });
  let {
    focusWithinProps
  } = useFocusWithin({
    isDisabled: !shouldCloseOnBlur,
    onBlurWithin: () => {
      if (!shouldCloseOnInteractOutside || shouldCloseOnInteractOutside(document.activeElement)) {
        onClose();
      }
    }
  });

  let onPointerDownUnderlay = e => {
    // fixes a firefox issue that starts text selection https://bugzilla.mozilla.org/show_bug.cgi?id=1675846
    if (e.target === e.currentTarget) {
      e.preventDefault();
    }
  };

  return {
    overlayProps: {
      onKeyDown,
      ...focusWithinProps
    },
    underlayProps: {
      onPointerDown: onPointerDownUnderlay
    }
  };
}

const $f431c2c11cc559fa3c5864caafbcfd19$var$styles = {
  border: 0,
  clip: 'rect(0 0 0 0)',
  clipPath: 'inset(50%)',
  height: 1,
  margin: '0 -1px -1px 0',
  overflow: 'hidden',
  padding: 0,
  position: 'absolute',
  width: 1,
  whiteSpace: 'nowrap'
};

/**
 * Provides props for an element that hides its children visually
 * but keeps content visible to assistive technology.
 */
function useVisuallyHidden$1(props) {
  if (props === void 0) {
    props = {};
  }

  let {
    style,
    isFocusable
  } = props;
  let [isFocused, setFocused] = useState(false);
  let {
    focusProps
  } = useFocus({
    isDisabled: !isFocusable,
    onFocusChange: setFocused
  }); // If focused, don't hide the element.

  let combinedStyles = useMemo(() => {
    if (isFocused) {
      return style;
    } else if (style) {
      return _extends({}, $f431c2c11cc559fa3c5864caafbcfd19$var$styles, style);
    } else {
      return $f431c2c11cc559fa3c5864caafbcfd19$var$styles;
    }
  }, [isFocused]);
  return {
    visuallyHiddenProps: _extends({}, focusProps, {
      style: combinedStyles
    })
  };
}

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}

const $d45e305fb90d49e7c81f49bb4afe323b$var$AXIS = {
  top: 'top',
  bottom: 'top',
  left: 'left',
  right: 'left'
};
const $d45e305fb90d49e7c81f49bb4afe323b$var$FLIPPED_DIRECTION = {
  top: 'bottom',
  bottom: 'top',
  left: 'right',
  right: 'left'
};
const $d45e305fb90d49e7c81f49bb4afe323b$var$CROSS_AXIS = {
  top: 'left',
  left: 'top'
};
const $d45e305fb90d49e7c81f49bb4afe323b$var$AXIS_SIZE = {
  top: 'height',
  left: 'width'
};
const $d45e305fb90d49e7c81f49bb4afe323b$var$PARSED_PLACEMENT_CACHE = {}; // @ts-ignore

let $d45e305fb90d49e7c81f49bb4afe323b$var$visualViewport = typeof window !== 'undefined' && window.visualViewport;

function $d45e305fb90d49e7c81f49bb4afe323b$var$getContainerDimensions(containerNode) {
  let width = 0,
      height = 0,
      top = 0,
      left = 0;
  let scroll = {};

  if (containerNode.tagName === 'BODY') {
    var _visualViewport$width, _visualViewport$heigh;

    width = (_visualViewport$width = $d45e305fb90d49e7c81f49bb4afe323b$var$visualViewport == null ? void 0 : $d45e305fb90d49e7c81f49bb4afe323b$var$visualViewport.width) != null ? _visualViewport$width : document.documentElement.clientWidth;
    height = (_visualViewport$heigh = $d45e305fb90d49e7c81f49bb4afe323b$var$visualViewport == null ? void 0 : $d45e305fb90d49e7c81f49bb4afe323b$var$visualViewport.height) != null ? _visualViewport$heigh : document.documentElement.clientHeight;
    scroll.top = _domHelpersQueryScrollTop(_domHelpersOwnerDocument(containerNode).documentElement) || _domHelpersQueryScrollTop(containerNode);
    scroll.left = _domHelpersQueryScrollLeft(_domHelpersOwnerDocument(containerNode).documentElement) || _domHelpersQueryScrollLeft(containerNode);
  } else {
    ({
      width,
      height,
      top,
      left
    } = _domHelpersQueryOffset(containerNode));
    scroll.top = _domHelpersQueryScrollTop(containerNode);
    scroll.left = _domHelpersQueryScrollLeft(containerNode);
  }

  return {
    width,
    height,
    scroll,
    top,
    left
  };
}

function $d45e305fb90d49e7c81f49bb4afe323b$var$getScroll(node) {
  return {
    top: node.scrollTop,
    left: node.scrollLeft,
    width: node.scrollWidth,
    height: node.scrollHeight
  };
}

function $d45e305fb90d49e7c81f49bb4afe323b$var$getDelta(axis, offset, size, containerDimensions, padding) {
  let containerScroll = containerDimensions.scroll[axis];
  let containerHeight = containerDimensions[$d45e305fb90d49e7c81f49bb4afe323b$var$AXIS_SIZE[axis]];
  let startEdgeOffset = offset - padding - containerScroll;
  let endEdgeOffset = offset + padding - containerScroll + size;

  if (startEdgeOffset < 0) {
    return -startEdgeOffset;
  } else if (endEdgeOffset > containerHeight) {
    return Math.max(containerHeight - endEdgeOffset, -startEdgeOffset);
  } else {
    return 0;
  }
}

function $d45e305fb90d49e7c81f49bb4afe323b$var$getMargins(node) {
  let style = window.getComputedStyle(node);
  return {
    top: parseInt(style.marginTop, 10) || 0,
    bottom: parseInt(style.marginBottom, 10) || 0,
    left: parseInt(style.marginLeft, 10) || 0,
    right: parseInt(style.marginRight, 10) || 0
  };
}

function $d45e305fb90d49e7c81f49bb4afe323b$var$parsePlacement(input) {
  if ($d45e305fb90d49e7c81f49bb4afe323b$var$PARSED_PLACEMENT_CACHE[input]) {
    return $d45e305fb90d49e7c81f49bb4afe323b$var$PARSED_PLACEMENT_CACHE[input];
  }

  let [placement, crossPlacement] = input.split(' ');
  let axis = $d45e305fb90d49e7c81f49bb4afe323b$var$AXIS[placement] || 'right';
  let crossAxis = $d45e305fb90d49e7c81f49bb4afe323b$var$CROSS_AXIS[axis];

  if (!$d45e305fb90d49e7c81f49bb4afe323b$var$AXIS[crossPlacement]) {
    crossPlacement = 'center';
  }

  let size = $d45e305fb90d49e7c81f49bb4afe323b$var$AXIS_SIZE[axis];
  let crossSize = $d45e305fb90d49e7c81f49bb4afe323b$var$AXIS_SIZE[crossAxis];
  $d45e305fb90d49e7c81f49bb4afe323b$var$PARSED_PLACEMENT_CACHE[input] = {
    placement,
    crossPlacement,
    axis,
    crossAxis,
    size,
    crossSize
  };
  return $d45e305fb90d49e7c81f49bb4afe323b$var$PARSED_PLACEMENT_CACHE[input];
}

function $d45e305fb90d49e7c81f49bb4afe323b$var$computePosition(childOffset, boundaryDimensions, overlaySize, placementInfo, offset, crossOffset, containerOffsetWithBoundary, isContainerPositioned) {
  let {
    placement,
    crossPlacement,
    axis,
    crossAxis,
    size,
    crossSize
  } = placementInfo;
  let position = {}; // button position

  position[crossAxis] = childOffset[crossAxis];

  if (crossPlacement === 'center') {
    //  + (button size / 2) - (overlay size / 2)
    // at this point the overlay center should match the button center
    position[crossAxis] += (childOffset[crossSize] - overlaySize[crossSize]) / 2;
  } else if (crossPlacement !== crossAxis) {
    //  + (button size) - (overlay size)
    // at this point the overlay bottom should match the button bottom
    position[crossAxis] += childOffset[crossSize] - overlaySize[crossSize];
  }
  /* else {
   the overlay top should match the button top
  } */
  // add the crossOffset from props


  position[crossAxis] += crossOffset; // this is button center position - the overlay size + half of the button to align bottom of overlay with button center

  let minViablePosition = childOffset[crossAxis] + childOffset[crossSize] / 2 - overlaySize[crossSize]; // this is button position of center, aligns top of overlay with button center

  let maxViablePosition = childOffset[crossAxis] + childOffset[crossSize] / 2; // clamp it into the range of the min/max positions

  position[crossAxis] = Math.min(Math.max(minViablePosition, position[crossAxis]), maxViablePosition); // Floor these so the position isn't placed on a partial pixel, only whole pixels. Shouldn't matter if it was floored or ceiled, so chose one.

  if (placement === axis) {
    // If the container is positioned (non-static), then we use the container's actual
    // height, as `bottom` will be relative to this height.  But if the container is static,
    // then it can only be the `document.body`, and `bottom` will be relative to _its_
    // container, which should be as large as boundaryDimensions.
    const containerHeight = isContainerPositioned ? containerOffsetWithBoundary[size] : boundaryDimensions[size];
    position[$d45e305fb90d49e7c81f49bb4afe323b$var$FLIPPED_DIRECTION[axis]] = Math.floor(containerHeight - childOffset[axis] + offset);
  } else {
    position[axis] = Math.floor(childOffset[axis] + childOffset[size] + offset);
  }

  return position;
}

function $d45e305fb90d49e7c81f49bb4afe323b$var$getMaxHeight(position, boundaryDimensions, containerOffsetWithBoundary, childOffset, margins, padding) {
  return position.top != null // We want the distance between the top of the overlay to the bottom of the boundary
  ? Math.max(0, boundaryDimensions.height + boundaryDimensions.top + boundaryDimensions.scroll.top - ( // this is the bottom of the boundary
  containerOffsetWithBoundary.top + position.top) // this is the top of the overlay
  - (margins.top + margins.bottom + padding) // save additional space for margin and padding
  ) // We want the distance between the top of the trigger to the top of the boundary
  : Math.max(0, childOffset.top + containerOffsetWithBoundary.top - ( // this is the top of the trigger
  boundaryDimensions.top + boundaryDimensions.scroll.top) // this is the top of the boundary
  - (margins.top + margins.bottom + padding) // save additional space for margin and padding
  );
}

function $d45e305fb90d49e7c81f49bb4afe323b$var$getAvailableSpace(boundaryDimensions, containerOffsetWithBoundary, childOffset, margins, padding, placementInfo) {
  let {
    placement,
    axis,
    size
  } = placementInfo;

  if (placement === axis) {
    return Math.max(0, childOffset[axis] - boundaryDimensions[axis] - boundaryDimensions.scroll[axis] + containerOffsetWithBoundary[axis] - margins[axis] - margins[$d45e305fb90d49e7c81f49bb4afe323b$var$FLIPPED_DIRECTION[axis]] - padding);
  }

  return Math.max(0, boundaryDimensions[size] + boundaryDimensions[axis] + boundaryDimensions.scroll[axis] - containerOffsetWithBoundary[axis] - childOffset[axis] - childOffset[size] - margins[axis] - margins[$d45e305fb90d49e7c81f49bb4afe323b$var$FLIPPED_DIRECTION[axis]] - padding);
}

function $d45e305fb90d49e7c81f49bb4afe323b$export$calculatePositionInternal(placementInput, childOffset, overlaySize, scrollSize, margins, padding, flip, boundaryDimensions, containerOffsetWithBoundary, offset, crossOffset, isContainerPositioned) {
  let placementInfo = $d45e305fb90d49e7c81f49bb4afe323b$var$parsePlacement(placementInput);
  let {
    size,
    crossAxis,
    crossSize,
    placement,
    crossPlacement
  } = placementInfo;
  let position = $d45e305fb90d49e7c81f49bb4afe323b$var$computePosition(childOffset, boundaryDimensions, overlaySize, placementInfo, offset, crossOffset, containerOffsetWithBoundary, isContainerPositioned);
  let normalizedOffset = offset;
  let space = $d45e305fb90d49e7c81f49bb4afe323b$var$getAvailableSpace(boundaryDimensions, containerOffsetWithBoundary, childOffset, margins, padding + offset, placementInfo); // Check if the scroll size of the overlay is greater than the available space to determine if we need to flip

  if (flip && scrollSize[size] > space) {
    let flippedPlacementInfo = $d45e305fb90d49e7c81f49bb4afe323b$var$parsePlacement($d45e305fb90d49e7c81f49bb4afe323b$var$FLIPPED_DIRECTION[placement] + " " + crossPlacement);
    let flippedPosition = $d45e305fb90d49e7c81f49bb4afe323b$var$computePosition(childOffset, boundaryDimensions, overlaySize, flippedPlacementInfo, offset, crossOffset, containerOffsetWithBoundary, isContainerPositioned);
    let flippedSpace = $d45e305fb90d49e7c81f49bb4afe323b$var$getAvailableSpace(boundaryDimensions, containerOffsetWithBoundary, childOffset, margins, padding + offset, flippedPlacementInfo); // If the available space for the flipped position is greater than the original available space, flip.

    if (flippedSpace > space) {
      placementInfo = flippedPlacementInfo;
      position = flippedPosition;
      normalizedOffset = offset;
    }
  }

  let delta = $d45e305fb90d49e7c81f49bb4afe323b$var$getDelta(crossAxis, position[crossAxis], overlaySize[crossSize], boundaryDimensions, padding);
  position[crossAxis] += delta;
  let maxHeight = $d45e305fb90d49e7c81f49bb4afe323b$var$getMaxHeight(position, boundaryDimensions, containerOffsetWithBoundary, childOffset, margins, padding);
  overlaySize.height = Math.min(overlaySize.height, maxHeight);
  position = $d45e305fb90d49e7c81f49bb4afe323b$var$computePosition(childOffset, boundaryDimensions, overlaySize, placementInfo, normalizedOffset, crossOffset, containerOffsetWithBoundary, isContainerPositioned);
  delta = $d45e305fb90d49e7c81f49bb4afe323b$var$getDelta(crossAxis, position[crossAxis], overlaySize[crossSize], boundaryDimensions, padding);
  position[crossAxis] += delta;
  let arrowPosition = {};
  arrowPosition[crossAxis] = childOffset[crossAxis] - position[crossAxis] + childOffset[crossSize] / 2;
  return {
    position,
    maxHeight: maxHeight,
    arrowOffsetLeft: arrowPosition.left,
    arrowOffsetTop: arrowPosition.top,
    placement: placementInfo.placement
  };
}
/**
 * Determines where to place the overlay with regards to the target and the position of an optional indicator.
 */


function $d45e305fb90d49e7c81f49bb4afe323b$export$calculatePosition(opts) {
  let {
    placement,
    targetNode,
    overlayNode,
    scrollNode,
    padding,
    shouldFlip,
    boundaryElement,
    offset,
    crossOffset
  } = opts;
  let container = overlayNode.offsetParent || document.body;
  let isBodyContainer = container.tagName === 'BODY';
  const containerPositionStyle = window.getComputedStyle(container).position;
  let isContainerPositioned = !!containerPositionStyle && containerPositionStyle !== 'static';
  let childOffset = isBodyContainer ? _domHelpersQueryOffset(targetNode) : _domHelpersQueryPosition(targetNode, container);

  if (!isBodyContainer) {
    childOffset.top += parseInt(_domHelpersStyle(targetNode, 'marginTop'), 10) || 0;
    childOffset.left += parseInt(_domHelpersStyle(targetNode, 'marginLeft'), 10) || 0;
  }

  let overlaySize = _domHelpersQueryOffset(overlayNode);

  let margins = $d45e305fb90d49e7c81f49bb4afe323b$var$getMargins(overlayNode);
  overlaySize.width += margins.left + margins.right;
  overlaySize.height += margins.top + margins.bottom;
  let scrollSize = $d45e305fb90d49e7c81f49bb4afe323b$var$getScroll(scrollNode);
  let boundaryDimensions = $d45e305fb90d49e7c81f49bb4afe323b$var$getContainerDimensions(boundaryElement);
  let containerOffsetWithBoundary = boundaryElement.tagName === 'BODY' ? _domHelpersQueryOffset(container) : _domHelpersQueryPosition(container, boundaryElement);
  return $d45e305fb90d49e7c81f49bb4afe323b$export$calculatePositionInternal(placement, childOffset, overlaySize, scrollSize, margins, padding, shouldFlip, boundaryDimensions, containerOffsetWithBoundary, offset, crossOffset, isContainerPositioned);
}

// This behavior moved from useOverlayTrigger to useOverlayPosition.
// For backward compatibility, where useOverlayTrigger handled hiding the popover on close,
// it sets a close function here mapped from the trigger element. This way we can avoid
// forcing users to pass an onClose function to useOverlayPosition which could be considered
// a breaking change.
const $df1b2f080f58bf9e74aeb666b8c96ba$export$onCloseMap = new WeakMap();

/** @private */
function $df1b2f080f58bf9e74aeb666b8c96ba$export$useCloseOnScroll(opts) {
  let {
    triggerRef,
    isOpen,
    onClose
  } = opts;
  useEffect(() => {
    if (!isOpen) {
      return;
    }

    let onScroll = e => {
      // Ignore if scrolling an scrollable region outside the trigger's tree.
      let target = e.target;

      if (!triggerRef.current || !target.contains(triggerRef.current)) {
        return;
      }

      let onCloseHandler = onClose || $df1b2f080f58bf9e74aeb666b8c96ba$export$onCloseMap.get(triggerRef.current);

      if (onCloseHandler) {
        onCloseHandler();
      }
    };

    window.addEventListener('scroll', onScroll, true);
    return () => {
      window.removeEventListener('scroll', onScroll, true);
    };
  }, [isOpen, onClose, triggerRef]);
}

// @ts-ignore
let $ae841ee9d3f76b31663cf0594adb0fc$var$visualViewport = typeof window !== 'undefined' && window.visualViewport;
/**
 * Handles positioning overlays like popovers and menus relative to a trigger
 * element, and updating the position when the window resizes.
 */

function useOverlayPosition$1(props) {
  let {
    direction
  } = useLocale();
  let {
    targetRef,
    overlayRef,
    scrollRef = overlayRef,
    placement = 'bottom',
    containerPadding = 12,
    shouldFlip = true,
    boundaryElement = typeof document !== 'undefined' ? document.body : null,
    offset = 0,
    crossOffset = 0,
    shouldUpdatePosition = true,
    isOpen = true,
    onClose
  } = props;
  let [position, setPosition] = useState({
    position: {},
    arrowOffsetLeft: undefined,
    arrowOffsetTop: undefined,
    maxHeight: undefined,
    placement: undefined
  });
  let deps = [shouldUpdatePosition, placement, overlayRef.current, targetRef.current, scrollRef.current, containerPadding, shouldFlip, boundaryElement, offset, crossOffset, isOpen, direction];
  let updatePosition = useCallback(() => {
    if (shouldUpdatePosition === false || !isOpen || !overlayRef.current || !targetRef.current || !scrollRef.current || !boundaryElement) {
      return;
    }

    setPosition($d45e305fb90d49e7c81f49bb4afe323b$export$calculatePosition({
      placement: $ae841ee9d3f76b31663cf0594adb0fc$var$translateRTL(placement, direction),
      overlayNode: overlayRef.current,
      targetNode: targetRef.current,
      scrollNode: scrollRef.current,
      padding: containerPadding,
      shouldFlip,
      boundaryElement,
      offset,
      crossOffset
    }));
  }, deps); // Update position when anything changes

  useLayoutEffect(updatePosition, deps); // Update position on window resize

  $ae841ee9d3f76b31663cf0594adb0fc$var$useResize(updatePosition); // Reposition the overlay and do not close on scroll while the visual viewport is resizing.
  // This will ensure that overlays adjust their positioning when the iOS virtual keyboard appears.

  let isResizing = useRef(false);
  useLayoutEffect(() => {
    let timeout;

    let onResize = () => {
      isResizing.current = true;
      clearTimeout(timeout);
      timeout = setTimeout(() => {
        isResizing.current = false;
      }, 500);
      updatePosition();
    };

    $ae841ee9d3f76b31663cf0594adb0fc$var$visualViewport == null ? void 0 : $ae841ee9d3f76b31663cf0594adb0fc$var$visualViewport.addEventListener('resize', onResize);
    return () => {
      $ae841ee9d3f76b31663cf0594adb0fc$var$visualViewport == null ? void 0 : $ae841ee9d3f76b31663cf0594adb0fc$var$visualViewport.removeEventListener('resize', onResize);
    };
  }, [updatePosition]);
  let close = useCallback(() => {
    if (!isResizing.current) {
      onClose();
    }
  }, [onClose, isResizing]); // When scrolling a parent scrollable region of the trigger (other than the body),
  // we hide the popover. Otherwise, its position would be incorrect.

  $df1b2f080f58bf9e74aeb666b8c96ba$export$useCloseOnScroll({
    triggerRef: targetRef,
    isOpen,
    onClose: onClose ? close : undefined
  });
  return {
    overlayProps: {
      style: _extends({
        position: 'absolute',
        zIndex: 100000
      }, position.position, {
        maxHeight: position.maxHeight
      })
    },
    placement: position.placement,
    arrowProps: {
      style: {
        left: position.arrowOffsetLeft,
        top: position.arrowOffsetTop
      }
    },
    updatePosition
  };
}

function $ae841ee9d3f76b31663cf0594adb0fc$var$useResize(onResize) {
  useLayoutEffect(() => {
    window.addEventListener('resize', onResize, false);
    return () => {
      window.removeEventListener('resize', onResize, false);
    };
  }, [onResize]);
}

function $ae841ee9d3f76b31663cf0594adb0fc$var$translateRTL(position, direction) {
  if (direction === 'rtl') {
    return position.replace('start', 'right').replace('end', 'left');
  }

  return position.replace('start', 'left').replace('end', 'right');
}

/**
 * Handles the behavior and accessibility for an overlay trigger, e.g. a button
 * that opens a popover, menu, or other overlay that is positioned relative to the trigger.
 */
function useOverlayTrigger(props, state, ref) {
  let {
    type
  } = props;
  let {
    isOpen
  } = state; // Backward compatibility. Share state close function with useOverlayPosition so it can close on scroll
  // without forcing users to pass onClose.

  useEffect(() => {
    if (ref.current) {
      $df1b2f080f58bf9e74aeb666b8c96ba$export$onCloseMap.set(ref.current, state.close);
    }
  }); // Aria 1.1 supports multiple values for aria-haspopup other than just menus.
  // https://www.w3.org/TR/wai-aria-1.1/#aria-haspopup
  // However, we only add it for menus for now because screen readers often
  // announce it as a menu even for other values.

  let ariaHasPopup = undefined;

  if (type === 'menu') {
    ariaHasPopup = true;
  } else if (type === 'listbox') {
    ariaHasPopup = 'listbox';
  }

  let overlayId = useId();
  return {
    triggerProps: {
      'aria-haspopup': ariaHasPopup,
      'aria-expanded': isOpen,
      'aria-controls': isOpen ? overlayId : null
    },
    overlayProps: {
      id: overlayId
    }
  };
}
// @ts-ignore
const $ece0076f06e8a828c60ba0c94f22f89$var$visualViewport = typeof window !== 'undefined' && window.visualViewport; // HTML input types that do not cause the software keyboard to appear.

const $ece0076f06e8a828c60ba0c94f22f89$var$nonTextInputTypes = new Set(['checkbox', 'radio', 'range', 'color', 'file', 'image', 'button', 'submit', 'reset']);
/**
 * Prevents scrolling on the document body on mount, and
 * restores it on unmount. Also ensures that content does not
 * shift due to the scrollbars disappearing.
 */

function usePreventScroll(options) {
  if (options === void 0) {
    options = {};
  }

  let {
    isDisabled
  } = options;
  useLayoutEffect(() => {
    if (isDisabled) {
      return;
    }

    if (isIOS()) {
      return $ece0076f06e8a828c60ba0c94f22f89$var$preventScrollMobileSafari();
    } else {
      return $ece0076f06e8a828c60ba0c94f22f89$var$preventScrollStandard();
    }
  }, [isDisabled]);
} // For most browsers, all we need to do is set `overflow: hidden` on the root element, and
// add some padding to prevent the page from shifting when the scrollbar is hidden.

function $ece0076f06e8a828c60ba0c94f22f89$var$preventScrollStandard() {
  return chain($ece0076f06e8a828c60ba0c94f22f89$var$setStyle(document.documentElement, 'paddingRight', window.innerWidth - document.documentElement.clientWidth + "px"), $ece0076f06e8a828c60ba0c94f22f89$var$setStyle(document.documentElement, 'overflow', 'hidden'));
} // Mobile Safari is a whole different beast. Even with overflow: hidden,
// it still scrolls the page in many situations:
//
// 1. When the bottom toolbar and address bar are collapsed, page scrolling is always allowed.
// 2. When the keyboard is visible, the viewport does not resize. Instead, the keyboard covers part of
//    it, so it becomes scrollable.
// 3. When tapping on an input, the page always scrolls so that the input is centered in the visual viewport.
//    This may cause even fixed position elements to scroll off the screen.
// 4. When using the next/previous buttons in the keyboard to navigate between inputs, the whole page always
//    scrolls, even if the input is inside a nested scrollable element that could be scrolled instead.
//
// In order to work around these cases, and prevent scrolling without jankiness, we do a few things:
//
// 1. Prevent default on `touchmove` events that are not in a scrollable element. This prevents touch scrolling
//    on the window.
// 2. Prevent default on `touchmove` events inside a scrollable element when the scroll position is at the
//    top or bottom. This avoids the whole page scrolling instead, but does prevent overscrolling.
// 3. Prevent default on `touchend` events on input elements and handle focusing the element ourselves.
// 4. When focusing an input, apply a transform to trick Safari into thinking the input is at the top
//    of the page, which prevents it from scrolling the page. After the input is focused, scroll the element
//    into view ourselves, without scrolling the whole page.
// 5. Offset the body by the scroll position using a negative margin and scroll to the top. This should appear the
//    same visually, but makes the actual scroll position always zero. This is required to make all of the
//    above work or Safari will still try to scroll the page when focusing an input.
// 6. As a last resort, handle window scroll events, and scroll back to the top. This can happen when attempting
//    to navigate to an input with the next/previous buttons that's outside a modal.


function $ece0076f06e8a828c60ba0c94f22f89$var$preventScrollMobileSafari() {
  let scrollable;
  let lastY = 0;

  let onTouchStart = e => {
    // Store the nearest scrollable parent element from the element that the user touched.
    scrollable = getScrollParent(e.target);

    if (scrollable === document.documentElement && scrollable === document.body) {
      return;
    }

    lastY = e.changedTouches[0].pageY;
  };

  let onTouchMove = e => {
    // Prevent scrolling the window.
    if (scrollable === document.documentElement || scrollable === document.body) {
      e.preventDefault();
      return;
    } // Prevent scrolling up when at the top and scrolling down when at the bottom
    // of a nested scrollable area, otherwise mobile Safari will start scrolling
    // the window instead. Unfortunately, this disables bounce scrolling when at
    // the top but it's the best we can do.


    let y = e.changedTouches[0].pageY;
    let scrollTop = scrollable.scrollTop;
    let bottom = scrollable.scrollHeight - scrollable.clientHeight;

    if (scrollTop <= 0 && y > lastY || scrollTop >= bottom && y < lastY) {
      e.preventDefault();
    }

    lastY = y;
  };

  let onTouchEnd = e => {
    let target = e.target;

    if (target instanceof HTMLInputElement && !$ece0076f06e8a828c60ba0c94f22f89$var$nonTextInputTypes.has(target.type)) {
      e.preventDefault(); // Apply a transform to trick Safari into thinking the input is at the top of the page
      // so it doesn't try to scroll it into view. When tapping on an input, this needs to
      // be done before the "focus" event, so we have to focus the element ourselves.

      target.style.transform = 'translateY(-2000px)';
      target.focus();
      requestAnimationFrame(() => {
        target.style.transform = '';
      });
    }
  };

  let onFocus = e => {
    let target = e.target;

    if (target instanceof HTMLInputElement && !$ece0076f06e8a828c60ba0c94f22f89$var$nonTextInputTypes.has(target.type)) {
      // Transform also needs to be applied in the focus event in cases where focus moves
      // software keyboard. In these cases, it seems applying the transform in the focus event
      // is good enough, whereas when tapping an input, it must be done before the focus event. 🤷‍♂️
      target.style.transform = 'translateY(-2000px)';
      requestAnimationFrame(() => {
        target.style.transform = ''; // This will have prevented the browser from scrolling the focused element into view,
        // so we need to do this ourselves in a way that doesn't cause the whole page to scroll.

        if ($ece0076f06e8a828c60ba0c94f22f89$var$visualViewport) {
          if ($ece0076f06e8a828c60ba0c94f22f89$var$visualViewport.height < window.innerHeight) {
            // If the keyboard is already visible, do this after one additional frame
            // to wait for the transform to be removed.
            requestAnimationFrame(() => {
              $ece0076f06e8a828c60ba0c94f22f89$var$scrollIntoView(target);
            });
          } else {
            // Otherwise, wait for the visual viewport to resize before scrolling so we can
            // measure the correct position to scroll to.
            $ece0076f06e8a828c60ba0c94f22f89$var$visualViewport.addEventListener('resize', () => $ece0076f06e8a828c60ba0c94f22f89$var$scrollIntoView(target), {
              once: true
            });
          }
        }
      });
    }
  };

  let onWindowScroll = () => {
    // Last resort. If the window scrolled, scroll it back to the top.
    // It should always be at the top because the body will have a negative margin (see below).
    window.scrollTo(0, 0);
  }; // Record the original scroll position so we can restore it.
  // Then apply a negative margin to the body to offset it by the scroll position. This will
  // enable us to scroll the window to the top, which is required for the rest of this to work.


  let scrollX = window.pageXOffset;
  let scrollY = window.pageYOffset;
  let restoreStyles = chain($ece0076f06e8a828c60ba0c94f22f89$var$setStyle(document.documentElement, 'paddingRight', window.innerWidth - document.documentElement.clientWidth + "px"), $ece0076f06e8a828c60ba0c94f22f89$var$setStyle(document.documentElement, 'overflow', 'hidden'), $ece0076f06e8a828c60ba0c94f22f89$var$setStyle(document.body, 'marginTop', "-" + scrollY + "px")); // Scroll to the top. The negative margin on the body will make this appear the same.

  window.scrollTo(0, 0);
  let removeEvents = chain($ece0076f06e8a828c60ba0c94f22f89$var$addEvent(document, 'touchstart', onTouchStart, {
    passive: false,
    capture: true
  }), $ece0076f06e8a828c60ba0c94f22f89$var$addEvent(document, 'touchmove', onTouchMove, {
    passive: false,
    capture: true
  }), $ece0076f06e8a828c60ba0c94f22f89$var$addEvent(document, 'touchend', onTouchEnd, {
    passive: false,
    capture: true
  }), $ece0076f06e8a828c60ba0c94f22f89$var$addEvent(document, 'focus', onFocus, true), $ece0076f06e8a828c60ba0c94f22f89$var$addEvent(window, 'scroll', onWindowScroll));
  return () => {
    // Restore styles and scroll the page back to where it was.
    restoreStyles();
    removeEvents();
    window.scrollTo(scrollX, scrollY);
  };
} // Sets a CSS property on an element, and returns a function to revert it to the previous value.


function $ece0076f06e8a828c60ba0c94f22f89$var$setStyle(element, style, value) {
  let cur = element.style[style];
  element.style[style] = value;
  return () => {
    element.style[style] = cur;
  };
} // Adds an event listener to an element, and returns a function to remove it.


function $ece0076f06e8a828c60ba0c94f22f89$var$addEvent(target, event, handler, options) {
  target.addEventListener(event, handler, options);
  return () => {
    target.removeEventListener(event, handler, options);
  };
}

function $ece0076f06e8a828c60ba0c94f22f89$var$scrollIntoView(target) {
  // Find the parent scrollable element and adjust the scroll position if the target is not already in view.
  let scrollable = getScrollParent(target);

  if (scrollable !== document.documentElement && scrollable !== document.body) {
    let scrollableTop = scrollable.getBoundingClientRect().top;
    let targetTop = target.getBoundingClientRect().top;

    if (targetTop > scrollableTop + target.clientHeight) {
      scrollable.scrollTop += targetTop - scrollableTop;
    }
  }
}

const $b876e5ac9c98db373bf726bce3d604e$var$Context = /*#__PURE__*/_react__default.createContext(null);
/**
 * Each ModalProvider tracks how many modals are open in its subtree. On mount, the modals
 * trigger `addModal` to increment the count, and trigger `removeModal` on unmount to decrement it.
 * This is done recursively so that all parent providers are incremented and decremented.
 * If the modal count is greater than zero, we add `aria-hidden` to this provider to hide its
 * subtree from screen readers. This is done using React context in order to account for things
 * like portals, which can cause the React tree and the DOM tree to differ significantly in structure.
 */


function ModalProvider(props) {
  let {
    children
  } = props;
  let parent = useContext($b876e5ac9c98db373bf726bce3d604e$var$Context);
  let [modalCount, setModalCount] = useState(0);
  let context = useMemo(() => ({
    parent,
    modalCount,

    addModal() {
      setModalCount(count => count + 1);

      if (parent) {
        parent.addModal();
      }
    },

    removeModal() {
      setModalCount(count => count - 1);

      if (parent) {
        parent.removeModal();
      }
    }

  }), [parent, modalCount]);
  return /*#__PURE__*/_react__default.createElement($b876e5ac9c98db373bf726bce3d604e$var$Context.Provider, {
    value: context
  }, children);
}

/**
 * Used to determine if the tree should be aria-hidden based on how many
 * modals are open.
 */
function useModalProvider() {
  let context = useContext($b876e5ac9c98db373bf726bce3d604e$var$Context);
  return {
    modalProviderProps: {
      'aria-hidden': context && context.modalCount > 0 ? true : null
    }
  };
}
/**
 * Creates a root node that will be aria-hidden if there are other modals open.
 */

function $b876e5ac9c98db373bf726bce3d604e$var$OverlayContainerDOM(props) {
  let {
    modalProviderProps
  } = useModalProvider();
  return /*#__PURE__*/_react__default.createElement("div", _extends({
    "data-overlay-container": true
  }, props, modalProviderProps));
}
/**
 * An OverlayProvider acts as a container for the top-level application.
 * Any application that uses modal dialogs or other overlays should
 * be wrapped in a `<OverlayProvider>`. This is used to ensure that
 * the main content of the application is hidden from screen readers
 * if a modal or other overlay is opened. Only the top-most modal or
 * overlay should be accessible at once.
 */


function OverlayProvider(props) {
  return /*#__PURE__*/_react__default.createElement(ModalProvider, null, /*#__PURE__*/_react__default.createElement($b876e5ac9c98db373bf726bce3d604e$var$OverlayContainerDOM, props));
}

/**
 * Hides content outside the current `<OverlayContainer>` from screen readers
 * on mount and restores it on unmount. Typically used by modal dialogs and
 * other types of overlays to ensure that only the top-most modal is
 * accessible at once.
 */
function useModal(options) {
  // Add aria-hidden to all parent providers on mount, and restore on unmount.
  let context = useContext($b876e5ac9c98db373bf726bce3d604e$var$Context);

  if (!context) {
    throw new Error('Modal is not contained within a provider');
  }

  useEffect(() => {
    if (options != null && options.isDisabled || !context || !context.parent) {
      return;
    } // The immediate context is from the provider containing this modal, so we only
    // want to trigger aria-hidden on its parents not on the modal provider itself.


    context.parent.addModal();
    return () => {
      if (context && context.parent) {
        context.parent.removeModal();
      }
    };
  }, [context, context.parent, options == null ? void 0 : options.isDisabled]);
  return {
    modalProps: {
      'data-ismodal': !(options != null && options.isDisabled)
    }
  };
}
// ASSET: /Users/govett/dev/react-spectrum-v3/packages/@react-aria/overlays/intl/ar-AE.json
var $e325a364098e05bf51160d06dcffdbe$exports = {};
$e325a364098e05bf51160d06dcffdbe$exports = JSON.parse("{\"dismiss\":\"تجاهل\"}");
// ASSET: /Users/govett/dev/react-spectrum-v3/packages/@react-aria/overlays/intl/bg-BG.json
var $ab088cc547d59c1be83369f8351a064$exports = {};
$ab088cc547d59c1be83369f8351a064$exports = JSON.parse("{\"dismiss\":\"Отхвърляне\"}");
// ASSET: /Users/govett/dev/react-spectrum-v3/packages/@react-aria/overlays/intl/cs-CZ.json
var $cec67ea16ca47059e10ca5e77187d8c2$exports = {};
$cec67ea16ca47059e10ca5e77187d8c2$exports = JSON.parse("{\"dismiss\":\"Odstranit\"}");
// ASSET: /Users/govett/dev/react-spectrum-v3/packages/@react-aria/overlays/intl/da-DK.json
var $d962fe1ed718c5ca37da1414136036f8$exports = {};
$d962fe1ed718c5ca37da1414136036f8$exports = JSON.parse("{\"dismiss\":\"Luk\"}");
// ASSET: /Users/govett/dev/react-spectrum-v3/packages/@react-aria/overlays/intl/de-DE.json
var $c5167dda40dde69038848f007e5$exports = {};
$c5167dda40dde69038848f007e5$exports = JSON.parse("{\"dismiss\":\"Schließen\"}");
// ASSET: /Users/govett/dev/react-spectrum-v3/packages/@react-aria/overlays/intl/el-GR.json
var $ecdd1ac0020e47f58a9ed51b5fb$exports = {};
$ecdd1ac0020e47f58a9ed51b5fb$exports = JSON.parse("{\"dismiss\":\"Απόρριψη\"}");
// ASSET: /Users/govett/dev/react-spectrum-v3/packages/@react-aria/overlays/intl/en-US.json
var $f33e30a89f4dff807f90ebe8c$exports = {};
$f33e30a89f4dff807f90ebe8c$exports = JSON.parse("{\"dismiss\":\"Dismiss\"}");
// ASSET: /Users/govett/dev/react-spectrum-v3/packages/@react-aria/overlays/intl/es-ES.json
var $ba353e2c61dcc5141af4537eeb3ef85c$exports = {};
$ba353e2c61dcc5141af4537eeb3ef85c$exports = JSON.parse("{\"dismiss\":\"Descartar\"}");
// ASSET: /Users/govett/dev/react-spectrum-v3/packages/@react-aria/overlays/intl/et-EE.json
var $dd3e8aaecbf1f2c2c0f9d51aacfd$exports = {};
$dd3e8aaecbf1f2c2c0f9d51aacfd$exports = JSON.parse("{\"dismiss\":\"Lõpeta\"}");
// ASSET: /Users/govett/dev/react-spectrum-v3/packages/@react-aria/overlays/intl/fi-FI.json
var $f730aaed9f4652842b2a8f94a4a$exports = {};
$f730aaed9f4652842b2a8f94a4a$exports = JSON.parse("{\"dismiss\":\"Hylkää\"}");
// ASSET: /Users/govett/dev/react-spectrum-v3/packages/@react-aria/overlays/intl/fr-FR.json
var $e76b22aab4e46b7806205b4af9ca3$exports = {};
$e76b22aab4e46b7806205b4af9ca3$exports = JSON.parse("{\"dismiss\":\"Rejeter\"}");
// ASSET: /Users/govett/dev/react-spectrum-v3/packages/@react-aria/overlays/intl/he-IL.json
var $c33ffdd5a9931bfc82c1c9b55e98de2f$exports = {};
$c33ffdd5a9931bfc82c1c9b55e98de2f$exports = JSON.parse("{\"dismiss\":\"התעלם\"}");
// ASSET: /Users/govett/dev/react-spectrum-v3/packages/@react-aria/overlays/intl/hr-HR.json
var $d64cb70d4ce170f599f4df5adf4e9898$exports = {};
$d64cb70d4ce170f599f4df5adf4e9898$exports = JSON.parse("{\"dismiss\":\"Odbaci\"}");
// ASSET: /Users/govett/dev/react-spectrum-v3/packages/@react-aria/overlays/intl/hu-HU.json
var $c05270a6513a8b6d8a6552a35a162$exports = {};
$c05270a6513a8b6d8a6552a35a162$exports = JSON.parse("{\"dismiss\":\"Elutasítás\"}");
// ASSET: /Users/govett/dev/react-spectrum-v3/packages/@react-aria/overlays/intl/it-IT.json
var $df915df637af1f3c14c8376c69dfd$exports = {};
$df915df637af1f3c14c8376c69dfd$exports = JSON.parse("{\"dismiss\":\"Ignora\"}");
// ASSET: /Users/govett/dev/react-spectrum-v3/packages/@react-aria/overlays/intl/ja-JP.json
var $e8bf1e6480d2c65d558c3537ec0d59ce$exports = {};
$e8bf1e6480d2c65d558c3537ec0d59ce$exports = JSON.parse("{\"dismiss\":\"閉じる\"}");
// ASSET: /Users/govett/dev/react-spectrum-v3/packages/@react-aria/overlays/intl/ko-KR.json
var $e06e93e1c9472a7e2fc5b26a87ea7$exports = {};
$e06e93e1c9472a7e2fc5b26a87ea7$exports = JSON.parse("{\"dismiss\":\"무시\"}");
// ASSET: /Users/govett/dev/react-spectrum-v3/packages/@react-aria/overlays/intl/lt-LT.json
var $fef82498418eab30c69349263b64e050$exports = {};
$fef82498418eab30c69349263b64e050$exports = JSON.parse("{\"dismiss\":\"Atmesti\"}");
// ASSET: /Users/govett/dev/react-spectrum-v3/packages/@react-aria/overlays/intl/lv-LV.json
var $c4df2502cb7b65c6578bcb8a165f6fc$exports = {};
$c4df2502cb7b65c6578bcb8a165f6fc$exports = JSON.parse("{\"dismiss\":\"Nerādīt\"}");
// ASSET: /Users/govett/dev/react-spectrum-v3/packages/@react-aria/overlays/intl/nb-NO.json
var $b50f4e499c19f4d55113139bba$exports = {};
$b50f4e499c19f4d55113139bba$exports = JSON.parse("{\"dismiss\":\"Lukk\"}");
// ASSET: /Users/govett/dev/react-spectrum-v3/packages/@react-aria/overlays/intl/nl-NL.json
var $e45d2f0079f29e4f5c6469cca7c$exports = {};
$e45d2f0079f29e4f5c6469cca7c$exports = JSON.parse("{\"dismiss\":\"Negeren\"}");
// ASSET: /Users/govett/dev/react-spectrum-v3/packages/@react-aria/overlays/intl/pl-PL.json
var $fcb5bfa87b2378a249bd7fb591ec22c2$exports = {};
$fcb5bfa87b2378a249bd7fb591ec22c2$exports = JSON.parse("{\"dismiss\":\"Zignoruj\"}");
// ASSET: /Users/govett/dev/react-spectrum-v3/packages/@react-aria/overlays/intl/pt-BR.json
var $edae5c6f18c937cf0015f2aa266d9fea$exports = {};
$edae5c6f18c937cf0015f2aa266d9fea$exports = JSON.parse("{\"dismiss\":\"Descartar\"}");
// ASSET: /Users/govett/dev/react-spectrum-v3/packages/@react-aria/overlays/intl/pt-PT.json
var $c016edcd88f37a017208da7518133d$exports = {};
$c016edcd88f37a017208da7518133d$exports = JSON.parse("{\"dismiss\":\"Dispensar\"}");
// ASSET: /Users/govett/dev/react-spectrum-v3/packages/@react-aria/overlays/intl/ro-RO.json
var $df1162b231d383d942e0fdb2bbf$exports = {};
$df1162b231d383d942e0fdb2bbf$exports = JSON.parse("{\"dismiss\":\"Revocare\"}");
// ASSET: /Users/govett/dev/react-spectrum-v3/packages/@react-aria/overlays/intl/ru-RU.json
var $fa17537bfd201c57fa41fd31dbd9f074$exports = {};
$fa17537bfd201c57fa41fd31dbd9f074$exports = JSON.parse("{\"dismiss\":\"Пропустить\"}");
// ASSET: /Users/govett/dev/react-spectrum-v3/packages/@react-aria/overlays/intl/sk-SK.json
var $c30db5bcff54a9e266ee7379a6cb8$exports = {};
$c30db5bcff54a9e266ee7379a6cb8$exports = JSON.parse("{\"dismiss\":\"Zrušiť\"}");
// ASSET: /Users/govett/dev/react-spectrum-v3/packages/@react-aria/overlays/intl/sl-SI.json
var $c86d8cad7c0045ad51a1fea185411a61$exports = {};
$c86d8cad7c0045ad51a1fea185411a61$exports = JSON.parse("{\"dismiss\":\"Opusti\"}");
// ASSET: /Users/govett/dev/react-spectrum-v3/packages/@react-aria/overlays/intl/sr-SP.json
var $c610b0b50ebc0061e6c42c420a2e1be$exports = {};
$c610b0b50ebc0061e6c42c420a2e1be$exports = JSON.parse("{\"dismiss\":\"Odbaci\"}");
// ASSET: /Users/govett/dev/react-spectrum-v3/packages/@react-aria/overlays/intl/sv-SE.json
var $c298c5c92c55ce8d8289d8cc18ea512$exports = {};
$c298c5c92c55ce8d8289d8cc18ea512$exports = JSON.parse("{\"dismiss\":\"Avvisa\"}");
// ASSET: /Users/govett/dev/react-spectrum-v3/packages/@react-aria/overlays/intl/tr-TR.json
var $f438196d9674b9d180ea6e74d7$exports = {};
$f438196d9674b9d180ea6e74d7$exports = JSON.parse("{\"dismiss\":\"Kapat\"}");
// ASSET: /Users/govett/dev/react-spectrum-v3/packages/@react-aria/overlays/intl/uk-UA.json
var $fa842ebaf07187d5bc74e0fa6c4679b$exports = {};
$fa842ebaf07187d5bc74e0fa6c4679b$exports = JSON.parse("{\"dismiss\":\"Скасувати\"}");
// ASSET: /Users/govett/dev/react-spectrum-v3/packages/@react-aria/overlays/intl/zh-CN.json
var $cdcbe39f22ae1814551e7f30dcfc8$exports = {};
$cdcbe39f22ae1814551e7f30dcfc8$exports = JSON.parse("{\"dismiss\":\"取消\"}");
// ASSET: /Users/govett/dev/react-spectrum-v3/packages/@react-aria/overlays/intl/zh-TW.json
var $a8c729d90cde82a4eb34bebfb46a6$exports = {};
$a8c729d90cde82a4eb34bebfb46a6$exports = JSON.parse("{\"dismiss\":\"關閉\"}");

/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */
// @ts-ignore
({
  "ar-AE": _interopRequireDefault($e325a364098e05bf51160d06dcffdbe$exports).default,
  "bg-BG": _interopRequireDefault($ab088cc547d59c1be83369f8351a064$exports).default,
  "cs-CZ": _interopRequireDefault($cec67ea16ca47059e10ca5e77187d8c2$exports).default,
  "da-DK": _interopRequireDefault($d962fe1ed718c5ca37da1414136036f8$exports).default,
  "de-DE": _interopRequireDefault($c5167dda40dde69038848f007e5$exports).default,
  "el-GR": _interopRequireDefault($ecdd1ac0020e47f58a9ed51b5fb$exports).default,
  "en-US": _interopRequireDefault($f33e30a89f4dff807f90ebe8c$exports).default,
  "es-ES": _interopRequireDefault($ba353e2c61dcc5141af4537eeb3ef85c$exports).default,
  "et-EE": _interopRequireDefault($dd3e8aaecbf1f2c2c0f9d51aacfd$exports).default,
  "fi-FI": _interopRequireDefault($f730aaed9f4652842b2a8f94a4a$exports).default,
  "fr-FR": _interopRequireDefault($e76b22aab4e46b7806205b4af9ca3$exports).default,
  "he-IL": _interopRequireDefault($c33ffdd5a9931bfc82c1c9b55e98de2f$exports).default,
  "hr-HR": _interopRequireDefault($d64cb70d4ce170f599f4df5adf4e9898$exports).default,
  "hu-HU": _interopRequireDefault($c05270a6513a8b6d8a6552a35a162$exports).default,
  "it-IT": _interopRequireDefault($df915df637af1f3c14c8376c69dfd$exports).default,
  "ja-JP": _interopRequireDefault($e8bf1e6480d2c65d558c3537ec0d59ce$exports).default,
  "ko-KR": _interopRequireDefault($e06e93e1c9472a7e2fc5b26a87ea7$exports).default,
  "lt-LT": _interopRequireDefault($fef82498418eab30c69349263b64e050$exports).default,
  "lv-LV": _interopRequireDefault($c4df2502cb7b65c6578bcb8a165f6fc$exports).default,
  "nb-NO": _interopRequireDefault($b50f4e499c19f4d55113139bba$exports).default,
  "nl-NL": _interopRequireDefault($e45d2f0079f29e4f5c6469cca7c$exports).default,
  "pl-PL": _interopRequireDefault($fcb5bfa87b2378a249bd7fb591ec22c2$exports).default,
  "pt-BR": _interopRequireDefault($edae5c6f18c937cf0015f2aa266d9fea$exports).default,
  "pt-PT": _interopRequireDefault($c016edcd88f37a017208da7518133d$exports).default,
  "ro-RO": _interopRequireDefault($df1162b231d383d942e0fdb2bbf$exports).default,
  "ru-RU": _interopRequireDefault($fa17537bfd201c57fa41fd31dbd9f074$exports).default,
  "sk-SK": _interopRequireDefault($c30db5bcff54a9e266ee7379a6cb8$exports).default,
  "sl-SI": _interopRequireDefault($c86d8cad7c0045ad51a1fea185411a61$exports).default,
  "sr-SP": _interopRequireDefault($c610b0b50ebc0061e6c42c420a2e1be$exports).default,
  "sv-SE": _interopRequireDefault($c298c5c92c55ce8d8289d8cc18ea512$exports).default,
  "tr-TR": _interopRequireDefault($f438196d9674b9d180ea6e74d7$exports).default,
  "uk-UA": _interopRequireDefault($fa842ebaf07187d5bc74e0fa6c4679b$exports).default,
  "zh-CN": _interopRequireDefault($cdcbe39f22ae1814551e7f30dcfc8$exports).default,
  "zh-TW": _interopRequireDefault($a8c729d90cde82a4eb34bebfb46a6$exports).default
});

const getContainerDimensions = containerNode => {
  var _a, _b;

  const scroll = {};
  const visualViewport = typeof window !== 'undefined' && window.visualViewport;
  let dimensions = {};

  if (containerNode.tagName === 'BODY') {
    dimensions.width = (_a = visualViewport === null || visualViewport === void 0 ? void 0 : visualViewport.width) !== null && _a !== void 0 ? _a : typeof document !== 'undefined' ? document.documentElement.clientWidth : 0;
    dimensions.height = (_b = visualViewport === null || visualViewport === void 0 ? void 0 : visualViewport.height) !== null && _b !== void 0 ? _b : typeof document !== 'undefined' ? document.documentElement.clientHeight : 0;
    scroll.top = _domHelpersQueryScrollTop(_domHelpersOwnerDocument(containerNode).documentElement) || _domHelpersQueryScrollTop(containerNode);
    scroll.left = _domHelpersQueryScrollLeft(_domHelpersOwnerDocument(containerNode).documentElement) || _domHelpersQueryScrollLeft(containerNode);
  } else {
    dimensions = _domHelpersQueryOffset(containerNode);
    scroll.top = _domHelpersQueryScrollTop(containerNode);
    scroll.left = _domHelpersQueryScrollLeft(containerNode);
  }

  return { ...dimensions,
    scroll
  };
};

function useOverlayPosition({
  matchTriggerWidth,
  ...props
}) {
  var _a;

  const [triggerWidth] = useSize(props.targetRef);
  const {
    overlayProps,
    placement = 'bottom',
    updatePosition,
    arrowProps
  } = useOverlayPosition$1(props);
  const style = Object.assign({}, arrowProps.style, {
    fontSize: 16,
    lineHeight: 0
  });
  let arrowIcon = 'caret-up';

  switch (placement) {
    case 'bottom':
      style.top = -10;
      style.marginLeft = -5;
      break;

    case 'top':
      style.bottom = -10;
      style.marginLeft = -5;
      arrowIcon = 'caret-down';
      break;

    case 'left':
      style.right = -6;
      style.marginTop = -8;
      arrowIcon = 'caret-right';
      break;

    case 'right':
      style.left = -5;
      style.marginTop = -8;
      arrowIcon = 'caret-left';
      break;

    default:
      console.warn("Hey, you're using an invalid placement prop! Check out the docs for appropriate usage, or remove it.");
  }

  arrowProps.style = style;
  const overlayStyle = overlayProps.style || {};

  if (matchTriggerWidth) {
    overlayStyle.width = triggerWidth;
  }

  if (props.shouldFlip && props.offset) {
    // invert axis to get correct CSS property
    const axisMap = {
      top: 'bottom',
      bottom: 'top'
    };
    const axis = axisMap[placement];
    let disableOffset = false;

    if (!props.placement.includes(placement)) {
      // direction is flipped, disable main axis offset
      disableOffset = true;
    } else if ((_a = props.targetRef.current) === null || _a === void 0 ? void 0 : _a.nodeType) {
      const boundaryElement = props.boundaryElement || (typeof document !== 'undefined' ? document.body : null);
      const boundaryDimensions = getContainerDimensions(boundaryElement);
      const triggerDimensions = getContainerDimensions(props.targetRef.current);
      const overlayTopPost = triggerDimensions.top + props.offset;

      if (boundaryDimensions.scroll.top >= overlayTopPost) {
        disableOffset = true;
      }
    }

    if (disableOffset && typeof overlayStyle[axis] === 'number') {
      overlayStyle[axis] -= props.offset;
    }
  }

  overlayProps.style = overlayStyle;
  return {
    overlayProps,
    placement,
    updatePosition,
    arrowProps,
    arrowIcon: ['fas', arrowIcon]
  };
}

const THEME_STORAGE_KEY = 'mosaic-theme';
const DEFAULT_THEME_MODE = 'light';
/**
 * For SSR
 */

const memoryDb = {};
const memoryStorage = {
  getItem: name => memoryDb[name],
  setItem: (name, value) => {
    memoryDb[name] = value;
  }
};

const defaultMode = () => {
  if (typeof localStorage === 'undefined') return DEFAULT_THEME_MODE;

  try {
    return JSON.parse(localStorage.getItem(THEME_STORAGE_KEY)).mode;
  } catch (_a) {}

  const dataTheme = document.documentElement.getAttribute('data-theme');
  if (dataTheme) return dataTheme;
  return DEFAULT_THEME_MODE;
};

const useThemeStore = create(persist(set => ({
  mode: defaultMode(),
  theme: {
    colors: {}
  },
  // default is light theme
  colorValues: {
    light: true
  },
  invertedColorValues: {
    light: false
  },
  setMode: mode => {
    const preferDark = prefersDarkMode();

    if (typeof document !== 'undefined') {
      let _mode = mode;

      if (mode === 'system') {
        _mode = preferDark ? 'dark' : 'light';
      }

      document.documentElement.setAttribute('data-theme', _mode);
    }

    set(state => ({ ...state,
      mode
    }));
  },
  setColor: (name, val) => set(state => {
    // if would result in no change, return
    if (defaultTheme.colors[name] === val || state.theme.colors[name] === val) return; // allow setting by hex or rgb val

    let hslObj;

    if (typeof val === 'string') {
      const x = parseToHsl(val);
      hslObj = {
        h: Math.round(x.hue),
        s: Math.round(x.saturation * 100),
        l: Math.round(x.lightness * 100)
      };
    } else {
      hslObj = val;
    }

    const hslString = stringifyHsl(hslObj); // if new val equals the default val, delete it so that it's removed from localStorage
    // this way if we update default theme in the future, the user will get the new values

    if (defaultTheme.colors[name] === hslString) {
      delete state.theme.colors[name];
      return;
    }

    return {
      theme: { ...state.theme,
        colors: { ...state.theme.colors,
          [name]: hslString
        }
      }
    };
  }),
  reset: () => set({
    theme: {
      colors: {}
    }
  }),
  setColorValues: cv => set({
    colorValues: cv
  }),
  setInvertedColorValues: cv => set({
    invertedColorValues: cv
  })
}), {
  name: THEME_STORAGE_KEY,
  version: 0,
  getStorage: () => typeof localStorage === 'undefined' ? memoryStorage : localStorage,
  // only remember the desired mode
  serialize: ({
    state,
    version
  }) => JSON.stringify({
    mode: state.mode,
    version
  }),
  deserialize: value => ({
    version: 0
    /* default */
    ,
    ...JSON.parse(value)
  })
}));

/**
 * Pass a lodash style property path to pluck a specific theme property out. This helps with performance
 * if theme is being updated, since calling component will only re-render when the particular theme value
 * that is subscribed to changes.
 */

const useTheme = property => {
  const themeValue = useThemeStore(state => _get(cjs(defaultTheme, state.theme), property));
  const setColor = useThemeStore(state => state.setColor);
  const reset = useThemeStore(state => state.reset);
  return {
    themeValue,
    setColor,
    reset
  };
};

const InvertThemeContext = /*#__PURE__*/_react.createContext({});
const InvertTheme = ({
  children,
  inverted
}) => {
  const {
    inverted: parentInverted
  } = useContext(InvertThemeContext);
  let _inverted = undefined;

  if (inverted !== false) {
    _inverted = parentInverted !== void 0 ? !parentInverted : true;
  }

  const _className = cn(children.props.className, {
    'sl-inverted': inverted === false ? undefined : true
  });

  return jsx(InvertThemeContext.Provider, Object.assign({
    value: {
      inverted: _inverted
    }
  }, {
    children: /*#__PURE__*/_react.cloneElement(children, {
      className: _className || undefined
    })
  }), void 0);
};

const useThemeIsDark = () => {
  const {
    inverted
  } = useContext(InvertThemeContext);
  const [isLightBg, isLightInvertedBg] = useThemeStore(s => [s.colorValues.light, s.invertedColorValues.light], shallow);

  if (inverted) {
    return !isLightInvertedBg;
  }

  return !isLightBg;
};

const useThemeIsInverted = () => {
  const {
    inverted
  } = useContext(InvertThemeContext);
  return inverted;
};

const useThemeMode = () => {
  const mode = useThemeStore(state => state.mode);
  const setMode = useThemeStore(state => state.setMode);
  return {
    mode,
    setMode
  };
};

function CopyButton({
  copyValue,
  ...props
}, ref) {
  const {
    hasCopied,
    onCopy
  } = useClipboard(copyValue);
  return jsx(_Button, Object.assign({
    appearance: "minimal",
    size: "sm",
    onPress: onCopy,
    icon: hasCopied ? undefined : 'copy',
    label: "Copy"
  }, props, {
    // @ts-expect-error
    ref: ref
  }, {
    children: hasCopied ? 'Copied' : null
  }), void 0);
}

const _CopyButton = /*#__PURE__*/forwardRef(CopyButton);

function FieldButton({
  children,
  placeholder,
  onClear,
  appearance = 'minimal',
  intent,
  active,
  loading,
  disabled,
  ...props
}, ref) {
  var _a, _b;

  const showClearButton = !!(onClear && children);
  const stateProps = { ...fieldButtonVariants.minimal.default,
    ...fieldButtonVariants.minimal[intent],
    ...((_a = fieldButtonVariants[appearance]) === null || _a === void 0 ? void 0 : _a.default),
    ...((_b = fieldButtonVariants[appearance]) === null || _b === void 0 ? void 0 : _b[intent])
  };
  let disabledProps = null;

  if (disabled) {
    disabledProps = {
      cursor: 'not-allowed'
    };

    if (appearance === 'outlined') {
      disabledProps.bg = 'canvas-100';
    }
  }
  /**
   * If active, remove other state effects
   */


  if (active) {
    for (const i in stateProps) {
      const prop = stateProps[i];

      if (prop && typeof prop === 'object') {
        if (prop.hasOwnProperty('active')) {
          stateProps[i] = prop.active;
        } else if (prop.hasOwnProperty('hover')) {
          // remove props immutably
          const {
            hover,
            ...newProps
          } = stateProps[i];
          stateProps[i] = newProps;
        }
      }
    }
  }
  /**
   * If in loading or disabled states, remove other ui effects like hover
   */


  if (loading || disabled) {
    for (const i in stateProps) {
      const prop = stateProps[i];

      if (prop && typeof prop === 'object') {
        // remove props immutably
        const {
          active,
          hover,
          ...newProps
        } = stateProps[i];
        stateProps[i] = newProps;
      }
    }
  }

  return jsxs(Box, Object.assign({
    pos: "relative"
  }, disabledProps, {
    children: [jsx(_Button, Object.assign({
      iconRight: jsx(Box, Object.assign({
        pt: 0.5,
        pr: 0.5
      }, {
        children: jsx(Icon, {
          icon: "chevron-down",
          size: "xs"
        }, void 0)
      }), void 0),
      noFocusRing: true,
      active: active,
      loading: loading,
      disabled: disabled
    }, props, stateProps, {
      ref: ref
    }, {
      children: jsxs(Flex, Object.assign({
        flex: 1,
        justifyItems: "start",
        alignItems: "center"
      }, {
        children: [jsx(Box, Object.assign({
          pr: 1,
          color: isNil(children) ? 'light' : undefined
        }, {
          children: isNil(children) ? placeholder : /*#__PURE__*/_react.isValidElement(children) ? children : String(children)
        }), void 0), showClearButton && jsx("div", {
          style: {
            width: props.size === 'sm' ? 24 : 28
          }
        }, void 0)]
      }), void 0)
    }), void 0), showClearButton && jsx(FieldButtonClear, {
      triggerRef: ref,
      onClear: onClear,
      size: props.size
    }, void 0)]
  }), void 0);
}

const _FieldButton = /*#__PURE__*/forwardRef(FieldButton);

const FieldButtonClear = ({
  triggerRef,
  size,
  onClear
}) => {
  const {
    pressProps
  } = usePress({
    onPress: () => {
      var _a;

      onClear(); // move focus back to the field button

      (_a = triggerRef === null || triggerRef === void 0 ? void 0 : triggerRef.current) === null || _a === void 0 ? void 0 : _a.focus();
    }
  });
  return jsx(FocusRing, Object.assign({
    focusRingClass: "sl-focus-ring"
  }, {
    children: jsx(Flex, Object.assign({
      as: "button"
    }, pressProps, {
      borderR: true,
      borderColor: "input",
      fontSize: "base",
      px: size === 'sm' ? 1.5 : 2,
      alignItems: "center",
      color: {
        hover: 'danger',
        focus: 'danger'
      },
      pos: "absolute",
      cursor: "pointer",
      style: {
        top: '50%',
        right: size === 'sm' ? 20 : 24,
        height: 13,
        marginTop: -6,
        lineHeight: 0
      },
      "aria-label": "Clear selected value"
    }, {
      children: jsx(Icon, {
        icon: "times",
        size: "xs"
      }, void 0)
    }), void 0)
  }), void 0);
};

const sizes$6 = {
  1: {
    as: 'h1',
    fontSize: '5xl',
    fontWeight: 'bold',
    lineHeight: 'tight'
  },
  2: {
    as: 'h2',
    fontSize: '4xl',
    fontWeight: 'bold',
    lineHeight: 'tight'
  },
  3: {
    as: 'h3',
    fontSize: '2xl',
    fontWeight: 'semibold',
    lineHeight: 'snug'
  },
  4: {
    as: 'h4',
    fontSize: 'paragraph',
    fontWeight: 'semibold',
    lineHeight: 'snug'
  }
};
const Heading = /*#__PURE__*/memo(function Heading({
  size,
  ...props
}) {
  return jsx(Box, Object.assign({
    fontFamily: "prose",
    fontWeight: "bold",
    color: "heading"
  }, sizes$6[size], props), void 0);
});

const defaultElement$6 = 'div';
const directionToFlex = {
  vertical: 'col',
  horizontal: 'row'
};
const Stack = /*#__PURE__*/memo( /*#__PURE__*/forwardRef(({
  className,
  spacing,
  direction = 'vertical',
  divider,
  children,
  ...restProps
}, ref) => {
  const hasDivider = !!divider;

  const _className = cn('sl-stack', {
    [`sl-stack--${direction}`]: spacing !== void 0,
    [`sl-stack--${spacing}`]: spacing !== void 0
  }, className);

  let clones = children;
  const childrenWithoutNulls = _react.Children.toArray(children).filter(Boolean);

  if (childrenWithoutNulls && hasDivider) {
    const childCount = childrenWithoutNulls.length;
    clones = _react.Children.map(childrenWithoutNulls, (child, index) => {
      const isLast = index + 1 === childCount;
      const clonedDivider = typeof divider === 'boolean' ? jsx(Box, {
        borderT: direction === 'vertical' ? true : undefined,
        borderL: direction === 'horizontal' ? true : undefined,
        alignSelf: "stretch"
      }, "d") : /*#__PURE__*/_react.cloneElement(divider, {
        key: 'd'
      });

      const _divider = isLast ? null : clonedDivider;

      return jsx(_react.Fragment, {
        children: [child, _divider]
      }, index);
    });
  }

  return jsx(Flex, Object.assign({
    as: defaultElement$6,
    ref: ref,
    className: _className,
    direction: directionToFlex[direction]
  }, restProps, {
    children: clones
  }), void 0);
}));
const HStack = /*#__PURE__*/forwardRef((props, ref) => {
  return jsx(Stack, Object.assign({
    align: "center"
  }, props, {
    ref: ref,
    direction: "horizontal"
  }), void 0);
});
const VStack = /*#__PURE__*/forwardRef((props, ref) => {
  return jsx(Stack, Object.assign({
    align: "stretch"
  }, props, {
    ref: ref,
    direction: "vertical"
  }), void 0);
});

const iconVariants$1 = {
  intent: {
    default: 'info-circle',
    success: 'check-circle',
    warning: 'exclamation-circle',
    danger: 'exclamation-circle'
  }
};
const variants$4 = {
  default: {
    default: {
      border: 2,
      borderColor: 'transparent',
      rounded: 'lg',
      bg: {
        default: 'primary-tint'
      }
    },
    success: {
      bg: {
        default: 'success-tint'
      }
    },
    warning: {
      bg: {
        default: 'warning-tint'
      }
    },
    danger: {
      bg: {
        default: 'danger-tint'
      }
    }
  },
  outline: {
    default: {
      border: 2,
      rounded: 'xl',
      borderColor: 'primary'
    },
    success: {
      borderColor: 'success'
    },
    warning: {
      borderColor: 'warning'
    },
    danger: {
      borderColor: 'danger'
    }
  }
};

const Callout = /*#__PURE__*/memo(function Callout({
  intent = 'default',
  appearance = 'default',
  heading,
  className,
  icon,
  actions,
  children,
  ...props
}) {
  const color = intent === 'default' || intent === 'info' ? 'primary' : intent;
  const {
    themeValue: value
  } = useTheme(`colors.${color}`);
  const stateProps = { ...variants$4[appearance].default,
    ...variants$4[appearance][intent]
  };
  return jsx(Box, Object.assign({
    className: cn('sl-callout', className),
    rounded: "xl",
    w: "full",
    pb: appearance === 'default' ? undefined : 1,
    bg: appearance === 'default' ? undefined : stateProps.borderColor,
    role: "alert"
  }, props, {
    children: jsxs(HStack, Object.assign({
      spacing: 3,
      pl: 4,
      pr: actions ? 4 : 10,
      py: 4,
      alignItems: "start",
      rounded: "xl",
      bg: appearance === 'default' ? undefined : 'canvas-pure'
    }, stateProps, {
      children: [icon !== null ? jsx(Box, Object.assign({
        mt: "px"
      }, {
        children: jsx(HeadingIcon, {
          icon: icon,
          intent: intent,
          intentColorValue: value
        }, void 0)
      }), void 0) : null, jsxs(VStack, Object.assign({
        flex: 1
      }, {
        children: [heading ? jsx(Heading, Object.assign({
          size: 4,
          mb: 1.5
        }, {
          children: heading
        }), void 0) : null, children]
      }), void 0), actions]
    }), void 0)
  }), void 0);
});

const HeadingIcon = ({
  icon,
  intent,
  intentColorValue
}) => {
  let elem = null;

  if (intent && !icon) {
    const intentIcon = iconVariants$1.intent[intent];

    if (intentIcon) {
      elem = jsx(Icon, {
        icon: intentIcon,
        style: {
          color: intentColorValue
        },
        size: "lg"
      }, void 0);
    }
  } else if (icon && isIconProp(icon)) {
    elem = jsx(Icon, {
      icon: icon,
      style: {
        color: intentColorValue
      },
      size: "lg"
    }, void 0);
  }

  return elem ? jsx(Box, Object.assign({
    "data-testid": "icon"
  }, {
    children: elem
  }), void 0) : null;
};

const Card = ({
  title,
  description,
  logoIcon = faRobot,
  logoIconColor = '#A0AEC0',
  logoBackgroundColor = 'canvas-100',
  actionBar,
  badge,
  isActive = false,
  activeHighlightColor = 'success'
}) => {
  const {
    mode
  } = useThemeMode();
  return jsx(Box, Object.assign({
    w: "full",
    boxShadow: "xl",
    rounded: "lg",
    display: "inline-block",
    cursor: "pointer"
  }, {
    children: jsxs(Box, Object.assign({
      border: 2,
      borderColor: {
        default: isActive ? activeHighlightColor : 'transparent'
      },
      m: -0.5,
      rounded: "lg",
      overflowX: "hidden",
      overflowY: "hidden"
    }, {
      children: [jsxs(Flex, Object.assign({
        bg: logoBackgroundColor,
        pos: "relative",
        alignItems: "center",
        justifyContent: "center",
        h: 24
      }, {
        children: [jsx(Box, Object.assign({
          pos: "absolute",
          right: 0,
          top: 0,
          textAlign: "right",
          px: 2,
          py: 1,
          color: "success"
        }, {
          children: badge
        }), void 0), jsx(Icon, {
          icon: logoIcon,
          color: logoIconColor,
          size: "3x"
        }, void 0)]
      }), void 0), jsxs(Box, Object.assign({
        style: {
          backgroundColor: mode === 'dark' ? 'var(--color-canvas-50)' : 'var(--color-canvas)'
        },
        bg: "canvas",
        border: 0,
        borderColor: "transparent",
        p: 4
      }, {
        children: [jsx(Text, Object.assign({
          fontSize: "base",
          color: "body",
          fontWeight: "semibold"
        }, {
          children: title
        }), void 0), jsx(Text, Object.assign({
          fontSize: "sm",
          color: "muted",
          overflowX: "hidden",
          overflowY: "hidden",
          style: {
            display: '-webkit-box',
            WebkitLineClamp: 2,
            WebkitBoxOrient: 'vertical'
          }
        }, {
          children: description
        }), void 0)]
      }), void 0), actionBar && jsx(Box, Object.assign({
        bg: "canvas",
        w: "full",
        overflowY: "hidden",
        overflowX: "hidden",
        borderT: true
      }, {
        children: actionBar
      }), void 0)]
    }), void 0)
  }), void 0);
};

function Code({
  className,
  ...props
}) {
  return jsx(Box, Object.assign({
    as: "code",
    className: cn(className),
    fontWeight: "medium",
    fontFamily: "mono",
    bg: "code",
    color: "on-code",
    border: true,
    py: 0.5,
    px: 1,
    mx: 0.5,
    rounded: true,
    style: {
      fontSize: '0.8125em'
    }
  }, props), void 0);
}

const Divider$2 = props => {
  return jsx("div", Object.assign({}, props), void 0);
};

const sizes$5 = {
  lg: {
    avatarSize: 'md',
    fontSize: 'lg'
  },
  md: {
    avatarSize: 'sm'
  }
};
const EntityName = /*#__PURE__*/memo( /*#__PURE__*/forwardRef(function EntityName(props, ref) {
  const {
    className,
    name,
    isHeading,
    size = 'md',
    avatar,
    ...rest
  } = props;
  let leftElem;

  if (isIconEntityName(props)) {
    leftElem = jsx(Box, Object.assign({
      mx: "auto"
    }, {
      children: jsx(Icon, {
        icon: props.icon
      }, void 0)
    }), void 0);
  } else if (isAvatarEntityName(props)) {
    leftElem = jsx(Avatar, Object.assign({
      size: sizes$5[size].avatarSize,
      mx: "auto"
    }, avatar), void 0);
  }

  return jsxs(Flex, Object.assign({}, rest, {
    ref: ref,
    align: "center",
    className: cn('sl-entity-name', className)
  }, {
    children: [leftElem ? jsx(Box, Object.assign({
      w: 12,
      ml: -3
    }, {
      children: leftElem
    }), void 0) : null, jsx(Text, Object.assign({
      fontWeight: isHeading ? 'semibold' : 'normal',
      size: sizes$5[size].fontSize
    }, {
      children: name
    }), void 0)]
  }), void 0);
}));

function isIconEntityName(props) {
  return props.icon !== undefined;
}

function isAvatarEntityName(props) {
  return props.avatar !== undefined;
}

const Grid = props => {
  return jsx("div", Object.assign({}, props), void 0);
};

const defaultElement$5 = 'img';
function Image({
  className,
  invertOnDark,
  ...props
}) {
  const {
    componentOverrides: {
      Image: ImageOverride
    }
  } = useMosaicContext();
  const isDark = useThemeIsDark();
  return jsx(Box, Object.assign({
    as: ImageOverride || defaultElement$5,
    className: cn('sl-image', className, {
      'sl-image--inverted': invertOnDark && isDark
    })
  }, props), void 0);
}

/**
 * Provides the behavior and accessibility implementation for a dialog component.
 * A dialog is an overlay shown above other content in an application.
 */
function useDialog(props, ref) {
  let {
    role = 'dialog'
  } = props;
  let titleId = useSlotId();
  titleId = props['aria-label'] ? undefined : titleId; // Focus the dialog itself on mount, unless a child element is already focused.

  useEffect(() => {
    if (ref.current && !ref.current.contains(document.activeElement)) {
      focusSafely(ref.current); // Safari on iOS does not move the VoiceOver cursor to the dialog
      // or announce that it has opened until it has rendered. A workaround
      // is to wait for half a second, then blur and re-focus the dialog.

      let timeout = setTimeout(() => {
        if (document.activeElement === ref.current) {
          ref.current.blur();
          focusSafely(ref.current);
        }
      }, 500);
      return () => {
        clearTimeout(timeout);
      };
    }
  }, [ref]); // We do not use aria-modal due to a Safari bug which forces the first focusable element to be focused
  // on mount when inside an iframe, no matter which element we programmatically focus.
  // See https://bugs.webkit.org/show_bug.cgi?id=211934.
  // useModal sets aria-hidden on all elements outside the dialog, so the dialog will behave as a modal
  // even without aria-modal on the dialog itself.

  return {
    dialogProps: _extends({}, filterDOMProps(props, {
      labelable: true
    }), {
      role,
      tabIndex: -1,
      'aria-labelledby': props['aria-labelledby'] || titleId
    }),
    titleProps: {
      id: titleId
    }
  };
}

/**
 * Manages state for an overlay trigger. Tracks whether the overlay is open, and provides
 * methods to toggle this state.
 */
function useOverlayTriggerState(props) {
  let [isOpen, setOpen] = useControlledState(props.isOpen, props.defaultOpen || false, props.onOpenChange);
  return {
    isOpen,

    open() {
      setOpen(true);
    },

    close() {
      setOpen(false);
    },

    toggle() {
      setOpen(!isOpen);
    }

  };
}

const styles = {
  border: 0,
  clip: 'rect(0 0 0 0)',
  height: 1,
  margin: '-1px',
  overflow: 'hidden',
  padding: 0,
  position: 'absolute',
  width: 1,
  whiteSpace: 'nowrap'
};
/**
 * Provides props for an element that hides its children visually
 * but keeps content visible to assistive technology.
 */

function useVisuallyHidden(props = {}) {
  let {
    style,
    isFocusable
  } = props;
  let [isFocused, setFocused] = _react.useState(false);
  let {
    focusProps
  } = useFocus({
    isDisabled: !isFocusable,
    onFocusChange: setFocused
  }); // If focused, don't hide the element.

  let combinedStyles = _react.useMemo(() => {
    if (isFocused) {
      return style;
    } else if (style) {
      return { ...styles,
        ...style
      };
    } else {
      return styles;
    }
  }, [isFocused, style]);
  return {
    visuallyHiddenProps: { ...focusProps,
      style: combinedStyles
    }
  };
}
/**
 * VisuallyHidden hides its children visually, while keeping content visible
 * to screen readers.
 */

function VisuallyHidden(props) {
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  let {
    children,
    elementType: Element = 'div',
    isFocusable,
    style,
    ...otherProps
  } = props;
  let {
    visuallyHiddenProps
  } = useVisuallyHidden(props);
  return jsx(Element, Object.assign({}, mergeProps(otherProps, visuallyHiddenProps), {
    children: children
  }), void 0);
}

/**
 * A visually hidden button that can be used to allow screen reader
 * users to dismiss a modal or popup when there is no visual
 * affordance to do so.
 */

function DismissButton(props) {
  let {
    onDismiss
  } = props;

  let onClick = () => {
    if (onDismiss) {
      onDismiss();
    }
  };

  return jsx(VisuallyHidden, {
    children: jsx("button", {
      tabIndex: -1,
      "aria-label": "Dismiss",
      onClick: onClick
    }, void 0)
  }, void 0);
}

function Overlay(props, ref) {
  let {
    children,
    isOpen,
    container
  } = props;
  const {
    providerRef
  } = useMosaicContext();
  let mountOverlay = isOpen;

  if (!mountOverlay || typeof window === 'undefined') {
    // Don't bother showing anything if we don't have to.
    return null;
  }

  let contents = jsx(WithDomRef, Object.assign({
    ref: ref
  }, {
    children: jsx(Box, Object.assign({
      bg: "transparent"
    }, {
      children: children
    }), void 0)
  }), void 0);

  const portalContainer = container || (providerRef === null || providerRef === void 0 ? void 0 : providerRef.current) || document.body;
  return /*#__PURE__*/_reactDom.createPortal(contents, portalContainer);
}

let _Overlay = /*#__PURE__*/_react.forwardRef(Overlay);

const modalSizeVariants = {
  sm: {
    width: '100%',
    maxWidth: 400
  },
  md: {
    width: '100%',
    maxWidth: 600
  },
  lg: {
    width: '100%',
    maxWidth: 900
  },
  full: {
    width: '100%',
    maxWidth: '90%'
  },
  grow: {
    maxWidth: '90%'
  }
};
const useModalState = () => {
  const state = useOverlayTriggerState({});
  return {
    isOpen: state.isOpen,
    open: state.open,
    close: state.close
  };
};
const Modal = props => {
  const {
    children,
    footer,
    isOpen,
    onClose,
    isDraggable,
    isNotDismissable,
    ...rest
  } = props;
  return jsx(_Overlay, Object.assign({
    isOpen: isOpen
  }, {
    children: jsx(ModalWrapper, Object.assign({}, rest, {
      footer: footer,
      isOpen: isOpen,
      onClose: onClose,
      isDraggable: isDraggable,
      isNotDismissable: isNotDismissable
    }, {
      children: children
    }), void 0)
  }), void 0);
};

function isElementAllowedToBeInteractedOutside(element) {
  const popoverParent = element.closest('[data-ispopover="true"]');
  return !!popoverParent;
} // returns implementation of shouldCloseOnInteractOutside for making sure that clicking elements outside the modal
// but triggered by modal itself (like select, menu) will not close the modal
// see https://github.com/stoplightio/mosaic/issues/303 for details


function preventClosingForShortTime() {
  let shouldPrevent = false;
  return function shouldCloseOnInteractionOutside(element) {
    if (isElementAllowedToBeInteractedOutside(element)) {
      shouldPrevent = true;
      setTimeout(() => {
        shouldPrevent = false;
      }, 400);
      return false;
    } else if (shouldPrevent) {
      return false;
    }

    return true;
  };
}

const ModalWrapper = ({
  children,
  footer,
  isOpen,
  onClose,
  isDraggable,
  isNotDismissable,
  ...props
}) => {
  const ref = useRef();
  const preventClosingFunction = _react.useMemo(preventClosingForShortTime, [isOpen]); // Handle interacting outside the dialog and pressing
  // the Escape key to close the modal.

  const {
    overlayProps
  } = useOverlay({
    onClose,
    isOpen,
    isDismissable: !isDraggable && !isNotDismissable,
    shouldCloseOnInteractOutside: preventClosingFunction
  }, ref); // Hide content outside the modal from screen readers.

  const {
    modalProps
  } = useModal(); // Get props for the dialog

  const {
    dialogProps,
    titleProps
  } = useDialog({}, ref); // TODO: having to pull out color for the typings is so annoying...

  const {
    color,
    ...containerProps
  } = mergeProps(overlayProps, modalProps);
  const {
    color: c2,
    ...dialogPropsWithoutColor
  } = dialogProps;
  const {
    color: c3,
    ...dialogTitlePropsWithoutColor
  } = titleProps;

  if (isDraggable) {
    return jsx(DraggableModalBox, Object.assign({}, props, {
      ref: ref,
      onClose: onClose,
      containerProps: containerProps,
      dialogProps: dialogPropsWithoutColor,
      titleProps: dialogTitlePropsWithoutColor,
      footer: footer,
      isNotDismissable: isNotDismissable
    }, {
      children: children
    }), void 0);
  }

  return jsx(StaticModalBox, Object.assign({}, props, {
    ref: ref,
    onClose: onClose,
    containerProps: containerProps,
    dialogProps: dialogPropsWithoutColor,
    titleProps: dialogTitlePropsWithoutColor,
    footer: footer,
    isNotDismissable: isNotDismissable
  }, {
    children: children
  }), void 0);
};

const ModalBox = /*#__PURE__*/forwardRef(({
  isDraggable,
  moveProps = {},
  containerProps,
  dialogProps,
  titleProps,
  onClose,
  children,
  footer,
  position,
  isHidden,
  isNotDismissable,
  size = 'md',
  ...props
}, ref) => {
  const isDark = useThemeIsDark();
  const style = Object.assign({}, modalSizeVariants[size] || {});

  if (position) {
    style.position = 'fixed';
    style.top = position.y;
    style.left = position.x;
  }

  if (size === 'full') {
    style.height = '100%';
    style.maxHeight = '90%';
  }

  let headerElem;

  if ('renderHeader' in props && props.renderHeader) {
    headerElem = props.renderHeader({
      containerProps: moveProps,
      titleProps,
      onClose
    });
  } else if ('title' in props && props.title) {
    headerElem = jsxs(Flex, Object.assign({}, moveProps, {
      borderB: true,
      borderColor: isDark ? 'input' : undefined,
      alignItems: "center",
      pl: 5,
      pr: 3,
      cursor: !!position ? 'move' : undefined,
      h: "3xl"
    }, {
      children: [typeof props.title === 'string' ? jsx(Heading, Object.assign({
        size: 3,
        fontSize: "xl",
        flex: 1,
        fontWeight: "medium"
      }, titleProps, {
        children: props.title
      }), void 0) : jsx(Box, Object.assign({}, titleProps, {
        flex: 1,
        as: "header"
      }, {
        children: props.title
      }), void 0), !isNotDismissable && jsx(_Button, {
        appearance: "minimal",
        icon: jsx(Icon, {
          icon: "times",
          size: "2x"
        }, void 0),
        onPress: onClose,
        "aria-label": "dismiss"
      }, void 0)]
    }), void 0);
  }

  let footerElem;

  if (footer) {
    footerElem = jsx(Box, Object.assign({
      borderT: true,
      borderColor: isDark ? 'input' : undefined,
      alignItems: "center",
      pl: 5,
      pr: 3,
      py: 3
    }, {
      children: footer
    }), void 0);
  }

  return jsx(Box, Object.assign({}, containerProps, {
    bg: "canvas-dialog",
    boxShadow: "lg",
    rounded: "lg",
    pos: "relative",
    zIndex: 20,
    style: style,
    visibility: isHidden ? 'invisible' : undefined
  }, {
    children: jsx(FocusScope, Object.assign({
      restoreFocus: !isDraggable,
      contain: !isDraggable
    }, {
      children: jsxs(Flex, Object.assign({}, dialogProps, {
        ref: ref,
        "aria-describedby": `${dialogProps['aria-labelledby']}-body`,
        "aria-modal": "true",
        "data-testid": "modal",
        h: size === 'full' ? 'full' : undefined,
        flexDirection: "col"
      }, {
        children: [headerElem, jsx(ModalContent, Object.assign({
          id: `${dialogProps['aria-labelledby']}-body`,
          p: headerElem || footerElem ? 5 : undefined,
          h: size === 'full' ? 'full' : undefined,
          overflowY: size === 'full' ? 'auto' : undefined
        }, {
          children: children
        }), void 0), footerElem]
      }), void 0)
    }), void 0)
  }), void 0);
});
/**
 * Memo modal content so that it does not re-render constantly in draggable modals
 */

const ModalContent = /*#__PURE__*/memo(({
  children,
  id,
  p,
  h,
  overflowY
}) => {
  return jsx(Box, Object.assign({
    p: p,
    id: id,
    h: h,
    overflowY: overflowY
  }, {
    children: children
  }), void 0);
});
const StaticModalBox = /*#__PURE__*/forwardRef((props, ref) => {
  // Prevent scrolling while the modal is open
  usePreventScroll();
  return jsxs(Flex, Object.assign({
    pos: "fixed",
    alignItems: "center",
    justifyContent: "center",
    zIndex: 40,
    pin: true,
    overflowY: "auto"
  }, {
    children: [jsx(Underlay, {}, void 0), jsx(ModalBox, Object.assign({}, props, {
      ref: ref
    }), void 0)]
  }), void 0);
});
const DraggableModalBox = /*#__PURE__*/forwardRef((props, ref) => {
  const [position, setPosition] = _react.useState({
    x: 0,
    y: 0
  }); // get the width of the button trigger so that we can set the menu min width

  const [modalWidth, modalHeight] = useSize(ref);
  const [windowWidth, windowHeight] = useWindowSize();
  _react.useEffect(() => {
    if (modalWidth && windowWidth) {
      const y = windowHeight / 2 - modalHeight / 2;
      setPosition({
        x: windowWidth / 2 - modalWidth / 2,
        y: y - y * 0.7
      });
    }
  }, [modalWidth, windowWidth, setPosition, windowHeight, modalHeight]);

  const clamp = (pos, containerSize, componentSize) => Math.min(Math.max(pos, 0), containerSize - componentSize);

  const {
    moveProps
  } = useMove({
    onMove(e) {
      setPosition(({
        x,
        y
      }) => {
        // Normally, we want to allow the user to continue
        // dragging outside the box such that they need to
        // drag back over the ball again before it moves.
        // This is handled below by clamping during render.
        // If using the keyboard, however, we need to clamp
        // here so that dragging outside the container and
        // then using the arrow keys works as expected.
        if (e.pointerType === 'keyboard') {
          // eslint-disable-next-line no-param-reassign
          x = clamp(x, windowWidth, modalWidth); // eslint-disable-next-line no-param-reassign

          y = clamp(y, windowHeight, modalHeight);
        } // eslint-disable-next-line no-param-reassign


        x += e.deltaX; // eslint-disable-next-line no-param-reassign

        y += e.deltaY;
        return {
          x: clamp(x, windowWidth + modalWidth * 0.5, modalWidth),
          y: clamp(y, windowHeight + 50, modalHeight)
        };
      });
    }

  });
  return jsx(ModalBox, Object.assign({}, props, {
    moveProps: moveProps,
    position: position,
    ref: ref,
    isHidden: !modalWidth
  }), void 0);
});

const Underlay = () => {
  return jsx(Box, {
    pos: "fixed",
    zIndex: 10,
    pin: true,
    style: {
      backgroundColor: 'rgba(0, 0 , 0, .3)'
    }
  }, void 0);
};

function ProductImage({
  className,
  children,
  focus,
  caption,
  bg = 'success',
  ...props
}) {
  var _a, _b, _c, _d;

  const {
    isOpen,
    open,
    close
  } = useModalState(); // enforce single child

  const child = _react.Children.only(children);
  const focusContainerProps = ((_a = FocusVariants[focus]) === null || _a === void 0 ? void 0 : _a.container) || {};
  const focusAspectProps = ((_b = FocusVariants[focus]) === null || _b === void 0 ? void 0 : _b.aspect) || {};
  const focusImageProps = ((_c = FocusVariants[focus]) === null || _c === void 0 ? void 0 : _c.image) || {};
  const focusCaptionProps = ((_d = FocusVariants[focus]) === null || _d === void 0 ? void 0 : _d.caption) || {};
  const imageElem = /*#__PURE__*/_react.cloneElement(child, {
    bg: 'canvas-pure',
    borderColor: 'body',
    overflowX: 'hidden',
    overflowY: 'hidden',
    mx: 'auto',
    ...focusImageProps,
    style: Object.assign(focusImageProps.style || {}, child.props.style || {})
  });
  let elem = imageElem;

  if (focusAspectProps.ratio) {
    elem = jsx(AspectRatio, Object.assign({
      mx: "auto",
      ratio: 1
    }, focusAspectProps, {
      children: imageElem
    }), void 0);
  }

  const resolvedCaption = caption || child.props.title;
  let captionElem;

  if (resolvedCaption) {
    if (focus) {
      captionElem = jsx(Box, Object.assign({
        as: "figcaption",
        display: "block",
        style: {
          color: 'white'
        },
        pb: 8,
        mt: -8,
        mx: "auto",
        px: 20,
        fontWeight: "semibold",
        fontSize: "paragraph",
        textAlign: "center"
      }, focusCaptionProps, {
        children: resolvedCaption
      }), void 0);
    } else {
      captionElem = jsx(Box, Object.assign({
        as: "figcaption"
      }, {
        children: resolvedCaption
      }), void 0);
    }
  }

  return jsxs(Fragment, {
    children: [jsx(Pressable, Object.assign({
      onPress: open
    }, {
      children: jsxs(Box, Object.assign({
        as: "figure"
      }, {
        children: [jsxs(Box, Object.assign({
          className: cn('sl-product-image', className),
          border: 2,
          borderColor: "body",
          rounded: "xl",
          bg: focus ? bg : undefined,
          overflowX: "hidden",
          overflowY: "hidden",
          transform: true,
          cursor: "zoom-in",
          transitionDuration: 300,
          translateX: {
            hover: 2
          },
          translateY: {
            hover: -2
          },
          style: {
            '--shadow-md': '-8px 8px 0 0 var(--color-text)'
          },
          boxShadow: {
            hover: true
          }
        }, props, focusContainerProps, {
          children: [focus && focus !== 'bottom' ? captionElem : null, elem, focus && focus === 'bottom' ? captionElem : null]
        }), void 0), !focus ? captionElem : null]
      }), void 0)
    }), void 0), jsx(Modal, Object.assign({
      isOpen: isOpen,
      onClose: close,
      size: "grow"
    }, {
      children: jsx(Box, Object.assign({
        as: Pressable,
        onPress: close,
        cursor: "zoom-out",
        overflowX: "hidden",
        overflowY: "hidden",
        rounded: "lg"
      }, {
        children: jsx(Box, {
          children: /*#__PURE__*/_react.cloneElement(child, {
            style: Object.assign({
              maxHeight: 800
            }, child.props.style || {})
          })
        }, void 0)
      }), void 0)
    }), void 0)]
  }, void 0);
}
const FocusVariants = {
  center: {
    container: {
      p: 16
    },
    image: {
      border: 2,
      rounded: 'xl',
      boxShadow: 'lg',
      style: {
        maxHeight: 500
      }
    }
  },
  bottom: {
    container: {
      pb: 16
    },
    aspect: {
      ratio: 16 / 9,
      mx: 16
    },
    image: {
      borderB: 2,
      borderL: 2,
      borderR: 2,
      rounded: 'b-lg',
      objectFit: 'scale-down',
      objectPosition: 'bottom'
    },
    caption: {
      pb: 0,
      mt: 0,
      pt: 8,
      mb: -8
    }
  },
  top: {
    container: {
      pt: 16
    },
    aspect: {
      ratio: 16 / 9,
      mx: 16
    },
    image: {
      borderT: 2,
      borderL: 2,
      borderR: 2,
      rounded: 't-lg',
      objectFit: 'scale-down',
      objectPosition: 'top'
    }
  },
  'top-right': {
    container: {
      pt: 16
    },
    aspect: {
      ratio: 16 / 9,
      mr: 16
    },
    image: {
      borderT: 2,
      borderR: 2,
      rounded: 'tr-lg',
      objectFit: 'scale-down',
      objectPosition: 'left-top'
    }
  },
  'top-left': {
    container: {
      pt: 16
    },
    aspect: {
      ratio: 16 / 9,
      ml: 16
    },
    image: {
      borderT: 2,
      borderL: 2,
      rounded: 'tl-lg',
      objectFit: 'scale-down',
      objectPosition: 'right-top'
    }
  }
};

/**
 * Provides the accessibility implementation for labels and their associated elements.
 * Labels provide context for user inputs.
 * @param props - The props for labels and fields.
 */
function useLabel(props) {
  let {
    id,
    label,
    'aria-labelledby': ariaLabelledby,
    'aria-label': ariaLabel,
    labelElementType = 'label'
  } = props;
  id = useId(id);
  let labelId = useId();
  let labelProps = {};

  if (label) {
    ariaLabelledby = ariaLabelledby ? ariaLabelledby + " " + labelId : labelId;
    labelProps = {
      id: labelId,
      htmlFor: labelElementType === 'label' ? id : undefined
    };
  } else if (!ariaLabelledby && !ariaLabel) {
    console.warn('If you do not provide a visible label, you must specify an aria-label or aria-labelledby attribute for accessibility');
  }

  let fieldProps = useLabels({
    id,
    'aria-label': ariaLabel,
    'aria-labelledby': ariaLabelledby
  });
  return {
    labelProps,
    fieldProps
  };
}

/**
 * Provides the behavior and accessibility implementation for a text field.
 * @param props - Props for the text field.
 * @param ref - Ref to the HTML input or textarea element.
 */
function useTextField(props, ref) {
  let {
    inputElementType = 'input',
    isDisabled = false,
    isRequired = false,
    isReadOnly = false,
    validationState,
    type = 'text',
    onChange: _onChange = () => {}
  } = props;
  let {
    focusableProps
  } = useFocusable(props, ref);
  let {
    labelProps,
    fieldProps
  } = useLabel(props);
  let domProps = filterDOMProps(props, {
    labelable: true
  });
  const inputOnlyProps = {
    type,
    pattern: props.pattern
  };
  return {
    labelProps,
    inputProps: mergeProps(domProps, inputElementType === 'input' && inputOnlyProps, _extends({
      disabled: isDisabled,
      readOnly: isReadOnly,
      'aria-required': isRequired || undefined,
      'aria-invalid': validationState === 'invalid' || undefined,
      'aria-errormessage': props['aria-errormessage'],
      'aria-activedescendant': props['aria-activedescendant'],
      'aria-autocomplete': props['aria-autocomplete'],
      'aria-haspopup': props['aria-haspopup'],
      value: props.value,
      defaultValue: props.value ? undefined : props.defaultValue,
      onChange: e => _onChange(e.target.value),
      autoComplete: props.autoComplete,
      maxLength: props.maxLength,
      minLength: props.minLength,
      name: props.name,
      placeholder: props.placeholder,
      inputMode: props.inputMode,
      // Clipboard events
      onCopy: props.onCopy,
      onCut: props.onCut,
      onPaste: props.onPaste,
      // Composition events
      onCompositionEnd: props.onCompositionEnd,
      onCompositionStart: props.onCompositionStart,
      onCompositionUpdate: props.onCompositionUpdate,
      // Selection events
      onSelect: props.onSelect,
      // Input events
      onBeforeInput: props.onBeforeInput,
      onInput: props.onInput
    }, focusableProps, fieldProps))
  };
}

const variants$3 = {
  default: {
    default: {
      borderColor: {
        default: 'input',
        // TODO: when have more sophisticated theme val system, slightly darker color on hover as in ui designs
        // hover: 'input',
        focus: 'primary'
      }
    },
    success: {
      borderColor: {
        default: 'success',
        focus: 'success-dark'
      }
    },
    warning: {
      borderColor: {
        default: 'warning',
        focus: 'warning-dark'
      }
    },
    danger: {
      borderColor: {
        default: 'danger',
        focus: 'danger-dark'
      }
    }
  },
  minimal: {
    default: {
      borderColor: {
        default: 'transparent',
        hover: 'input',
        focus: 'primary'
      }
    },
    success: {
      borderColor: {
        default: 'transparent',
        hover: 'success',
        focus: 'success-dark'
      }
    },
    warning: {
      borderColor: {
        default: 'transparent',
        hover: 'warning',
        focus: 'warning-dark'
      }
    },
    danger: {
      borderColor: {
        default: 'transparent',
        hover: 'danger',
        focus: 'danger-dark'
      }
    }
  }
};

const sizes$4 = {
  lg: {
    px: 3
  },
  md: {
    px: 2.5
  },
  sm: {
    px: 1.5
  }
};
const fontSizes$1 = {
  lg: 'lg',
  md: 'base',
  sm: 'base'
};
const Input = /*#__PURE__*/memo( /*#__PURE__*/forwardRef(function Input({
  appearance = 'default',
  intent = 'default',
  size = 'md',
  readOnly,
  disabled,
  className,
  icon,
  required,
  value,
  defaultValue,
  onChange,
  ...props
}, ref) {
  const {
    matchedProps,
    remainingProps
  } = splitBoxProps(props);
  const fallbackRef = useRef();
  const inputRef = ref || fallbackRef;
  const {
    inputProps: {
      color,
      ...inputProps
    }
  } = useTextField({ ...remainingProps,
    value: typeof value !== 'undefined' ? String(value) : value,
    defaultValue: typeof defaultValue !== 'undefined' ? String(defaultValue) : defaultValue,
    onInput: onChange,
    isDisabled: disabled,
    isReadOnly: readOnly,
    isRequired: required
  }, inputRef);
  const stateProps = { ...variants$3.default.default,
    ...variants$3.default[intent],
    ...variants$3[appearance].default,
    ...variants$3[appearance][intent]
  };
  let disabledProps = {};
  let disabledInputProps = {};

  if (disabled) {
    disabledProps = {
      bg: 'canvas-100',
      color: 'muted'
    };
    disabledInputProps = {
      cursor: 'not-allowed'
    };
  }

  let readOnlyProps = {};

  if (readOnly) {
    readOnlyProps.tabIndex = -1;

    if (appearance === 'minimal') {
      readOnlyProps.borderColor = 'transparent';
    }
  }

  return jsxs(Box, Object.assign({
    className: cn('sl-input', className),
    pos: "relative"
  }, matchedProps, disabledProps, {
    children: [icon ? jsx(InputIcon, {
      icon: icon
    }, void 0) : null, jsx(Box, Object.assign({
      as: "input",
      ref: inputRef,
      pl: icon ? 8 : sizes$4[size].px,
      pr: sizes$4[size].px,
      fontSize: fontSizes$1[size],
      rounded: true,
      h: size,
      border: true,
      w: "full",
      disabled: disabled,
      readOnly: readOnly,
      pos: "relative",
      zIndex: 10
    }, disabledInputProps, remainingProps, stateProps, readOnlyProps, inputProps), void 0)]
  }), void 0);
}));

const InputIcon = ({
  icon
}) => {
  let elem = icon;

  if (isIconProp(icon)) {
    elem = jsx(Icon, {
      icon: icon,
      size: "sm",
      fixedWidth: true
    }, void 0);
  }

  return jsx(Flex, Object.assign({
    pos: "absolute",
    align: "center",
    zIndex: 0,
    style: {
      top: 0,
      bottom: 0,
      left: 0,
      lineHeight: 0
    },
    pl: 2
  }, {
    children: elem
  }), void 0);
};

const defaultElement$4 = 'a';
const Link = /*#__PURE__*/memo( /*#__PURE__*/forwardRef(({
  className,
  ...restProps
}, ref) => {
  const {
    componentOverrides: {
      Link: LinkOverride
    }
  } = useMosaicContext();
  return jsx(Box, Object.assign({
    as: LinkOverride || defaultElement$4,
    ref: ref,
    className: cn('sl-link', className)
  }, restProps), void 0);
}));

const LinkHeading = /*#__PURE__*/memo(function LinkHeading({
  id,
  children,
  className,
  ...props
}) {
  const _className = cn('sl-link-heading', className); // Just in case browser doesn't scroll correctly - handle it


  _react.useEffect(() => {
    if (document.location.hash === `#${id}`) {
      const timer = setTimeout(() => {
        document.querySelector(`#${id}`).scrollIntoView({
          behavior: 'smooth',
          block: 'start'
        });
      }, 300);
      return () => clearTimeout(timer);
    } // eslint-disable-next-line react-hooks/exhaustive-deps

  }, []);
  return jsx(Box, Object.assign({
    as: Heading,
    className: _className,
    id: id
  }, props, {
    children: jsx(FocusRing, Object.assign({
      focusRingClass: "sl-focus-ring",
      focusClass: "sl-focus-ring"
    }, {
      children: jsxs(Link, Object.assign({
        href: `#${id}`,
        className: "sl-link-heading__link",
        display: "inline-flex",
        alignItems: "center",
        color: "current"
      }, {
        children: [jsx(Box, {
          children: children
        }, void 0), jsx(Box, Object.assign({
          className: "sl-link-heading__icon",
          ml: 4,
          fontSize: "base",
          color: "muted"
        }, {
          children: jsx(Icon, {
            icon: "link"
          }, void 0)
        }), void 0)]
      }), void 0)
    }), void 0)
  }), void 0);
});

/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */
const $c10674539d06c96e1a2fbb6a54340$var$cache$1 = new WeakMap();
function getItemCount$1(collection) {
  let count = $c10674539d06c96e1a2fbb6a54340$var$cache$1.get(collection);

  if (count != null) {
    return count;
  }

  count = 0;

  for (let item of collection) {
    if (item.type === 'section') {
      count += getItemCount$1(item.childNodes);
    } else {
      count++;
    }
  }

  $c10674539d06c96e1a2fbb6a54340$var$cache$1.set(collection, count);
  return count;
}

/**
 * Handles typeahead interactions with collections.
 */
function useTypeSelect(options) {
  let {
    keyboardDelegate,
    selectionManager,
    onTypeSelect
  } = options;
  let state = useRef({
    search: '',
    timeout: null
  }).current;

  let onKeyDown = e => {
    let character = $c78d7fa5f7d5832f9b4f97b33a679865$var$getStringForKey(e.key);

    if (!character || e.ctrlKey || e.metaKey) {
      return;
    } // Do not propagate the Spacebar event if it's meant to be part of the search.
    // When we time out, the search term becomes empty, hence the check on length.
    // Trimming is to account for the case of pressing the Spacebar more than once,
    // which should cycle through the selection/deselection of the focused item.


    if (character === ' ' && state.search.trim().length > 0) {
      e.preventDefault();

      if (!('continuePropagation' in e)) {
        e.stopPropagation();
      }
    }

    state.search += character; // Use the delegate to find a key to focus.
    // Prioritize items after the currently focused item, falling back to searching the whole list.

    let key = keyboardDelegate.getKeyForSearch(state.search, selectionManager.focusedKey); // If no key found, search from the top.

    if (key == null) {
      key = keyboardDelegate.getKeyForSearch(state.search);
    }

    if (key != null) {
      selectionManager.setFocusedKey(key);

      if (onTypeSelect) {
        onTypeSelect(key);
      }
    }

    clearTimeout(state.timeout);
    state.timeout = setTimeout(() => {
      state.search = '';
    }, 500);
  };

  return {
    typeSelectProps: {
      // Using a capturing listener to catch the keydown event before
      // other hooks in order to handle the Spacebar event.
      onKeyDownCapture: keyboardDelegate.getKeyForSearch ? onKeyDown : null
    }
  };
}

function $c78d7fa5f7d5832f9b4f97b33a679865$var$getStringForKey(key) {
  // If the key is of length 1, it is an ASCII value.
  // Otherwise, if there are no ASCII characters in the key name,
  // it is a Unicode character.
  // See https://www.w3.org/TR/uievents-key/
  if (key.length === 1 || !/^[A-Z]/i.test(key)) {
    return key;
  }

  return '';
}

function $a9b9aa71af07c56ab1d89ca45381f4b$var$isCtrlKeyPressed(e) {
  if (isMac()) {
    return e.metaKey;
  }

  return e.ctrlKey;
}

/**
 * Handles interactions with selectable collections.
 */
function useSelectableCollection(options) {
  let {
    selectionManager: manager,
    keyboardDelegate: delegate,
    ref,
    autoFocus = false,
    shouldFocusWrap = false,
    disallowEmptySelection = false,
    disallowSelectAll = false,
    selectOnFocus = false,
    disallowTypeAhead = false,
    shouldUseVirtualFocus,
    allowsTabNavigation = false
  } = options;
  let {
    direction
  } = useLocale();

  let onKeyDown = e => {
    // Let child element (e.g. menu button) handle the event if the Alt key is pressed.
    // Keyboard events bubble through portals. Don't handle keyboard events
    // for elements outside the collection (e.g. menus).
    if (e.altKey || !ref.current.contains(e.target)) {
      return;
    }

    const navigateToKey = (key, childFocus) => {
      if (key != null) {
        manager.setFocusedKey(key, childFocus);

        if (e.shiftKey && manager.selectionMode === 'multiple') {
          manager.extendSelection(key);
        } else if (selectOnFocus) {
          manager.replaceSelection(key);
        }
      }
    };

    switch (e.key) {
      case 'ArrowDown':
        {
          if (delegate.getKeyBelow) {
            e.preventDefault();
            let nextKey = manager.focusedKey != null ? delegate.getKeyBelow(manager.focusedKey) : delegate.getFirstKey == null ? void 0 : delegate.getFirstKey();

            if (nextKey == null && shouldFocusWrap) {
              nextKey = delegate.getFirstKey == null ? void 0 : delegate.getFirstKey(manager.focusedKey);
            }

            navigateToKey(nextKey);
          }

          break;
        }

      case 'ArrowUp':
        {
          if (delegate.getKeyAbove) {
            e.preventDefault();
            let nextKey = manager.focusedKey != null ? delegate.getKeyAbove(manager.focusedKey) : delegate.getLastKey == null ? void 0 : delegate.getLastKey();

            if (nextKey == null && shouldFocusWrap) {
              nextKey = delegate.getLastKey == null ? void 0 : delegate.getLastKey(manager.focusedKey);
            }

            navigateToKey(nextKey);
          }

          break;
        }

      case 'ArrowLeft':
        {
          if (delegate.getKeyLeftOf) {
            e.preventDefault();
            let nextKey = delegate.getKeyLeftOf(manager.focusedKey);
            navigateToKey(nextKey, direction === 'rtl' ? 'first' : 'last');
          }

          break;
        }

      case 'ArrowRight':
        {
          if (delegate.getKeyRightOf) {
            e.preventDefault();
            let nextKey = delegate.getKeyRightOf(manager.focusedKey);
            navigateToKey(nextKey, direction === 'rtl' ? 'last' : 'first');
          }

          break;
        }

      case 'Home':
        if (delegate.getFirstKey) {
          e.preventDefault();
          let firstKey = delegate.getFirstKey(manager.focusedKey, $a9b9aa71af07c56ab1d89ca45381f4b$var$isCtrlKeyPressed(e));
          manager.setFocusedKey(firstKey);

          if ($a9b9aa71af07c56ab1d89ca45381f4b$var$isCtrlKeyPressed(e) && e.shiftKey && manager.selectionMode === 'multiple') {
            manager.extendSelection(firstKey);
          } else if (selectOnFocus) {
            manager.replaceSelection(firstKey);
          }
        }

        break;

      case 'End':
        if (delegate.getLastKey) {
          e.preventDefault();
          let lastKey = delegate.getLastKey(manager.focusedKey, $a9b9aa71af07c56ab1d89ca45381f4b$var$isCtrlKeyPressed(e));
          manager.setFocusedKey(lastKey);

          if ($a9b9aa71af07c56ab1d89ca45381f4b$var$isCtrlKeyPressed(e) && e.shiftKey && manager.selectionMode === 'multiple') {
            manager.extendSelection(lastKey);
          } else if (selectOnFocus) {
            manager.replaceSelection(lastKey);
          }
        }

        break;

      case 'PageDown':
        if (delegate.getKeyPageBelow) {
          e.preventDefault();
          let nextKey = delegate.getKeyPageBelow(manager.focusedKey);
          navigateToKey(nextKey);
        }

        break;

      case 'PageUp':
        if (delegate.getKeyPageAbove) {
          e.preventDefault();
          let nextKey = delegate.getKeyPageAbove(manager.focusedKey);
          navigateToKey(nextKey);
        }

        break;

      case 'a':
        if ($a9b9aa71af07c56ab1d89ca45381f4b$var$isCtrlKeyPressed(e) && manager.selectionMode === 'multiple' && disallowSelectAll !== true) {
          e.preventDefault();
          manager.selectAll();
        }

        break;

      case 'Escape':
        e.preventDefault();

        if (!disallowEmptySelection) {
          manager.clearSelection();
        }

        break;

      case 'Tab':
        {
          if (!allowsTabNavigation) {
            // There may be elements that are "tabbable" inside a collection (e.g. in a grid cell).
            // However, collections should be treated as a single tab stop, with arrow key navigation internally.
            // We don't control the rendering of these, so we can't override the tabIndex to prevent tabbing.
            // Instead, we handle the Tab key, and move focus manually to the first/last tabbable element
            // in the collection, so that the browser default behavior will apply starting from that element
            // rather than the currently focused one.
            if (e.shiftKey) {
              ref.current.focus();
            } else {
              let walker = getFocusableTreeWalker(ref.current, {
                tabbable: true
              });
              let next;
              let last;

              do {
                last = walker.lastChild();

                if (last) {
                  next = last;
                }
              } while (last);

              if (next && !next.contains(document.activeElement)) {
                focusWithoutScrolling(next);
              }
            }

            break;
          }
        }
    }
  };

  let onFocus = e => {
    if (manager.isFocused) {
      // If a focus event bubbled through a portal, reset focus state.
      if (!e.currentTarget.contains(e.target)) {
        manager.setFocused(false);
      }

      return;
    } // Focus events can bubble through portals. Ignore these events.


    if (!e.currentTarget.contains(e.target)) {
      return;
    }

    manager.setFocused(true);

    if (manager.focusedKey == null) {
      // If the user hasn't yet interacted with the collection, there will be no focusedKey set.
      // Attempt to detect whether the user is tabbing forward or backward into the collection
      // and either focus the first or last item accordingly.
      let relatedTarget = e.relatedTarget;

      if (relatedTarget && e.currentTarget.compareDocumentPosition(relatedTarget) & Node.DOCUMENT_POSITION_FOLLOWING) {
        var _manager$lastSelected;

        manager.setFocusedKey((_manager$lastSelected = manager.lastSelectedKey) != null ? _manager$lastSelected : delegate.getLastKey());
      } else {
        var _manager$firstSelecte;

        manager.setFocusedKey((_manager$firstSelecte = manager.firstSelectedKey) != null ? _manager$firstSelecte : delegate.getFirstKey());
      }
    }
  };

  let onBlur = e => {
    // Don't set blurred and then focused again if moving focus within the collection.
    if (!e.currentTarget.contains(e.relatedTarget)) {
      manager.setFocused(false);
    }
  };

  useEffect(() => {
    if (autoFocus) {
      let focusedKey = null; // Check focus strategy to determine which item to focus

      if (autoFocus === 'first') {
        focusedKey = delegate.getFirstKey();
      }

      if (autoFocus === 'last') {
        focusedKey = delegate.getLastKey();
      } // If there are any selected keys, make the first one the new focus target


      let selectedKeys = manager.selectedKeys;

      if (selectedKeys.size) {
        focusedKey = selectedKeys.values().next().value;
      }

      manager.setFocused(true);
      manager.setFocusedKey(focusedKey); // If no default focus key is selected, focus the collection itself.

      if (focusedKey == null && !shouldUseVirtualFocus) {
        focusSafely(ref.current);
      }
    } // eslint-disable-next-line react-hooks/exhaustive-deps

  }, []);
  let handlers = {
    onKeyDown,
    onFocus,
    onBlur,

    onMouseDown(e) {
      // Ignore events that bubbled through portals.
      if (e.currentTarget.contains(e.target)) {
        // Prevent focus going to the collection when clicking on the scrollbar.
        e.preventDefault();
      }
    }

  };
  let {
    typeSelectProps
  } = useTypeSelect({
    keyboardDelegate: delegate,
    selectionManager: manager
  });

  if (!disallowTypeAhead) {
    handlers = mergeProps(typeSelectProps, handlers);
  } // If nothing is focused within the collection, make the collection itself tabbable.
  // This will be marshalled to either the first or last item depending on where focus came from.
  // If using virtual focus, don't set a tabIndex at all so that VoiceOver on iOS 14 doesn't try
  // to move real DOM focus to the element anyway.


  let tabIndex;

  if (!shouldUseVirtualFocus) {
    tabIndex = manager.focusedKey == null ? 0 : -1;
  }

  return {
    collectionProps: _extends({}, handlers, {
      tabIndex
    })
  };
}

/**
 * Handles interactions with an item in a selectable collection.
 */
function useSelectableItem(options) {
  let {
    selectionManager: manager,
    key,
    ref,
    shouldSelectOnPressUp,
    isVirtualized,
    shouldUseVirtualFocus,
    focus
  } = options;

  let onSelect = e => manager.select(key, e); // Focus the associated DOM node when this item becomes the focusedKey


  let isFocused = key === manager.focusedKey;
  useEffect(() => {
    if (isFocused && manager.isFocused && !shouldUseVirtualFocus && document.activeElement !== ref.current) {
      if (focus) {
        focus();
      } else {
        focusSafely(ref.current);
      }
    }
  }, [ref, isFocused, manager.focusedKey, manager.childFocusStrategy, manager.isFocused, shouldUseVirtualFocus]); // Set tabIndex to 0 if the element is focused, or -1 otherwise so that only the last focused
  // item is tabbable.  If using virtual focus, don't set a tabIndex at all so that VoiceOver
  // on iOS 14 doesn't try to move real DOM focus to the item anyway.

  let itemProps = {};

  if (!shouldUseVirtualFocus) {
    itemProps = {
      tabIndex: isFocused ? 0 : -1,

      onFocus(e) {
        if (e.target === ref.current) {
          manager.setFocusedKey(key);
        }
      }

    };
  } // By default, selection occurs on pointer down. This can be strange if selecting an
  // item causes the UI to disappear immediately (e.g. menus).
  // If shouldSelectOnPressUp is true, we use onPressUp instead of onPressStart.
  // onPress requires a pointer down event on the same element as pointer up. For menus,
  // we want to be able to have the pointer down on the trigger that opens the menu and
  // the pointer up on the menu item rather than requiring a separate press.
  // For keyboard events, selection still occurs on key down.


  if (shouldSelectOnPressUp) {
    itemProps.onPressStart = e => {
      if (e.pointerType === 'keyboard') {
        onSelect(e);
      }
    };

    itemProps.onPressUp = e => {
      if (e.pointerType !== 'keyboard') {
        onSelect(e);
      }
    };
  } else {
    // On touch, it feels strange to select on touch down, so we special case this.
    itemProps.onPressStart = e => {
      if (e.pointerType !== 'touch') {
        onSelect(e);
      }
    };

    itemProps.onPress = e => {
      if (e.pointerType === 'touch') {
        onSelect(e);
      }
    };
  }

  if (!isVirtualized) {
    itemProps['data-key'] = key;
  }

  return {
    itemProps
  };
}

/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */
class ListKeyboardDelegate {
  constructor(collection, disabledKeys, ref, collator) {
    this.collection = void 0;
    this.disabledKeys = void 0;
    this.ref = void 0;
    this.collator = void 0;
    this.collection = collection;
    this.disabledKeys = disabledKeys;
    this.ref = ref;
    this.collator = collator;
  }

  getKeyBelow(key) {
    key = this.collection.getKeyAfter(key);

    while (key != null) {
      let item = this.collection.getItem(key);

      if (item.type === 'item' && !this.disabledKeys.has(key)) {
        return key;
      }

      key = this.collection.getKeyAfter(key);
    }
  }

  getKeyAbove(key) {
    key = this.collection.getKeyBefore(key);

    while (key != null) {
      let item = this.collection.getItem(key);

      if (item.type === 'item' && !this.disabledKeys.has(key)) {
        return key;
      }

      key = this.collection.getKeyBefore(key);
    }
  }

  getFirstKey() {
    let key = this.collection.getFirstKey();

    while (key != null) {
      let item = this.collection.getItem(key);

      if (item.type === 'item' && !this.disabledKeys.has(key)) {
        return key;
      }

      key = this.collection.getKeyAfter(key);
    }
  }

  getLastKey() {
    let key = this.collection.getLastKey();

    while (key != null) {
      let item = this.collection.getItem(key);

      if (item.type === 'item' && !this.disabledKeys.has(key)) {
        return key;
      }

      key = this.collection.getKeyBefore(key);
    }
  }

  getItem(key) {
    return this.ref.current.querySelector("[data-key=\"" + key + "\"]");
  }

  getKeyPageAbove(key) {
    let menu = this.ref.current;
    let item = this.getItem(key);

    if (!item) {
      return null;
    }

    let pageY = Math.max(0, item.offsetTop + item.offsetHeight - menu.offsetHeight);

    while (item && item.offsetTop > pageY) {
      key = this.getKeyAbove(key);
      item = this.getItem(key);
    }

    return key;
  }

  getKeyPageBelow(key) {
    let menu = this.ref.current;
    let item = this.getItem(key);

    if (!item) {
      return null;
    }

    let pageY = Math.min(menu.scrollHeight, item.offsetTop - item.offsetHeight + menu.offsetHeight);

    while (item && item.offsetTop < pageY) {
      key = this.getKeyBelow(key);
      item = this.getItem(key);
    }

    return key;
  }

  getKeyForSearch(search, fromKey) {
    if (!this.collator) {
      return null;
    }

    let collection = this.collection;
    let key = fromKey || this.getFirstKey();

    while (key != null) {
      let item = collection.getItem(key);
      let substring = item.textValue.slice(0, search.length);

      if (item.textValue && this.collator.compare(substring, search) === 0) {
        return key;
      }

      key = this.getKeyBelow(key);
    }

    return null;
  }

}

/**
 * Handles interactions with a selectable list.
 */
function useSelectableList(props) {
  let {
    selectionManager,
    collection,
    disabledKeys,
    ref,
    keyboardDelegate,
    autoFocus,
    shouldFocusWrap,
    isVirtualized,
    disallowEmptySelection,
    selectOnFocus = false,
    disallowTypeAhead,
    shouldUseVirtualFocus,
    allowsTabNavigation
  } = props; // By default, a KeyboardDelegate is provided which uses the DOM to query layout information (e.g. for page up/page down).
  // When virtualized, the layout object will be passed in as a prop and override this.

  let collator = useCollator({
    usage: 'search',
    sensitivity: 'base'
  });
  let delegate = useMemo(() => keyboardDelegate || new ListKeyboardDelegate(collection, disabledKeys, ref, collator), [keyboardDelegate, collection, disabledKeys, ref, collator]); // If not virtualized, scroll the focused element into view when the focusedKey changes.
  // When virtualized, Virtualizer handles this internally.

  useEffect(() => {
    if (!isVirtualized && selectionManager.focusedKey && ref != null && ref.current) {
      let element = ref.current.querySelector("[data-key=\"" + selectionManager.focusedKey + "\"]");

      if (element) {
        $a09ba753e08b703267f2392f7fc8e96$var$scrollIntoView(ref.current, element);
      }
    }
  }, [isVirtualized, ref, selectionManager.focusedKey]);
  let {
    collectionProps
  } = useSelectableCollection({
    ref,
    selectionManager,
    keyboardDelegate: delegate,
    autoFocus,
    shouldFocusWrap,
    disallowEmptySelection,
    selectOnFocus,
    disallowTypeAhead,
    shouldUseVirtualFocus,
    allowsTabNavigation
  });
  return {
    listProps: collectionProps
  };
}
/**
 * Scrolls `scrollView` so that `element` is visible.
 * Similar to `element.scrollIntoView({block: 'nearest'})` (not supported in Edge),
 * but doesn't affect parents above `scrollView`.
 */

function $a09ba753e08b703267f2392f7fc8e96$var$scrollIntoView(scrollView, element) {
  let offsetX = $a09ba753e08b703267f2392f7fc8e96$var$relativeOffset(scrollView, element, 'left');
  let offsetY = $a09ba753e08b703267f2392f7fc8e96$var$relativeOffset(scrollView, element, 'top');
  let width = element.offsetWidth;
  let height = element.offsetHeight;
  let x = scrollView.scrollLeft;
  let y = scrollView.scrollTop;
  let maxX = x + scrollView.offsetWidth;
  let maxY = y + scrollView.offsetHeight;

  if (offsetX <= x) {
    x = offsetX;
  } else if (offsetX + width > maxX) {
    x += offsetX + width - maxX;
  }

  if (offsetY <= y) {
    y = offsetY;
  } else if (offsetY + height > maxY) {
    y += offsetY + height - maxY;
  }

  scrollView.scrollLeft = x;
  scrollView.scrollTop = y;
}
/**
 * Computes the offset left or top from child to ancestor by accumulating
 * offsetLeft or offsetTop through intervening offsetParents.
 */


function $a09ba753e08b703267f2392f7fc8e96$var$relativeOffset(ancestor, child, axis) {
  const prop = axis === 'left' ? 'offsetLeft' : 'offsetTop';
  let sum = 0;

  while (child.offsetParent) {
    sum += child[prop];

    if (child.offsetParent === ancestor) {
      // Stop once we have found the ancestor we are interested in.
      break;
    } else if (child.offsetParent.contains(ancestor)) {
      // If the ancestor is not `position:relative`, then we stop at 
      // _its_ offset parent, and we subtract off _its_ offset, so that
      // we end up with the proper offset from child to ancestor.
      sum -= ancestor[prop];
      break;
    }

    child = child.offsetParent;
  }

  return sum;
}

/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */
const listIds = new WeakMap();

function $d7356e622fdc32e5aea4e1e7cc2e6e6b$var$normalizeKey(key) {
  if (typeof key === 'string') {
    return key.replace(/\s*/g, '');
  }

  return '' + key;
}

function getItemId(state, itemKey) {
  let listId = listIds.get(state);

  if (!listId) {
    throw new Error('Unknown list');
  }

  return listId + "-option-" + $d7356e622fdc32e5aea4e1e7cc2e6e6b$var$normalizeKey(itemKey);
}

/**
 * Provides the behavior and accessibility implementation for a listbox component.
 * A listbox displays a list of options and allows a user to select one or more of them.
 * @param props - Props for the listbox.
 * @param state - State for the listbox, as returned by `useListState`.
 */
function useListBox(props, state, ref) {
  let domProps = filterDOMProps(props, {
    labelable: true
  });
  let {
    listProps
  } = useSelectableList(_extends({}, props, {
    ref,
    selectionManager: state.selectionManager,
    collection: state.collection,
    disabledKeys: state.disabledKeys
  }));
  let id = useId(props.id);
  listIds.set(state, id);
  let {
    labelProps,
    fieldProps
  } = useLabel(_extends({}, props, {
    id,
    // listbox is not an HTML input element so it
    // shouldn't be labeled by a <label> element.
    labelElementType: 'span'
  }));
  return {
    labelProps,
    listBoxProps: mergeProps(domProps, state.selectionManager.selectionMode === 'multiple' ? {
      'aria-multiselectable': 'true'
    } : {}, _extends({
      role: 'listbox'
    }, mergeProps(fieldProps, listProps)))
  };
}

/**
 * Provides the behavior and accessibility implementation for an option in a listbox.
 * See `useListBox` for more details about listboxes.
 * @param props - Props for the option.
 * @param state - State for the listbox, as returned by `useListState`.
 */
function useOption(props, state, ref) {
  let {
    isSelected,
    isDisabled,
    key,
    shouldSelectOnPressUp,
    shouldFocusOnHover,
    isVirtualized,
    shouldUseVirtualFocus
  } = props;
  let labelId = useSlotId();
  let descriptionId = useSlotId();
  let optionProps = {
    role: 'option',
    'aria-disabled': isDisabled,
    'aria-selected': isSelected
  }; // Safari with VoiceOver on macOS misreads options with aria-labelledby or aria-label as simply "text".
  // We should not map slots to the label and description on Safari and instead just have VoiceOver read the textContent.
  // https://bugs.webkit.org/show_bug.cgi?id=209279

  if (!(isMac() && isWebKit())) {
    optionProps['aria-label'] = props['aria-label'];
    optionProps['aria-labelledby'] = labelId;
    optionProps['aria-describedby'] = descriptionId;
  }

  if (isVirtualized) {
    optionProps['aria-posinset'] = state.collection.getItem(key).index + 1;
    optionProps['aria-setsize'] = getItemCount$1(state.collection);
  }

  let {
    itemProps
  } = useSelectableItem({
    selectionManager: state.selectionManager,
    key,
    ref,
    shouldSelectOnPressUp,
    isVirtualized,
    shouldUseVirtualFocus
  });
  let {
    pressProps
  } = usePress(_extends({}, itemProps, {
    isDisabled,
    preventFocusOnPress: shouldUseVirtualFocus
  }));
  let {
    hoverProps
  } = useHover({
    isDisabled: isDisabled || !shouldFocusOnHover,

    onHoverStart() {
      if (!isFocusVisible()) {
        state.selectionManager.setFocused(true);
        state.selectionManager.setFocusedKey(key);
      }
    }

  });
  return {
    optionProps: _extends({}, optionProps, mergeProps(pressProps, hoverProps), {
      id: getItemId(state, key)
    }),
    labelProps: {
      id: labelId
    },
    descriptionProps: {
      id: descriptionId
    }
  };
}

/**
 * Provides the behavior and accessibility implementation for a section in a listbox.
 * See `useListBox` for more details about listboxes.
 * @param props - Props for the section.
 */
function useListBoxSection(props) {
  let {
    heading,
    'aria-label': ariaLabel
  } = props;
  let headingId = useId();
  return {
    itemProps: {
      role: 'presentation'
    },
    headingProps: heading ? {
      // Techincally, listbox cannot contain headings according to ARIA.
      // We hide the heading from assistive technology, and only use it
      // as a label for the nested group.
      id: headingId,
      'aria-hidden': true
    } : {},
    groupProps: {
      role: 'group',
      'aria-label': ariaLabel,
      'aria-labelledby': heading ? headingId : undefined
    }
  };
}

function $e92117d6e5313ef8e7c10fac1de193ce$var$Item(props) {
  // eslint-disable-line @typescript-eslint/no-unused-vars
  return null;
}

$e92117d6e5313ef8e7c10fac1de193ce$var$Item.getCollectionNode = function* getCollectionNode(props, context) {
  let {
    childItems,
    title,
    children
  } = props;
  let rendered = props.title || props.children;
  let textValue = props.textValue || (typeof rendered === 'string' ? rendered : '') || props['aria-label'] || ''; // suppressTextValueWarning is used in components like Tabs, which don't have type to select support.

  if (!textValue && !(context == null ? void 0 : context.suppressTextValueWarning)) {
    console.warn('<Item> with non-plain text contents is unsupported by type to select for accessibility. Please add a `textValue` prop.');
  }

  yield {
    type: 'item',
    props: props,
    rendered,
    textValue,
    'aria-label': props['aria-label'],
    hasChildNodes: $e92117d6e5313ef8e7c10fac1de193ce$var$hasChildItems(props),

    *childNodes() {
      if (childItems) {
        for (let child of childItems) {
          yield {
            type: 'item',
            value: child
          };
        }
      } else if (title) {
        let items = [];

        _react__default.Children.forEach(children, child => {
          items.push({
            type: 'item',
            element: child
          });
        });

        yield* items;
      }
    }

  };
};

function $e92117d6e5313ef8e7c10fac1de193ce$var$hasChildItems(props) {
  if (props.hasChildItems != null) {
    return props.hasChildItems;
  }

  if (props.childItems) {
    return true;
  }

  if (props.title && _react__default.Children.count(props.children) > 0) {
    return true;
  }

  return false;
} // We don't want getCollectionNode to show up in the type definition


let Item$1 = $e92117d6e5313ef8e7c10fac1de193ce$var$Item;

class $f8429209754fda4b9142d514065f4$export$CollectionBuilder$1 {
  constructor() {
    this.context = void 0;
    this.cache = new WeakMap();
  }

  build(props, context) {
    this.context = context;
    return $f8429209754fda4b9142d514065f4$var$iterable$1(() => this.iterateCollection(props));
  }

  *iterateCollection(props) {
    let {
      children,
      items
    } = props;

    if (typeof children === 'function') {
      if (!items) {
        throw new Error('props.children was a function but props.items is missing');
      }

      for (let item of props.items) {
        yield* this.getFullNode({
          value: item
        }, {
          renderer: children
        });
      }
    } else {
      let items = [];

      _react__default.Children.forEach(children, child => {
        items.push(child);
      });

      let index = 0;

      for (let item of items) {
        let nodes = this.getFullNode({
          element: item,
          index: index
        }, {});

        for (let node of nodes) {
          index++;
          yield node;
        }
      }
    }
  }

  getKey(item, partialNode, state, parentKey) {
    if (item.key != null) {
      return item.key;
    }

    if (partialNode.type === 'cell' && partialNode.key != null) {
      return "" + parentKey + partialNode.key;
    }

    let v = partialNode.value;

    if (v != null) {
      var _v$key;

      let key = (_v$key = v.key) != null ? _v$key : v.id;

      if (key == null) {
        throw new Error('No key found for item');
      }

      return key;
    }

    return parentKey ? parentKey + "." + partialNode.index : "$." + partialNode.index;
  }

  getChildState(state, partialNode) {
    return {
      renderer: partialNode.renderer || state.renderer
    };
  }

  *getFullNode(partialNode, state, parentKey, parentNode) {
    // If there's a value instead of an element on the node, and a parent renderer function is available,
    // use it to render an element for the value.
    let element = partialNode.element;

    if (!element && partialNode.value && state && state.renderer) {
      let cached = this.cache.get(partialNode.value);

      if (cached && (!cached.shouldInvalidate || !cached.shouldInvalidate(this.context))) {
        cached.index = partialNode.index;
        yield cached;
        return;
      }

      element = state.renderer(partialNode.value);
    } // If there's an element with a getCollectionNode function on its type, then it's a supported component.
    // Call this function to get a partial node, and recursively build a full node from there.


    if ( /*#__PURE__*/_react__default.isValidElement(element)) {
      let type = element.type;

      if (typeof type !== 'function' || typeof type.getCollectionNode !== 'function') {
        let name = typeof element.type === 'function' ? element.type.name : element.type;
        throw new Error("Unknown element <" + name + "> in collection.");
      }

      let childNodes = type.getCollectionNode(element.props, this.context);
      let index = partialNode.index;
      let result = childNodes.next();

      while (!result.done && result.value) {
        let childNode = result.value;
        partialNode.index = index;
        let nodeKey = childNode.key;

        if (!nodeKey) {
          nodeKey = childNode.element ? null : this.getKey(element, partialNode, state, parentKey);
        }

        let nodes = this.getFullNode(_extends({}, childNode, {
          key: nodeKey,
          index,
          wrapper: $f8429209754fda4b9142d514065f4$var$compose$1(partialNode.wrapper, childNode.wrapper)
        }), this.getChildState(state, childNode), parentKey ? "" + parentKey + element.key : element.key, parentNode);
        let children = [...nodes];

        for (let node of children) {
          // Cache the node based on its value
          node.value = childNode.value || partialNode.value;

          if (node.value) {
            this.cache.set(node.value, node);
          } // The partial node may have specified a type for the child in order to specify a constraint.
          // Verify that the full node that was built recursively matches this type.


          if (partialNode.type && node.type !== partialNode.type) {
            throw new Error("Unsupported type <" + $f8429209754fda4b9142d514065f4$var$capitalize$1(node.type) + "> in <" + $f8429209754fda4b9142d514065f4$var$capitalize$1(parentNode.type) + ">. Only <" + $f8429209754fda4b9142d514065f4$var$capitalize$1(partialNode.type) + "> is supported.");
          }

          index++;
          yield node;
        }

        result = childNodes.next(children);
      }

      return;
    } // Ignore invalid elements


    if (partialNode.key == null) {
      return;
    } // Create full node


    let builder = this;
    let node = {
      type: partialNode.type,
      props: partialNode.props,
      key: partialNode.key,
      parentKey: parentNode ? parentNode.key : null,
      value: partialNode.value,
      level: parentNode ? parentNode.level + 1 : 0,
      index: partialNode.index,
      rendered: partialNode.rendered,
      textValue: partialNode.textValue,
      'aria-label': partialNode['aria-label'],
      wrapper: partialNode.wrapper,
      shouldInvalidate: partialNode.shouldInvalidate,
      hasChildNodes: partialNode.hasChildNodes,
      childNodes: $f8429209754fda4b9142d514065f4$var$iterable$1(function* () {
        if (!partialNode.hasChildNodes) {
          return;
        }

        let index = 0;

        for (let child of partialNode.childNodes()) {
          // Ensure child keys are globally unique by prepending the parent node's key
          if (child.key != null) {
            child.key = "" + node.key + child.key;
          }

          child.index = index;
          let nodes = builder.getFullNode(child, builder.getChildState(state, child), node.key, node);

          for (let node of nodes) {
            index++;
            yield node;
          }
        }
      })
    };
    yield node;
  }

} // Wraps an iterator function as an iterable object, and caches the results.


function $f8429209754fda4b9142d514065f4$var$iterable$1(iterator) {
  let cache = [];
  let iterable = null;
  return {
    *[Symbol.iterator]() {
      for (let item of cache) {
        yield item;
      }

      if (!iterable) {
        iterable = iterator();
      }

      for (let item of iterable) {
        cache.push(item);
        yield item;
      }
    }

  };
}

function $f8429209754fda4b9142d514065f4$var$compose$1(outer, inner) {
  if (outer && inner) {
    return element => outer(inner(element));
  }

  if (outer) {
    return outer;
  }

  if (inner) {
    return inner;
  }
}

function $f8429209754fda4b9142d514065f4$var$capitalize$1(str) {
  return str[0].toUpperCase() + str.slice(1);
}

function useCollection$1(props, factory, context, invalidators) {
  if (invalidators === void 0) {
    invalidators = [];
  }

  let builder = useMemo(() => new $f8429209754fda4b9142d514065f4$export$CollectionBuilder$1(), []);
  let prev = useRef(null);
  return useMemo(() => {
    let nodes = builder.build(props, context);
    prev.current = factory(nodes, prev.current);
    return prev.current; // Don't invalidate when any prop changes, just the two we care about.
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [builder, props.children, props.items, context, ...invalidators]);
}

class $f8429209754fda4b9142d514065f4$export$CollectionBuilder {
  constructor() {
    this.context = void 0;
    this.cache = new WeakMap();
  }

  build(props, context) {
    this.context = context;
    return $f8429209754fda4b9142d514065f4$var$iterable(() => this.iterateCollection(props));
  }

  *iterateCollection(props) {
    let {
      children,
      items
    } = props;

    if (typeof children === 'function') {
      if (!items) {
        throw new Error('props.children was a function but props.items is missing');
      }

      for (let item of props.items) {
        yield* this.getFullNode({
          value: item
        }, {
          renderer: children
        });
      }
    } else {
      let items = [];

      _react__default.Children.forEach(children, child => {
        items.push(child);
      });

      let index = 0;

      for (let item of items) {
        let nodes = this.getFullNode({
          element: item,
          index: index
        }, {});

        for (let node of nodes) {
          index++;
          yield node;
        }
      }
    }
  }

  getKey(item, partialNode, state, parentKey) {
    if (item.key != null) {
      return item.key;
    }

    if (partialNode.type === 'cell' && partialNode.key != null) {
      return "" + parentKey + partialNode.key;
    }

    let v = partialNode.value;

    if (v != null) {
      var _v$key;

      let key = (_v$key = v.key) != null ? _v$key : v.id;

      if (key == null) {
        throw new Error('No key found for item');
      }

      return key;
    }

    return parentKey ? parentKey + "." + partialNode.index : "$." + partialNode.index;
  }

  getChildState(state, partialNode) {
    return {
      renderer: partialNode.renderer || state.renderer
    };
  }

  *getFullNode(partialNode, state, parentKey, parentNode) {
    // If there's a value instead of an element on the node, and a parent renderer function is available,
    // use it to render an element for the value.
    let element = partialNode.element;

    if (!element && partialNode.value && state && state.renderer) {
      let cached = this.cache.get(partialNode.value);

      if (cached && (!cached.shouldInvalidate || !cached.shouldInvalidate(this.context))) {
        cached.index = partialNode.index;
        cached.parentKey = parentNode ? parentNode.key : null;
        yield cached;
        return;
      }

      element = state.renderer(partialNode.value);
    } // If there's an element with a getCollectionNode function on its type, then it's a supported component.
    // Call this function to get a partial node, and recursively build a full node from there.


    if ( /*#__PURE__*/_react__default.isValidElement(element)) {
      let type = element.type;

      if (typeof type !== 'function' && typeof type.getCollectionNode !== 'function') {
        let name = typeof element.type === 'function' ? element.type.name : element.type;
        throw new Error("Unknown element <" + name + "> in collection.");
      }

      let childNodes = type.getCollectionNode(element.props, this.context);
      let index = partialNode.index;
      let result = childNodes.next();

      while (!result.done && result.value) {
        let childNode = result.value;
        partialNode.index = index;
        let nodeKey = childNode.key;

        if (!nodeKey) {
          nodeKey = childNode.element ? null : this.getKey(element, partialNode, state, parentKey);
        }

        let nodes = this.getFullNode(_extends({}, childNode, {
          key: nodeKey,
          index,
          wrapper: $f8429209754fda4b9142d514065f4$var$compose(partialNode.wrapper, childNode.wrapper)
        }), this.getChildState(state, childNode), parentKey ? "" + parentKey + element.key : element.key, parentNode);
        let children = [...nodes];

        for (let node of children) {
          // Cache the node based on its value
          node.value = childNode.value || partialNode.value;

          if (node.value) {
            this.cache.set(node.value, node);
          } // The partial node may have specified a type for the child in order to specify a constraint.
          // Verify that the full node that was built recursively matches this type.


          if (partialNode.type && node.type !== partialNode.type) {
            throw new Error("Unsupported type <" + $f8429209754fda4b9142d514065f4$var$capitalize(node.type) + "> in <" + $f8429209754fda4b9142d514065f4$var$capitalize(parentNode.type) + ">. Only <" + $f8429209754fda4b9142d514065f4$var$capitalize(partialNode.type) + "> is supported.");
          }

          index++;
          yield node;
        }

        result = childNodes.next(children);
      }

      return;
    } // Ignore invalid elements


    if (partialNode.key == null) {
      return;
    } // Create full node


    let builder = this;
    let node = {
      type: partialNode.type,
      props: partialNode.props,
      key: partialNode.key,
      parentKey: parentNode ? parentNode.key : null,
      value: partialNode.value,
      level: parentNode ? parentNode.level + 1 : 0,
      index: partialNode.index,
      rendered: partialNode.rendered,
      textValue: partialNode.textValue,
      'aria-label': partialNode['aria-label'],
      wrapper: partialNode.wrapper,
      shouldInvalidate: partialNode.shouldInvalidate,
      hasChildNodes: partialNode.hasChildNodes,
      childNodes: $f8429209754fda4b9142d514065f4$var$iterable(function* () {
        if (!partialNode.hasChildNodes) {
          return;
        }

        let index = 0;

        for (let child of partialNode.childNodes()) {
          // Ensure child keys are globally unique by prepending the parent node's key
          if (child.key != null) {
            child.key = "" + node.key + child.key;
          }

          child.index = index;
          let nodes = builder.getFullNode(child, builder.getChildState(state, child), node.key, node);

          for (let node of nodes) {
            index++;
            yield node;
          }
        }
      })
    };
    yield node;
  }

} // Wraps an iterator function as an iterable object, and caches the results.


function $f8429209754fda4b9142d514065f4$var$iterable(iterator) {
  let cache = [];
  let iterable = null;
  return {
    *[Symbol.iterator]() {
      for (let item of cache) {
        yield item;
      }

      if (!iterable) {
        iterable = iterator();
      }

      for (let item of iterable) {
        cache.push(item);
        yield item;
      }
    }

  };
}

function $f8429209754fda4b9142d514065f4$var$compose(outer, inner) {
  if (outer && inner) {
    return element => outer(inner(element));
  }

  if (outer) {
    return outer;
  }

  if (inner) {
    return inner;
  }
}

function $f8429209754fda4b9142d514065f4$var$capitalize(str) {
  return str[0].toUpperCase() + str.slice(1);
}

function useCollection(props, factory, context, invalidators) {
  if (invalidators === void 0) {
    invalidators = [];
  }

  let builder = useMemo(() => new $f8429209754fda4b9142d514065f4$export$CollectionBuilder(), []);
  let prev = useRef(null);
  return useMemo(() => {
    let nodes = builder.build(props, context);
    prev.current = factory(nodes, prev.current);
    return prev.current; // Don't invalidate when any prop changes, just the two we care about.
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [builder, props.children, props.items, context, ...invalidators]);
}

/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */

/**
 * A Selection is a special Set containing Keys, which also has an anchor
 * and current selected key for use when range selecting.
 */
class $c91e86e24f2dc9a2182dcc2674c58c$export$Selection extends Set {
  constructor(keys, anchorKey, currentKey) {
    super(keys);
    this.anchorKey = void 0;
    this.currentKey = void 0;

    if (keys instanceof $c91e86e24f2dc9a2182dcc2674c58c$export$Selection) {
      this.anchorKey = anchorKey || keys.anchorKey;
      this.currentKey = currentKey || keys.currentKey;
    } else {
      this.anchorKey = anchorKey;
      this.currentKey = currentKey;
    }
  }

}

/**
 * Manages state for multiple selection and focus in a collection.
 */
function useMultipleSelectionState$1(props) {
  let {
    selectionMode = 'none',
    disallowEmptySelection
  } = props; // We want synchronous updates to `isFocused` and `focusedKey` after their setters are called.
  // But we also need to trigger a react re-render. So, we have both a ref (sync) and state (async).

  let isFocusedRef = useRef(false);
  let [, setFocused] = useState(false);
  let focusedKeyRef = useRef(null);
  let childFocusStrategyRef = useRef(null);
  let [, setFocusedKey] = useState(null);
  let selectedKeysProp = useMemo(() => $c86d35e876e048ac11515eee40c7$var$convertSelection(props.selectedKeys), [props.selectedKeys]);
  let defaultSelectedKeys = useMemo(() => $c86d35e876e048ac11515eee40c7$var$convertSelection(props.defaultSelectedKeys, new $c91e86e24f2dc9a2182dcc2674c58c$export$Selection()), [props.defaultSelectedKeys]);
  let [selectedKeys, setSelectedKeys] = useControlledState(selectedKeysProp, defaultSelectedKeys, props.onSelectionChange);
  let disabledKeysProp = useMemo(() => props.disabledKeys ? new Set(props.disabledKeys) : new Set(), [props.disabledKeys]);
  return {
    selectionMode,
    disallowEmptySelection,

    get isFocused() {
      return isFocusedRef.current;
    },

    setFocused(f) {
      isFocusedRef.current = f;
      setFocused(f);
    },

    get focusedKey() {
      return focusedKeyRef.current;
    },

    get childFocusStrategy() {
      return childFocusStrategyRef.current;
    },

    setFocusedKey(k, childFocusStrategy) {
      if (childFocusStrategy === void 0) {
        childFocusStrategy = 'first';
      }

      focusedKeyRef.current = k;
      childFocusStrategyRef.current = childFocusStrategy;
      setFocusedKey(k);
    },

    selectedKeys,
    setSelectedKeys,
    disabledKeys: disabledKeysProp
  };
}

function $c86d35e876e048ac11515eee40c7$var$convertSelection(selection, defaultValue) {
  if (!selection) {
    return defaultValue;
  }

  return selection === 'all' ? 'all' : new $c91e86e24f2dc9a2182dcc2674c58c$export$Selection(selection);
}

/**
 * An interface for reading and updating multiple selection state.
 */
class SelectionManager {
  constructor(collection, state, options) {
    var _options$allowsCellSe;

    this.collection = void 0;
    this.state = void 0;
    this.allowsCellSelection = void 0;
    this._isSelectAll = void 0;
    this.collection = collection;
    this.state = state;
    this.allowsCellSelection = (_options$allowsCellSe = options == null ? void 0 : options.allowsCellSelection) != null ? _options$allowsCellSe : false;
    this._isSelectAll = null;
  }
  /**
   * The type of selection that is allowed in the collection.
   */


  get selectionMode() {
    return this.state.selectionMode;
  }
  /**
   * Whether the collection allows empty selection.
   */


  get disallowEmptySelection() {
    return this.state.disallowEmptySelection;
  }
  /**
   * Whether the collection is currently focused.
   */


  get isFocused() {
    return this.state.isFocused;
  }
  /**
   * Sets whether the collection is focused.
   */


  setFocused(isFocused) {
    this.state.setFocused(isFocused);
  }
  /**
   * The current focused key in the collection.
   */


  get focusedKey() {
    return this.state.focusedKey;
  }
  /** Whether the first or last child of the focused key should receive focus. */


  get childFocusStrategy() {
    return this.state.childFocusStrategy;
  }
  /**
   * Sets the focused key.
   */


  setFocusedKey(key, childFocusStrategy) {
    this.state.setFocusedKey(key, childFocusStrategy);
  }
  /**
   * The currently selected keys in the collection.
   */


  get selectedKeys() {
    return this.state.selectedKeys === 'all' ? new Set(this.getSelectAllKeys()) : this.state.selectedKeys;
  }
  /**
   * The raw selection value for the collection.
   * Either 'all' for select all, or a set of keys.
   */


  get rawSelection() {
    return this.state.selectedKeys;
  }
  /**
   * Returns whether a key is selected.
   */


  isSelected(key) {
    if (this.state.selectionMode === 'none') {
      return false;
    }

    key = this.getKey(key);
    return this.state.selectedKeys === 'all' ? !this.state.disabledKeys.has(key) : this.state.selectedKeys.has(key);
  }
  /**
   * Whether the selection is empty.
   */


  get isEmpty() {
    return this.state.selectedKeys !== 'all' && this.state.selectedKeys.size === 0;
  }
  /**
   * Whether all items in the collection are selected.
   */


  get isSelectAll() {
    if (this.isEmpty) {
      return false;
    }

    if (this.state.selectedKeys === 'all') {
      return true;
    }

    if (this._isSelectAll != null) {
      return this._isSelectAll;
    }

    let allKeys = this.getSelectAllKeys();
    let selectedKeys = this.state.selectedKeys;
    this._isSelectAll = allKeys.every(k => selectedKeys.has(k));
    return this._isSelectAll;
  }

  get firstSelectedKey() {
    var _first;

    let first = null;

    for (let key of this.state.selectedKeys) {
      let item = this.collection.getItem(key);

      if (!first || (item == null ? void 0 : item.index) < first.index) {
        first = item;
      }
    }

    return (_first = first) == null ? void 0 : _first.key;
  }

  get lastSelectedKey() {
    var _last;

    let last = null;

    for (let key of this.state.selectedKeys) {
      let item = this.collection.getItem(key);

      if (!last || (item == null ? void 0 : item.index) > last.index) {
        last = item;
      }
    }

    return (_last = last) == null ? void 0 : _last.key;
  }
  /**
   * Extends the selection to the given key.
   */


  extendSelection(toKey) {
    toKey = this.getKey(toKey);
    let selection; // Only select the one key if coming from a select all.

    if (this.state.selectedKeys === 'all') {
      selection = new $c91e86e24f2dc9a2182dcc2674c58c$export$Selection([toKey], toKey, toKey);
    } else {
      let selectedKeys = this.state.selectedKeys;
      let anchorKey = selectedKeys.anchorKey || toKey;
      selection = new $c91e86e24f2dc9a2182dcc2674c58c$export$Selection(selectedKeys, anchorKey, toKey);

      for (let key of this.getKeyRange(anchorKey, selectedKeys.currentKey || toKey)) {
        selection.delete(key);
      }

      for (let key of this.getKeyRange(toKey, anchorKey)) {
        if (!this.state.disabledKeys.has(key)) {
          selection.add(key);
        }
      }
    }

    this.state.setSelectedKeys(selection);
  }

  getKeyRange(from, to) {
    let fromItem = this.collection.getItem(from);
    let toItem = this.collection.getItem(to);

    if (fromItem && toItem) {
      if (fromItem.index <= toItem.index) {
        return this.getKeyRangeInternal(from, to);
      }

      return this.getKeyRangeInternal(to, from);
    }

    return [];
  }

  getKeyRangeInternal(from, to) {
    let keys = [];
    let key = from;

    while (key) {
      let item = this.collection.getItem(key);

      if (item && item.type === 'item' || item.type === 'cell' && this.allowsCellSelection) {
        keys.push(key);
      }

      if (key === to) {
        return keys;
      }

      key = this.collection.getKeyAfter(key);
    }

    return [];
  }

  getKey(key) {
    let item = this.collection.getItem(key);

    if (!item) {
      // ¯\_(ツ)_/¯
      return key;
    } // If cell selection is allowed, just return the key.


    if (item.type === 'cell' && this.allowsCellSelection) {
      return key;
    } // Find a parent item to select


    while (item.type !== 'item' && item.parentKey) {
      item = this.collection.getItem(item.parentKey);
    }

    if (!item || item.type !== 'item') {
      return null;
    }

    return item.key;
  }
  /**
   * Toggles whether the given key is selected.
   */


  toggleSelection(key) {
    key = this.getKey(key);

    if (key == null) {
      return;
    }

    let keys = new $c91e86e24f2dc9a2182dcc2674c58c$export$Selection(this.state.selectedKeys === 'all' ? this.getSelectAllKeys() : this.state.selectedKeys);

    if (keys.has(key)) {
      keys.delete(key); // TODO: move anchor to last selected key...
      // Does `current` need to move here too?
    } else {
      keys.add(key);
      keys.anchorKey = key;
      keys.currentKey = key;
    }

    if (this.disallowEmptySelection && keys.size === 0) {
      return;
    }

    this.state.setSelectedKeys(keys);
  }
  /**
   * Replaces the selection with only the given key.
   */


  replaceSelection(key) {
    key = this.getKey(key);

    if (key == null) {
      return;
    }

    this.state.setSelectedKeys(new $c91e86e24f2dc9a2182dcc2674c58c$export$Selection([key], key, key));
  }
  /**
   * Replaces the selection with the given keys.
   */


  setSelectedKeys(keys) {
    if (this.selectionMode === 'none') {
      return;
    }

    let selection = new $c91e86e24f2dc9a2182dcc2674c58c$export$Selection();

    for (let key of keys) {
      key = this.getKey(key);

      if (key != null) {
        selection.add(key);

        if (this.selectionMode === 'single') {
          break;
        }
      }
    }

    this.state.setSelectedKeys(selection);
  }

  getSelectAllKeys() {
    let keys = [];

    let addKeys = key => {
      while (key) {
        if (!this.state.disabledKeys.has(key)) {
          let item = this.collection.getItem(key);

          if (item.type === 'item') {
            keys.push(key);
          } // Add child keys. If cell selection is allowed, then include item children too.


          if (item.hasChildNodes && (this.allowsCellSelection || item.type !== 'item')) {
            addKeys([...item.childNodes][0].key);
          }
        }

        key = this.collection.getKeyAfter(key);
      }
    };

    addKeys(this.collection.getFirstKey());
    return keys;
  }
  /**
   * Selects all items in the collection.
   */


  selectAll() {
    if (this.selectionMode === 'multiple') {
      this.state.setSelectedKeys('all');
    }
  }
  /**
   * Removes all keys from the selection.
   */


  clearSelection() {
    if (!this.disallowEmptySelection && (this.state.selectedKeys === 'all' || this.state.selectedKeys.size > 0)) {
      this.state.setSelectedKeys(new $c91e86e24f2dc9a2182dcc2674c58c$export$Selection());
    }
  }
  /**
   * Toggles between select all and an empty selection.
   */


  toggleSelectAll() {
    if (this.isSelectAll) {
      this.clearSelection();
    } else {
      this.selectAll();
    }
  }

  select(key, e) {
    if (this.selectionMode === 'none') {
      return;
    }

    if (this.selectionMode === 'single') {
      if (this.isSelected(key) && !this.disallowEmptySelection) {
        this.toggleSelection(key);
      } else {
        this.replaceSelection(key);
      }
    } else if (e && e.shiftKey) {
      this.extendSelection(key);
    } else {
      this.toggleSelection(key);
    }
  }
  /**
   * Returns whether the current selection is equal to the given selection.
   */


  isSelectionEqual(selection) {
    if (selection === this.state.selectedKeys) {
      return true;
    } // Check if the set of keys match.


    let selectedKeys = this.selectedKeys;

    if (selection.size !== selectedKeys.size) {
      return false;
    }

    for (let key of selection) {
      if (!selectedKeys.has(key)) {
        return false;
      }
    }

    for (let key of selectedKeys) {
      if (!selection.has(key)) {
        return false;
      }
    }

    return true;
  }

}

let $ed5d55e571caf578a4f08babbaa26be$var$_Symbol$iterator;
$ed5d55e571caf578a4f08babbaa26be$var$_Symbol$iterator = Symbol.iterator;

/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */
class ListCollection {
  constructor(nodes) {
    var _last;

    this.keyMap = new Map();
    this.iterable = void 0;
    this.firstKey = void 0;
    this.lastKey = void 0;
    this.iterable = nodes;

    let visit = node => {
      this.keyMap.set(node.key, node);

      if (node.childNodes && node.type === 'section') {
        for (let child of node.childNodes) {
          visit(child);
        }
      }
    };

    for (let node of nodes) {
      visit(node);
    }

    let last;
    let index = 0;

    for (let [key, node] of this.keyMap) {
      if (last) {
        last.nextKey = key;
        node.prevKey = last.key;
      } else {
        this.firstKey = key;
        node.prevKey = undefined;
      }

      if (node.type === 'item') {
        node.index = index++;
      }

      last = node; // Set nextKey as undefined since this might be the last node
      // If it isn't the last node, last.nextKey will properly set at start of new loop

      last.nextKey = undefined;
    }

    this.lastKey = (_last = last) == null ? void 0 : _last.key;
  }

  *[$ed5d55e571caf578a4f08babbaa26be$var$_Symbol$iterator]() {
    yield* this.iterable;
  }

  get size() {
    return this.keyMap.size;
  }

  getKeys() {
    return this.keyMap.keys();
  }

  getKeyBefore(key) {
    let node = this.keyMap.get(key);
    return node ? node.prevKey : null;
  }

  getKeyAfter(key) {
    let node = this.keyMap.get(key);
    return node ? node.nextKey : null;
  }

  getFirstKey() {
    return this.firstKey;
  }

  getLastKey() {
    return this.lastKey;
  }

  getItem(key) {
    return this.keyMap.get(key);
  }

  at(idx) {
    const keys = [...this.getKeys()];
    return this.getItem(keys[idx]);
  }

}

/**
 * Provides state management for list-like components. Handles building a collection
 * of items from props, and manages multiple selection state.
 */
function useListState(props) {
  let {
    filter
  } = props;
  let selectionState = useMultipleSelectionState$1(props);
  let disabledKeys = useMemo(() => props.disabledKeys ? new Set(props.disabledKeys) : new Set(), [props.disabledKeys]);

  let factory = nodes => filter ? new ListCollection(filter(nodes)) : new ListCollection(nodes);

  let context = useMemo(() => ({
    suppressTextValueWarning: props.suppressTextValueWarning
  }), [props.suppressTextValueWarning]);
  let collection = useCollection(props, factory, context, [filter]); // Reset focused key if that item is deleted from the collection.

  useEffect(() => {
    if (selectionState.focusedKey != null && !collection.getItem(selectionState.focusedKey)) {
      selectionState.setFocusedKey(null);
    }
  }, [collection, selectionState.focusedKey]);
  return {
    collection,
    disabledKeys,
    selectionManager: new SelectionManager(collection, selectionState)
  };
}

/**
 * Provides state management for list-like components with single selection.
 * Handles building a collection of items from props, and manages selection state.
 */
function useSingleSelectListState(props) {
  var _props$defaultSelecte;

  let [selectedKey, setSelectedKey] = useControlledState(props.selectedKey, (_props$defaultSelecte = props.defaultSelectedKey) != null ? _props$defaultSelecte : null, props.onSelectionChange);
  let selectedKeys = useMemo(() => selectedKey != null ? [selectedKey] : [], [selectedKey]);
  let {
    collection,
    disabledKeys,
    selectionManager
  } = useListState(_extends({}, props, {
    selectionMode: 'single',
    disallowEmptySelection: true,
    selectedKeys,
    onSelectionChange: keys => {
      let key = keys.values().next().value; // Always fire onSelectionChange, even if the key is the same
      // as the current key (useControlledState does not).

      if (key === selectedKey && props.onSelectionChange) {
        props.onSelectionChange(key);
      }

      setSelectedKey(key);
    }
  }));
  let selectedItem = selectedKey != null ? collection.getItem(selectedKey) : null;
  return {
    collection,
    disabledKeys,
    selectionManager,
    selectedKey,
    setSelectedKey,
    selectedItem
  };
}

function ListBoxBase(props, forwardRef) {
  const {
    matchedProps,
    remainingProps
  } = splitBoxProps(props);
  const domRef = _react.useRef();
  const ref = forwardRef || domRef;
  const state = useListState(props);
  const {
    listBoxProps
  } = useListBox(remainingProps, state, ref);
  return jsx(Box, Object.assign({}, listBoxProps, matchedProps, {
    color: matchedProps.color,
    ref: ref
  }, {
    children: [...state.collection].map(item => jsx(ListBoxOption, {
      item: item,
      state: state
    }, item.key))
  }), void 0);
} // forwardRef doesn't support generic parameters, so cast the result to the correct type
// https://stackoverflow.com/questions/58469229/react-with-typescript-generics-while-using-react-forwardref


const ListBox = /*#__PURE__*/_react.forwardRef(ListBoxBase);

function ListBoxOption({
  item,
  state
}) {
  const {
    rendered,
    key
  } = item;
  const isDisabled = state.disabledKeys.has(key);
  const ref = _react.useRef();
  const {
    optionProps
  } = useOption({
    key,
    isDisabled
  }, state, ref);
  const {
    isFocusVisible,
    focusProps
  } = useFocusRing();
  return jsx(Box, Object.assign({}, mergeProps(optionProps, focusProps), {
    bg: {
      default: isFocusVisible ? 'canvas-200' : 'transparent',
      hover: 'canvas-200'
    },
    color: "body",
    cursor: "pointer",
    ref: ref
  }, {
    children: rendered
  }), void 0);
}

const ListBoxItem = Item$1;

/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */
const $c10674539d06c96e1a2fbb6a54340$var$cache = new WeakMap();
function getItemCount(collection) {
  let count = $c10674539d06c96e1a2fbb6a54340$var$cache.get(collection);

  if (count != null) {
    return count;
  }

  count = 0;

  for (let item of collection) {
    if (item.type === 'section') {
      count += getItemCount(item.childNodes);
    } else {
      count++;
    }
  }

  $c10674539d06c96e1a2fbb6a54340$var$cache.set(collection, count);
  return count;
}

/**
 * Provides the behavior and accessibility implementation for a menu trigger.
 * @param props - Props for the menu trigger.
 * @param state - State for the menu trigger.
 */
function useMenuTrigger(props, state, ref) {
  let {
    type = 'menu',
    isDisabled
  } = props;
  let menuTriggerId = useId();
  let {
    triggerProps,
    overlayProps
  } = useOverlayTrigger({
    type
  }, state, ref);

  let onKeyDown = e => {
    if (typeof e.isDefaultPrevented === 'function' && e.isDefaultPrevented() || e.defaultPrevented || isDisabled) {
      return;
    }

    if (ref && ref.current) {
      switch (e.key) {
        case 'ArrowDown':
        case 'Enter':
        case ' ':
          e.preventDefault();
          e.stopPropagation();
          state.toggle('first');
          break;

        case 'ArrowUp':
          e.preventDefault();
          e.stopPropagation();
          state.toggle('last');
          break;
      }
    }
  };

  return {
    menuTriggerProps: _extends({}, triggerProps, {
      id: menuTriggerId,

      onPressStart(e) {
        // For consistency with native, open the menu on mouse/key down, but touch up.
        if (e.pointerType !== 'touch' && e.pointerType !== 'keyboard') {
          // If opened with a screen reader, auto focus the first item.
          // Otherwise, the menu itself will be focused.
          state.toggle(e.pointerType === 'virtual' ? 'first' : null);
        }
      },

      onPress(e) {
        if (e.pointerType === 'touch') {
          state.toggle();
        }
      },

      onKeyDown
    }),
    menuProps: _extends({}, overlayProps, {
      'aria-labelledby': menuTriggerId
    })
  };
}

/**
 * Provides the behavior and accessibility implementation for a menu component.
 * A menu displays a list of actions or options that a user can choose.
 * @param props - Props for the menu.
 * @param state - State for the menu, as returned by `useListState`.
 */
function useMenu(props, state, ref) {
  let {
    shouldFocusWrap = true
  } = props,
      otherProps = _objectWithoutPropertiesLoose(props, ["shouldFocusWrap"]);

  if (!props['aria-label'] && !props['aria-labelledby']) {
    console.warn('An aria-label or aria-labelledby prop is required for accessibility.');
  }

  let domProps = filterDOMProps(props, {
    labelable: true
  });
  let {
    listProps
  } = useSelectableList(_extends({}, otherProps, {
    ref,
    selectionManager: state.selectionManager,
    collection: state.collection,
    disabledKeys: state.disabledKeys,
    shouldFocusWrap
  }));
  return {
    menuProps: mergeProps(domProps, _extends({
      role: 'menu'
    }, listProps))
  };
}

/**
 * Provides the behavior and accessibility implementation for an item in a menu.
 * See `useMenu` for more details about menus.
 * @param props - Props for the item.
 * @param state - State for the menu, as returned by `useTreeState`.
 */
function useMenuItem(props, state, ref) {
  let {
    isSelected,
    isDisabled,
    key,
    onClose,
    closeOnSelect,
    isVirtualized,
    onAction
  } = props;
  let role = 'menuitem';

  if (state.selectionManager.selectionMode === 'single') {
    role = 'menuitemradio';
  } else if (state.selectionManager.selectionMode === 'multiple') {
    role = 'menuitemcheckbox';
  }

  let labelId = useSlotId();
  let descriptionId = useSlotId();
  let keyboardId = useSlotId();
  let ariaProps = {
    'aria-disabled': isDisabled,
    role,
    'aria-label': props['aria-label'],
    'aria-labelledby': labelId,
    'aria-describedby': [descriptionId, keyboardId].filter(Boolean).join(' ') || undefined
  };

  if (state.selectionManager.selectionMode !== 'none') {
    ariaProps['aria-checked'] = isSelected;
  }

  if (isVirtualized) {
    ariaProps['aria-posinset'] = state.collection.getItem(key).index;
    ariaProps['aria-setsize'] = getItemCount(state.collection);
  }

  let onKeyDown = e => {
    // Ignore repeating events, which may have started on the menu trigger before moving
    // focus to the menu item. We want to wait for a second complete key press sequence.
    if (e.repeat) {
      return;
    }

    switch (e.key) {
      case ' ':
        if (!isDisabled && state.selectionManager.selectionMode === 'none' && closeOnSelect !== false && onClose) {
          onClose();
        }

        break;

      case 'Enter':
        // The Enter key should always close on select, except if overridden.
        if (!isDisabled && closeOnSelect !== false && onClose) {
          onClose();
        }

        break;
    }
  };

  let onPressStart = e => {
    if (e.pointerType === 'keyboard' && onAction) {
      onAction(key);
    }
  };

  let onPressUp = e => {
    if (e.pointerType !== 'keyboard') {
      if (onAction) {
        onAction(key);
      } // Pressing a menu item should close by default in single selection mode but not multiple
      // selection mode, except if overridden by the closeOnSelect prop.


      if (onClose && (closeOnSelect != null ? closeOnSelect : state.selectionManager.selectionMode !== 'multiple')) {
        onClose();
      }
    }
  };

  let {
    itemProps
  } = useSelectableItem({
    selectionManager: state.selectionManager,
    key,
    ref,
    shouldSelectOnPressUp: true
  });
  let {
    pressProps
  } = usePress(mergeProps({
    onPressStart,
    onPressUp,
    onKeyDown,
    isDisabled
  }, itemProps));
  let {
    hoverProps
  } = useHover({
    isDisabled,

    onHoverStart() {
      if (!isFocusVisible()) {
        state.selectionManager.setFocused(true);
        state.selectionManager.setFocusedKey(key);
      }
    }

  });
  return {
    menuItemProps: _extends({}, ariaProps, mergeProps(pressProps, hoverProps)),
    labelProps: {
      id: labelId
    },
    descriptionProps: {
      id: descriptionId
    },
    keyboardShortcutProps: {
      id: keyboardId
    }
  };
}

/**
 * Provides the behavior and accessibility implementation for a section in a menu.
 * See `useMenu` for more details about menus.
 * @param props - Props for the section.
 */
function useMenuSection(props) {
  let {
    heading,
    'aria-label': ariaLabel
  } = props;
  let headingId = useId();
  return {
    itemProps: {
      role: 'presentation'
    },
    headingProps: heading ? {
      // Techincally, menus cannot contain headings according to ARIA.
      // We hide the heading from assistive technology, and only use it
      // as a label for the nested group.
      id: headingId,
      'aria-hidden': true
    } : {},
    groupProps: {
      role: 'group',
      'aria-label': ariaLabel,
      'aria-labelledby': heading ? headingId : undefined
    }
  };
}

/**
 * Manages state for a menu trigger. Tracks whether the menu is currently open,
 * and controls which item will receive focus when it opens.
 */
function useMenuTriggerState(props) {
  let overlayTriggerState = useOverlayTriggerState(props);
  let [focusStrategy, setFocusStrategy] = useState(null);
  return _extends({
    focusStrategy
  }, overlayTriggerState, {
    open(focusStrategy) {
      if (focusStrategy === void 0) {
        focusStrategy = null;
      }

      setFocusStrategy(focusStrategy);
      overlayTriggerState.open();
    },

    toggle(focusStrategy) {
      if (focusStrategy === void 0) {
        focusStrategy = null;
      }

      setFocusStrategy(focusStrategy);
      overlayTriggerState.toggle();
    }

  });
}

const Popover = /*#__PURE__*/forwardRef((props, ref) => {
  const {
    renderTrigger,
    children,
    isOpen,
    defaultOpen,
    placement = 'bottom',
    scrollRef,
    onOpen,
    onClose,
    contain = true,
    autoFocus = true,
    restoreFocus = true,
    offset = props.showArrow ? 10 : 8,
    crossOffset = 0,
    shouldFlip = true,
    p,
    appearance = 'default',
    showArrow,
    type = 'dialog',
    isNonModal,
    matchTriggerWidth,
    boundaryElement
  } = props;
  const onOpenChange = useCallback($isOpen => {
    if ($isOpen && onOpen) onOpen();
    if (!$isOpen && onClose) onClose();
  }, [onClose, onOpen]);
  let state = useOverlayTriggerState({
    isOpen,
    defaultOpen,
    onOpenChange
  });
  const triggerRef = useRef();
  const consumerProvidedRef = !!props.triggerRef;
  const popoverRef = useRef();
  let unwrappedPopoverRef = useUnwrapDOMRef(popoverRef); // Get props for the trigger and overlay. This also handles
  // hiding the overlay when a parent element of the trigger scrolls
  // (which invalidates the popover positioning).

  let {
    triggerProps,
    overlayProps
  } = useOverlayTrigger({
    type
  }, state, triggerRef); // Get popover positioning props relative to the trigger

  let {
    overlayProps: positionProps,
    arrowProps,
    arrowIcon
  } = useOverlayPosition({
    targetRef: props.triggerRef || triggerRef,
    overlayRef: unwrappedPopoverRef,
    placement,
    offset,
    scrollRef,
    crossOffset,
    boundaryElement,
    shouldFlip,
    isOpen: state.isOpen,
    onClose,
    matchTriggerWidth
  });
  const triggerPropsWithRef = { ...triggerProps,
    ref: consumerProvidedRef ? undefined : triggerRef
  }; // if isOpen is provided (controlled mode), do not use our own onPress handler

  const onPress = isOpen === void 0 ? state.toggle : undefined;
  const triggerElem = renderTrigger ? runIfFn(renderTrigger, {
    isOpen: state.isOpen
  }) : null;
  return jsxs(Fragment, {
    children: [triggerElem && jsx(PressResponder, Object.assign({}, triggerPropsWithRef, {
      onPress: onPress,
      isPressed: state.isOpen
    }, {
      children: triggerElem
    }), void 0), jsx(_Overlay, Object.assign({
      isOpen: state.isOpen
    }, {
      children: jsxs(PopoverWrapper, Object.assign({}, overlayProps, positionProps, {
        ref: popoverRef,
        isOpen: state.isOpen,
        onClose: state.close,
        p: p,
        contain: contain,
        autoFocus: autoFocus,
        restoreFocus: restoreFocus,
        appearance: appearance,
        isNonModal: isNonModal,
        type: type
      }, {
        children: [runIfFn(children, {
          close: state.close
        }), showArrow && jsx(TooltipArrow$1, {
          icon: arrowIcon,
          style: arrowProps.style
        }, void 0)]
      }), void 0)
    }), void 0)]
  }, void 0);
});
const popoverVariants = {
  default: {
    p: 4,
    bg: 'canvas-dialog'
  },
  minimal: {}
};
const PopoverWrapper = /*#__PURE__*/forwardRef(({
  children,
  isOpen,
  onClose,
  contain,
  autoFocus,
  restoreFocus,
  appearance,
  isNonModal,
  type,
  ...otherProps
}, ref) => {
  let domRef = useDOMRef(ref); // Handle interacting outside the dialog and pressing
  // the Escape key to close the modal.

  let {
    overlayProps
  } = useOverlay({
    onClose,
    isOpen,
    isDismissable: true,
    shouldCloseOnBlur: type === 'listbox'
  }, domRef); // Hide content outside the modal from screen readers.

  let {
    modalProps
  } = useModal({
    isDisabled: isNonModal
  });
  const {
    color,
    ...containerProps
  } = mergeProps(overlayProps, otherProps, modalProps);
  const variantProps = popoverVariants[appearance] || {}; // Focus the popover itself on mount, unless a child element is already focused.

  useEffect(() => {
    // without the requestAnimationFrame, interactions with popover in cypress testing environment fail
    requestAnimationFrame(() => {
      if (domRef.current && !domRef.current.contains(document.activeElement)) {
        focusSafely(domRef.current);
      }
    });
  }, [domRef]);
  return jsxs(FocusScope, Object.assign({
    contain: contain,
    restoreFocus: restoreFocus,
    autoFocus: autoFocus
  }, {
    children: [jsx(DismissButton, {
      onDismiss: onClose
    }, void 0), jsx(Box, Object.assign({}, containerProps, variantProps, {
      className: "sl-popover",
      ref: domRef,
      role: "presentation",
      tabIndex: -1,
      display: "inline-flex",
      "data-testid": "popover",
      "data-ispopover": "true"
    }, {
      children: children
    }), void 0), jsx(DismissButton, {
      onDismiss: onClose
    }, void 0)]
  }), void 0);
});

function TooltipArrow$1({
  icon,
  style
}) {
  const isDark = useThemeIsDark();
  return jsx(Box, Object.assign({
    className: "sl-popover__tip",
    zIndex: 0,
    pos: "absolute",
    color: isDark ? 'canvas-dialog' : 'canvas-pure',
    style: style
  }, {
    children: jsx(Icon, {
      icon: icon
    }, void 0)
  }), void 0);
}

let idCounter$1 = 1;
const cache = new WeakMap();
function generateKey(items) {
  const cached = cache.get(items);
  if (cached) return cached;
  const id = idCounter$1++;
  if (items) cache.set(items, id);
  return id;
}

/**
 * Pulled from https://github.com/adobe/react-spectrum/blob/main/packages/%40react-stately/collections/src/Item.ts
 * with some minor adjustments.
 */

function Item(props) {
  return null;
} // See examples of getCollectionNode https://github.com/adobe/react-spectrum/search?q=getCollectionNode

Item.getCollectionNode = function* getCollectionNode(props, context) {
  let {
    childItems,
    title,
    children
  } = props;
  let rendered = props.title || props.children;
  let textValue = props.textValue || (typeof rendered === 'string' ? rendered : '') || props['aria-label'] || '';
  yield {
    key: props.id,
    type: 'item',
    props,
    rendered,
    textValue,
    'aria-label': props['aria-label'],
    hasChildNodes: hasChildItems(props),

    *childNodes() {
      if (childItems) {
        for (let child of childItems) {
          if (child && typeof child === 'object') {
            yield {
              value: {
                // generate a key for groups/sections nested inside of items (for menus mostly)
                // @ts-expect-error
                id: typeof child.id !== 'undefined' ? child.id : `${generateKey(child.children)}-subitem`,
                ...child
              }
            };
          } else {
            yield {
              value: child
            };
          }
        }
      } else if (title) {
        let items = [];
        _react.Children.forEach(children, child => {
          items.push({
            // type: 'item', // do not constrain to just item children - sections etc are ok
            element: child
          });
        });
        yield* items;
      }
    }

  };
};

function hasChildItems(props) {
  if (props.hasChildItems !== null) {
    return props.hasChildItems;
  }

  if (props.childItems) {
    return true;
  }

  if (props.title && _react.Children.count(props.children) > 0) {
    return true;
  }

  return false;
}

/**
 * Pulled from https://github.com/adobe/react-spectrum/blob/main/packages/%40react-stately/collections/src/Section.ts
 * with some minor adjustments.
 */

function Section$1(props) {
  return null;
} // See examples of getCollectionNode https://github.com/adobe/react-spectrum/search?q=getCollectionNode

Section$1.getCollectionNode = function* getCollectionNode(props, context) {
  let {
    children,
    id,
    title,
    items
  } = props;
  yield {
    key: typeof id !== 'undefined' ? id : `${generateKey(items)}-section`,
    type: 'section',
    hasChildNodes: true,
    props,
    rendered: title,
    'aria-label': props['aria-label'],

    *childNodes() {
      if (typeof children === 'function') {
        if (!items) {
          throw new Error('props.children was a function but props.items is missing');
        }

        for (let item of items) {
          yield {
            value: item,
            renderer: children
          };
        }
      } else {
        let items = [];
        _react.Children.forEach(children, child => {
          items.push({
            element: child
          });
        });
        yield* items;
      }
    }

  };
};

const useEnhancedEffect = typeof window !== 'undefined' && !process.env.TEST_SSR ? _react.useLayoutEffect : _react.useEffect;
/**
 * NoSsr purposely removes components from the subject of Server Side Rendering (SSR).
 *
 * This component can be useful in a variety of situations:
 * - Escape hatch for broken dependencies not supporting SSR.
 * - Improve the time-to-first paint on the client by only rendering above the fold.
 * - Reduce the rendering time on the server.
 * - Under too heavy server load, you can turn on service degradation.
 */

const NoSsr = props => {
  const {
    children,
    defer = false,
    fallback = null
  } = props;
  const [mountedState, setMountedState] = _react.useState(false);
  useEnhancedEffect(() => {
    if (!defer && !process.env.TEST_SSR) {
      setMountedState(true);
    }
  }, [defer]);
  _react.useEffect(() => {
    if (defer && !process.env.TEST_SSR) {
      setMountedState(true);
    }
  }, [defer]);
  return jsx(Fragment, {
    children: mountedState ? children : fallback
  }, void 0);
};

const isMenuGroup = node => {
  return node && typeof node === 'object' && node['type'] === 'group';
};
const isMenuOptionGroup = node => {
  return node && typeof node === 'object' && node['type'] === 'option_group';
};
const isMenuOption = node => {
  return node && typeof node === 'object' && node.hasOwnProperty('value') && !node['type'];
};
const isMenuDivider = node => {
  return node && typeof node === 'object' && node['type'] === 'divider';
};

const MenuContext = /*#__PURE__*/_react.createContext(null);

class MenuKeyboardDelegate {
  constructor(state) {
    this.expandedKeys = state.expandedKeys;
    this.collection = state.collection;
    this.selectionManager = state.selectionManager;
    this.toggleKey = state.toggleKey;
    this.collapseKey = state.collapseKey;
  }

  getKeyRightOf(key) {
    const {
      selectionManager,
      collection,
      toggleKey
    } = this;
    const item = collection.getItem(key);
    if (!item || !item.hasChildNodes) return;
    toggleKey(key);
    selectionManager.setFocused(true); // return the first key in the nested menu

    const rightKey = this.getFirstKey();
    return rightKey;
  }

  getKeyLeftOf(key) {
    const {
      selectionManager,
      collection,
      collapseKey
    } = this;
    const item = collection.getItem(key);
    if (!item) return;
    let parent = collection.getItem(item.parentKey);
    let parentKey = null;

    while (parentKey === null) {
      if (!parent) return null;

      if (parent.menuLevel === item.menuLevel - 1) {
        parentKey = parent.key;
      } else {
        parent = collection.getItem(parent.parentKey);
      }
    }

    if (parentKey) {
      collapseKey(parentKey);
    }

    selectionManager.setFocusedKey(parentKey);
    selectionManager.setFocused(true); // return the parent key

    return parentKey;
  }

  getKeyAbove(key) {
    const {
      collection
    } = this;
    const deepestExpandedKey = this.getDeepestExpandedKey();
    let keyBefore = collection.getKeyBefore(key);

    while (keyBefore !== null) {
      let item = collection.getItem(keyBefore);

      if ((item === null || item === void 0 ? void 0 : item.type) === 'item' && !item.isDisabled && // only navigate up/down through items in this menu (not nested or parent menus)
      item.parentMenuItemKey === deepestExpandedKey) {
        return keyBefore;
      }

      keyBefore = collection.getKeyBefore(keyBefore);
    }

    return null;
  }

  getKeyBelow(key) {
    const {
      collection
    } = this;
    const deepestExpandedKey = this.getDeepestExpandedKey();
    let keyBelow = collection.getKeyAfter(key);

    while (keyBelow !== null) {
      const item = collection.getItem(keyBelow);

      if ((item === null || item === void 0 ? void 0 : item.type) === 'item' && !item.isDisabled && // only navigate up/down through items in this menu (not nested or parent menus)
      item.parentMenuItemKey === deepestExpandedKey) {
        return keyBelow;
      }

      keyBelow = collection.getKeyAfter(keyBelow);
    }

    return null;
  }

  getFirstKey() {
    const {
      collection
    } = this;
    const deepestExpandedKey = this.getDeepestExpandedKey();
    let key = collection.getFirstKey();

    while (key !== null) {
      const item = collection.getItem(key);

      if ((item === null || item === void 0 ? void 0 : item.type) === 'item' && !item.isDisabled && item.parentMenuItemKey === deepestExpandedKey) {
        return key;
      }

      key = collection.getKeyAfter(key);
    }

    return null;
  }

  getLastKey() {
    const {
      collection
    } = this;
    const deepestExpandedKey = this.getDeepestExpandedKey();
    let key = collection.getLastKey();

    while (key !== null) {
      const item = collection.getItem(key);

      if ((item === null || item === void 0 ? void 0 : item.type) === 'item' && !item.isDisabled && item.parentMenuItemKey === deepestExpandedKey) {
        return key;
      }

      key = collection.getKeyBefore(key);
    }

    return null;
  }

  getDeepestExpandedKey() {
    const {
      expandedKeys
    } = this;
    const keyArray = Array.from(expandedKeys.keys());
    return keyArray[keyArray.length - 1] || null;
  }

}

/**
 * Provides the accessibility implementation for a separator.
 * A separator is a visual divider between two groups of content,
 * e.g. groups of menu items or sections of a page.
 */
function useSeparator(props) {
  let domProps = filterDOMProps(props, {
    labelable: true
  });
  let ariaOrientation; // if orientation is horizontal, aria-orientation default is horizontal, so we leave it undefined
  // if it's vertical, we need to specify it

  if (props.orientation === 'vertical') {
    ariaOrientation = 'vertical';
  } // hr elements implicitly have role = separator and a horizontal orientation


  if (props.elementType !== 'hr') {
    return {
      separatorProps: _extends({}, domProps, {
        role: 'separator',
        'aria-orientation': ariaOrientation
      })
    };
  }

  return {
    separatorProps: domProps
  };
}

const MENU_ITEM_IDENT_WIDTHS = {
  default: '28px',
  lg: '40px'
};
const Internal_MenuItemRow = /*#__PURE__*/forwardRef(function MenuItem({
  title,
  isFocused,
  isActive,
  isDisabled,
  isSelected,
  hasSubmenu,
  isIndented,
  icon,
  iconColor,
  meta,
  href,
  description,
  size = 'default',
  cursor = true,
  ...restProps
}, ref) {
  const isCheckableItem = typeof isSelected !== 'undefined';
  const shouldIndent = isIndented || isCheckableItem || typeof icon !== 'undefined';
  const modality = useInteractionModality();
  const pointerInteraction = modality === 'pointer';
  const isLink = !!href;
  const isExternalLink = isLink && !href.startsWith('/');

  const rowChildren = jsxs(Fragment, {
    children: [shouldIndent && jsx(Box, Object.assign({
      style: {
        width: MENU_ITEM_IDENT_WIDTHS[size],
        fontSize: isCheckableItem ? size === 'lg' ? 12 : 10 : undefined
      },
      flexShrink: 0,
      textAlign: "center",
      "data-testid": "icon"
    }, {
      children: (isSelected || icon) && jsx(Icon, {
        className: "sl-menu-item__icon",
        icon: isSelected ? 'check' : icon,
        style: {
          color: iconColor
        }
      }, void 0)
    }), void 0), jsxs(Box, Object.assign({
      flex: 1,
      w: "full",
      pr: 8,
      className: "sl-menu-item__title-wrapper"
    }, {
      children: [jsx(Box, Object.assign({
        lineHeight: size === 'lg' ? 'relaxed' : undefined,
        textOverflow: "truncate"
      }, {
        children: title
      }), void 0), description && jsx(Box, Object.assign({
        className: "sl-menu-item__description",
        lineHeight: size === 'lg' ? 'relaxed' : undefined,
        color: "light",
        fontSize: size === 'lg' ? 'base' : 'sm',
        whitespace: "normal"
      }, {
        children: description
      }), void 0)]
    }), void 0), isExternalLink ? jsx(Box, Object.assign({
      className: "sl-menu-item__link-icon"
    }, {
      children: jsx(Icon, {
        icon: "external-link-alt",
        size: "sm"
      }, void 0)
    }), void 0) : null, (meta || meta === 0) && jsx(Box, Object.assign({
      className: cn('sl-menu-item__meta', {
        'sl-menu-item__meta-text': typeof meta === 'string' || typeof meta === 'number'
      })
    }, {
      children: meta
    }), void 0), hasSubmenu && jsx(Box, {
      children: jsx(Icon, {
        icon: ['fas', 'caret-right']
      }, void 0)
    }, void 0)]
  }, void 0);

  const rowProps = { ...restProps,
    pl: size === 'lg' ? shouldIndent ? 2 : 5 : shouldIndent ? 1 : 3,
    pr: size === 'lg' ? 4 : 3,
    pt: size === 'lg' ? 2 : 1,
    pb: size === 'lg' ? 2 : 1,
    alignItems: 'center',
    whitespace: 'nowrap',
    fontSize: size === 'lg' ? 'lg' : 'base',
    className: cn('sl-menu-item', {
      'sl-menu-item--has-submenu': hasSubmenu,
      'sl-menu-item--disabled': isDisabled,
      'sl-menu-item--submenu-active': !isFocused && isActive,
      'sl-menu-item--focused': (!pointerInteraction || hasSubmenu) && isFocused
    })
  };

  if (isLink && !isDisabled) {
    return jsx(Link, Object.assign({
      ref: ref,
      href: href,
      target: href && !href.startsWith('/') ? '_blank' : undefined,
      display: "flex",
      cursor: cursor
    }, rowProps, {
      children: rowChildren
    }), void 0);
  }

  return jsx(Flex, Object.assign({
    ref: ref
  }, rowProps, {
    children: rowChildren
  }), void 0);
});

function MenuNodes({
  items,
  autoFocus,
  className,
  ...props
}) {
  const ref = useRef();
  const isDark = useThemeIsDark();
  const {
    state,
    keyboardDelegate,
    size
  } = useContext(MenuContext);
  const {
    // pull color out for typing reasons
    // pull onBlur and onFocus out because react-aria isn't setup to work with portaled submenus
    menuProps: {
      color,
      onBlur: _onBlur,
      onFocus,
      ...menuProps
    }
  } = useMenu( // @ts-expect-error children is not needed
  { ...props,
    autoFocus,
    keyboardDelegate
  }, state, ref);
  const modality = useInteractionModality();
  const pointerInteraction = modality === 'pointer';
  return jsx(Box, Object.assign({
    ref: ref,
    bg: isDark ? 'canvas-dialog' : 'canvas-pure',
    w: "full",
    style: {
      minWidth: 150,
      maxWidth: 400
    },
    py: size === 'lg' ? 3 : 2,
    className: cn(className, {
      'sl-menu--pointer-interactions': pointerInteraction
    }),
    cursor: true,
    overflowY: "auto",
    display: "inline-block",
    noFocusRing: true
  }, menuProps, {
    children: Array.from(items).map((item, i) => {
      if (isMenuGroup(item.value) || isMenuOptionGroup(item.value)) {
        return jsx(MenuSectionWrapper, {
          section: item,
          state: state
        }, item.key || i);
      }

      if (isMenuDivider(item.value)) {
        return jsx(Divider$1, {}, item.key || i);
      }

      return jsx(MenuItemWrapper, {
        item: item,
        state: state
      }, item.key || i);
    })
  }), void 0);
}

function Divider$1() {
  const {
    separatorProps: {
      color,
      ...separatorProps
    }
  } = useSeparator({
    elementType: 'div'
  });
  const {
    size
  } = useContext(MenuContext);
  return jsx(Box, Object.assign({
    my: size === 'lg' ? 2.5 : 2,
    borderT: true
  }, separatorProps), void 0);
}

function MenuSectionWrapper({
  section,
  state
}) {
  const {
    itemProps,
    headingProps: {
      color,
      ...headingProps
    },
    groupProps
  } = useMenuSection({
    heading: section.rendered,
    'aria-label': section['aria-label']
  });
  const {
    size,
    closeOnPress
  } = useContext(MenuContext);
  let value;
  let onChange;

  if (isMenuOptionGroup(section.value)) {
    value = section.value.value;
    onChange = section.value.onChange;
  }

  const childNodes = Array.from(section.childNodes); // do not render the section if it has no children

  if (!childNodes.length) return null;
  return jsxs(Fragment, {
    children: [!section.firstInMenu && jsx(Divider$1, {}, void 0), jsxs("div", Object.assign({}, itemProps, {
      children: [section.rendered && jsx(Box, Object.assign({}, headingProps, {
        pl: size === 'lg' ? 5 : 3,
        pt: size === 'lg' ? 1 : 0.5,
        pb: size === 'lg' ? 1.5 : 1,
        pr: 8,
        textTransform: "uppercase",
        color: "light",
        cursor: true,
        fontSize: size === 'lg' ? 'base' : 'sm'
      }, {
        children: section.rendered
      }), void 0), jsx("div", Object.assign({}, groupProps, {
        children: childNodes.map((node, i) => {
          if (isMenuDivider(node.value)) {
            return jsx(Divider$1, {}, node.key || i);
          }

          if (isMenuOption(node.value) && isMenuOptionGroup(section.value)) {
            node.value = {
              closeOnPress: typeof closeOnPress !== 'undefined' ? closeOnPress : false,
              ...node.value,
              isChecked: value === node.value.value,
              onPress: () => {
                if (isMenuOption(node.value)) {
                  onChange(node.value.value);
                }
              }
            };
          } // @ts-expect-error


          return jsx(MenuItemWrapper, {
            item: node,
            state: state,
            isRadio: !!onChange
          }, node.key || i);
        })
      }), void 0)]
    }), void 0)]
  }, void 0);
}

function MenuItemWrapper({
  item,
  state,
  isRadio
}) {
  const ref = useRef();
  const {
    key,
    hasChildNodes,
    isDisabled
  } = item;
  const {
    useIsFocusedKey,
    useIsExpandedKey,
    toggleKey
  } = state;
  const {
    onClose,
    closeOnPress: globalCloseOnPress,
    size,
    cursor
  } = useContext(MenuContext);
  const hasSubmenu = hasChildNodes;
  const {
    isChecked: isSelected,
    title,
    value,
    onPress,
    label,
    isActive,
    closeOnPress,
    afterRestoreFocus,
    ...restItemProps
  } = item.value;
  const isExpanded = useIsExpandedKey(key);
  const isFocused = useIsFocusedKey(key);
  let closeOnSelect = false; // priority to the value set on the item itself, if one is set

  if (typeof closeOnPress !== 'undefined') {
    closeOnSelect = closeOnPress;
  } else {
    // else default to true when NOT in checked/radio context and NOT a submenu, otherwise the global default
    closeOnSelect = typeof isSelected !== 'undefined' ? globalCloseOnPress : !hasSubmenu;
  } // links use `onClick` handlers, while most of menu works off of `onmouseup`. This dynamic causes the onClose()
  // logic to teardown the menu before link `onClick` event is triggered, causing the link to not work
  // disable closeOnSelect for links to prevent this - we call onClose in the onAction handler below for links.


  const isLink = !!item.value.href;

  if (isLink) {
    closeOnSelect = false;
  }

  const onAction = useCallback(() => {
    if (onPress) {
      if (afterRestoreFocus) {
        requestAnimationFrame(() => setTimeout(() => onPress(key), 10));
      } else {
        onPress(key);
      }
    }

    if (isLink && onClose) {
      setTimeout(onClose, 0);
    }
  }, [onPress, isLink, onClose, afterRestoreFocus, key]);
  const handleHoverChange = _react.useCallback(() => {
    toggleKey(key);
  }, [key, toggleKey]);
  const {
    hoverProps
  } = useHover({
    onHoverStart: handleHoverChange,
    isDisabled
  });
  const {
    menuItemProps
  } = useMenuItem({
    key,
    isSelected,
    isDisabled,
    onAction,
    closeOnSelect,
    onClose
  }, state, ref);
  let role = 'menuitem';

  if (isRadio) {
    role = 'menuitemradio';
  } else if (typeof isSelected !== 'undefined') {
    role = 'menuitemcheckbox';
  }

  const ariaProps = {
    role
  };

  if (typeof isSelected !== 'undefined') {
    ariaProps['aria-checked'] = isSelected;
  }

  const {
    color,
    ...restProps
  } = mergeProps(restItemProps, menuItemProps, hoverProps);
  const menuItemRowProps = { ...restProps,
    ...ariaProps,
    title: title || value,
    isFocused,
    isActive: isActive || isExpanded,
    isSelected,
    isDisabled,
    size,
    cursor
  };

  if (!hasSubmenu) {
    return jsx(Internal_MenuItemRow, Object.assign({}, menuItemRowProps, {
      ref: ref
    }), void 0);
  }

  return jsx(SubmenuItem, {
    item: item,
    menuItemRowProps: menuItemRowProps,
    menuItemRef: ref,
    isExpanded: isExpanded,
    label: label,
    onClose: onClose
  }, void 0);
}

function SubmenuItem({
  item,
  menuItemRowProps,
  menuItemRef,
  isExpanded,
  label,
  onClose
}) {
  const triggerId = useId();
  const submenuId = useId();
  const {
    providerRef
  } = useMosaicContext();
  const ariaTriggerProps = {
    'aria-haspopup': true,
    'aria-expanded': isExpanded ? 'true' : 'false'
  };

  if (isExpanded) {
    ariaTriggerProps['aria-controls'] = submenuId;
  }

  return jsxs(Fragment, {
    children: [jsx(Internal_MenuItemRow, Object.assign({}, menuItemRowProps, ariaTriggerProps, {
      id: triggerId,
      hasSubmenu: true,
      ref: menuItemRef
    }), void 0), isExpanded ? jsx(Popover, Object.assign({
      isOpen: true,
      placement: "right top",
      triggerRef: menuItemRef,
      boundaryElement: providerRef.current,
      contain: false,
      autoFocus: false,
      restoreFocus: false,
      appearance: "minimal",
      offset: 0,
      crossOffset: menuItemRowProps.size === 'lg' ? -12 : -8,
      onClose: onClose,
      type: "menu",
      isNonModal: true
    }, {
      children: jsx(MenuNodes, {
        id: submenuId,
        className: "sl-menu sl-menu--submenu",
        "aria-label": label || `${menuItemRowProps.title} submenu`,
        items: item.childNodes,
        "aria-labelledby": triggerId
      }, void 0)
    }), void 0) : null]
  }, void 0);
}

// Adapted from https://github.com/adobe/react-spectrum/blob/main/packages/%40react-stately/tree/src/TreeCollection.ts
class MenuCollection {
  constructor(nodes) {
    this.keyMap = new Map();
    this.iterable = nodes;

    let visit = (node, firstInMenu, menuLevel, parentMenuItemKey) => {
      node.firstInMenu = firstInMenu;
      node.menuLevel = menuLevel;
      node.parentMenuItemKey = parentMenuItemKey;
      node.isDisabled = node.value.isDisabled || node.value.type === 'divider';
      this.keyMap.set(node.key, node);

      if (node.childNodes) {
        let first = true;

        for (let child of node.childNodes) {
          visit(child, first, node.type === 'item' ? menuLevel + 1 : menuLevel, node.type === 'item' ? node.key : parentMenuItemKey);
          first = false;
        }
      }
    };

    let first = true;

    for (let node of nodes) {
      visit(node, first, 1, null);
      first = false;
    }

    let last;
    let index = 0;

    for (let [key, node] of this.keyMap) {
      if (last) {
        last.nextKey = key;
        node.prevKey = last.key;
      } else {
        this.firstKey = key;
        node.prevKey = undefined;
      }

      if (node.type === 'item') {
        node.index = index++;
      }

      last = node; // Set nextKey as undefined since this might be the last node
      // If it isn't the last node, last.nextKey will properly set at start of new loop

      last.nextKey = undefined;
    }

    this.lastKey = last === null || last === void 0 ? void 0 : last.key;
  }

  *[Symbol.iterator]() {
    yield* this.iterable;
  }

  get size() {
    return this.keyMap.size;
  }

  at(pos) {
    let i = 0;

    for (const item of this) {
      if (i++ === pos) {
        return item;
      }
    }

    return;
  }

  getKeys() {
    return this.keyMap.keys();
  }

  getKeyBefore(key) {
    let node = this.keyMap.get(key);
    return node ? node.prevKey : null;
  }

  getKeyAfter(key) {
    let node = this.keyMap.get(key);
    return node ? node.nextKey : null;
  }

  getFirstKey() {
    return this.firstKey;
  }

  getLastKey() {
    return this.lastKey;
  }

  getItem(key) {
    return this.keyMap.get(key);
  }

}

// Originally adapated from https://github.com/adobe/react-spectrum/tree/main/packages/%40react-stately/selection

/**
 * A Selection is a special Set containing Keys, which also has an anchor
 * and current selected key for use when range selecting.
 */
class Selection extends Set {
  constructor(keys, anchorKey, currentKey) {
    super(keys);

    if (keys instanceof Selection) {
      this.anchorKey = anchorKey || keys.anchorKey;
      this.currentKey = currentKey || keys.currentKey;
    } else {
      this.anchorKey = anchorKey;
      this.currentKey = currentKey;
    }
  }

}

// Originally adapated from https://github.com/adobe/react-spectrum/tree/main/packages/%40react-stately/selection
/**
 * Manages state for multiple selection and focus in a collection.
 */

function useMultipleSelectionState(props) {
  let {
    selectionMode = 'none',
    disallowEmptySelection
  } = props; // We want synchronous updates to `isFocused` and `focusedKey` after their setters are called.
  // But we also need to trigger a react re-render. So, we have both a ref (sync) and state (async).

  const isFocusedRef = useRef(false);
  const focusedKeyRef = useRef(null);
  const childFocusStrategyRef = useRef(null);
  const selectedKeysProp = useMemo(() => convertSelection(props.selectedKeys), [props.selectedKeys]);
  const defaultSelectedKeys = useMemo(() => convertSelection(props.defaultSelectedKeys, new Selection()), [props.defaultSelectedKeys]);
  const [selectedKeys, setSelectedKeys] = useControlledState(selectedKeysProp, defaultSelectedKeys, props.onSelectionChange);
  const disabledKeysProp = useMemo(() => props.disabledKeys ? new Set(props.disabledKeys) : new Set(), [props.disabledKeys]);
  const useStore = useRef(create(set => ({
    isFocused: false,
    focusedKey: null,
    setFocused: f => set(state => {
      isFocusedRef.current = f;
      return { ...state,
        isFocusedRef: f
      };
    }),
    setFocusedKey: (k, childFocusStrategy = 'first') => set(state => {
      focusedKeyRef.current = k;
      childFocusStrategyRef.current = childFocusStrategy;
      return { ...state,
        focusedKey: k
      };
    })
  })));
  const [setFocused, setFocusedKey] = useStore.current(state => [state.setFocused, state.setFocusedKey], shallow);

  function useIsFocusedKey(key) {
    const cb = useCallback(state => state.focusedKey === key, [key]);
    if (!useStore.current) return false;
    return useStore.current(cb);
  }

  function useFocusedKey() {
    const cb = useCallback(state => state.focusedKey, []);
    if (!useStore.current) return false;
    return useStore.current(cb);
  }

  return {
    useIsFocusedKey,
    useFocusedKey,
    selectionMode,
    disallowEmptySelection,

    get isFocused() {
      return isFocusedRef.current;
    },

    setFocused,

    get focusedKey() {
      return focusedKeyRef.current;
    },

    get childFocusStrategy() {
      return childFocusStrategyRef.current;
    },

    setFocusedKey,
    selectedKeys,
    setSelectedKeys,
    disabledKeys: disabledKeysProp
  };
}

function convertSelection(selection, defaultValue) {
  if (!selection) {
    return defaultValue;
  }

  return selection === 'all' ? 'all' : new Selection(selection);
}

// Adapted from https://github.com/adobe/react-spectrum/blob/main/packages/%40react-stately/tree/src/useTreeState.ts
const disabledKeys = new Set();
/**
 * Provides state management for tree-like components. Handles building a collection
 * of items from props, item expanded state, and manages multiple selection state.
 */

function useMenuState(props) {
  // stable expandedKeys set for use in keyboard delegate, etc
  const expandedKeysRef = useRef(new Set());
  const selectionState = useMultipleSelectionState(props);
  const tree = useCollection$1(props, nodes => new MenuCollection(nodes), null, []);
  const selectionManager = useMemo(() => new SelectionManager(tree, selectionState), [selectionState, tree]);
  const useStore = useRef(create(set => ({
    // mirrored expanded keys set for use in observers in components etc
    expandedKeys: new Set(),
    toggleKey: k => {
      const newSet = new Set(toggleKey(tree, expandedKeysRef.current, k));
      return set(state => ({ ...state,
        expandedKeys: newSet
      }));
    },
    collapseKey: k => {
      const newSet = new Set(collapseKey(expandedKeysRef.current, k));
      return set(state => ({ ...state,
        expandedKeys: newSet
      }));
    },
    collapseAllKeys: () => {
      expandedKeysRef.current = new Set();
      return set(state => ({ ...state,
        expandedKeys: expandedKeysRef.current
      }));
    }
  })));
  const [onToggle, onCollapse, onCollapseAllKeys] = useStore.current(state => [state.toggleKey, state.collapseKey, state.collapseAllKeys], shallow);

  function useIsExpandedKey(key) {
    const cb = useCallback(state => state.expandedKeys.has(key), [key]);
    if (!useStore.current) return false;
    return useStore.current(cb);
  } // Reset focused key if that item is deleted from the collection.


  useEffect(() => {
    if (selectionState.focusedKey != null && !tree.getItem(selectionState.focusedKey)) {
      selectionState.setFocusedKey(null);
    } // eslint-disable-next-line react-hooks/exhaustive-deps

  }, [tree, selectionState.focusedKey]);
  return {
    useIsFocusedKey: selectionState.useIsFocusedKey,
    useFocusedKey: selectionState.useFocusedKey,
    useIsExpandedKey,
    collection: tree,
    expandedKeys: expandedKeysRef.current,
    disabledKeys,
    toggleKey: onToggle,
    collapseKey: onCollapse,
    collapseAllKeys: onCollapseAllKeys,
    selectionManager
  };
}

function toggleKey(tree, set, key) {
  const parents = [];
  const item = tree.getItem(key);
  const hasChildNodes = item === null || item === void 0 ? void 0 : item.hasChildNodes;
  let parent = (item === null || item === void 0 ? void 0 : item.parentKey) ? tree.getItem(item.parentKey) : null;

  while (parent) {
    parents.unshift(parent.key);

    if (parent.parentKey) {
      parent = tree.getItem(parent.parentKey);
    } else {
      parent = null;
    }
  }

  for (const expandedKey of set) {
    if (!parents.includes(expandedKey)) {
      set.delete(expandedKey);
    }
  } // if item has child nodes and is not yet expanded, expand!


  if (hasChildNodes && !set.has(key)) {
    set.add(key);
  }

  return set;
}

function collapseKey(set, key) {
  if (set.has(key)) {
    set.delete(key);
  }

  return set;
}

function MenuList({
  items,
  onClose,
  closeOnPress,
  size,
  cursor,
  ...props
}) {
  const state = useMenuState({
    items: items,
    children: MenuListChildren
  });
  const keyboardDelegate = useMemo(() => new MenuKeyboardDelegate(state), [state]);
  const handleOnClose = useCallback(() => {
    // make sure to collapse all submenus when menu close is triggered
    state.collapseAllKeys();
    if (onClose) onClose();
  }, [onClose, state]);
  return jsx(NoSsr, {
    children: jsx(MenuContext.Provider, Object.assign({
      value: {
        state,
        keyboardDelegate,
        closeOnPress,
        onClose: handleOnClose,
        size,
        cursor
      }
    }, {
      children: jsx(MenuNodes, Object.assign({}, props, {
        className: "sl-menu",
        autoFocus: true,
        items: state.collection
      }), void 0)
    }), void 0)
  }, void 0);
}

function MenuOption(item) {
  return jsx(Item, {
    id: item.id || item.value,
    title: item.value || item.title
  }, item.id || item.value || item.title);
}

let idCounter = 1;

function MenuListChildren(item) {
  if (isMenuGroup(item)) {
    return jsx(Section$1, {
      id: item.id,
      title: item.title,
      // @ts-expect-error
      items: item.children || [],
      // eslint-disable-next-line react/no-children-prop
      children: MenuListChildren
    }, item.id || item.title);
  }

  if (isMenuOptionGroup(item)) {
    return jsx(Section$1, {
      id: item.id,
      title: item.title,
      items: item.children || [],
      // eslint-disable-next-line react/no-children-prop
      children: MenuOption
    }, item.id || item.title);
  }

  if (isMenuOption(item)) {
    return MenuOption(item);
  }

  if (isMenuDivider(item)) {
    return jsx(Item, {}, idCounter++);
  }

  return jsx(Item, {
    id: item.id,
    title: item.title,
    childItems: item.children,
    hasChildItems: !!(item.children && item.children.length),
    // eslint-disable-next-line react/no-children-prop
    children: MenuListChildren
  }, item.id || item.title);
}

const openMenus = {};
let menuId = 0;
function Menu({
  renderTrigger,
  placement = 'bottom',
  hideArrow,
  onClose,
  closeOnPress = false,
  'aria-label': ariaLabel,
  matchTriggerWidth,
  ...props
}) {
  const id = useMemo(() => `${++menuId}`, []);
  useEffect(() => {
    // make sure to cleanup on unmount in case the menu is unmounted via a method other than official close handler
    return () => {
      if (openMenus[id]) delete openMenus[id];
    };
  }, [id]); // only one menu allowed open at a time

  const closeOpenMenus = useCallback(() => {
    for (let hideMenuId in openMenus) {
      if (hideMenuId !== id) {
        openMenus[hideMenuId](true);
        delete openMenus[hideMenuId];
      }
    }
  }, [id]);

  const onOpenChange = isOpen => {
    if (isOpen) {
      closeOpenMenus();
      trackOpenMenu();
    } else {
      if (onClose) onClose();
    }
  }; // Create state based on the incoming props


  const state = useMenuTriggerState({ ...props,
    onOpenChange,
    closeOnSelect: closeOnPress
  });

  function trackOpenMenu() {
    openMenus[id] = state.close;
  } // Get props for the menu trigger and menu elements


  const ref = useRef();
  const {
    menuTriggerProps,
    menuProps
  } = useMenuTrigger({
    type: 'menu'
  }, state, ref);
  const triggerElem = runIfFn(renderTrigger, {
    isOpen: state.isOpen
  });
  return jsxs(Fragment, {
    children: [jsx(PressResponder, Object.assign({
      "aria-label": ariaLabel
    }, menuTriggerProps, {
      ref: ref,
      isPressed: state.isOpen
    }, {
      children: triggerElem
    }), void 0), state.isOpen ? jsx(Popover, Object.assign({
      isOpen: true,
      placement: placement,
      triggerRef: ref,
      appearance: "minimal",
      onClose: state.close,
      showArrow: !hideArrow,
      autoFocus: true,
      restoreFocus: true,
      contain: true,
      type: "menu",
      isNonModal: true,
      matchTriggerWidth: matchTriggerWidth
    }, {
      children: jsx(MenuList, Object.assign({}, props, menuProps, {
        "aria-labelleddby": ariaLabel,
        closeOnPress: closeOnPress,
        onClose: state.close
      }), void 0)
    }), void 0) : null]
  }, void 0);
}

const PanelContent = ({
  children,
  ...props
}) => jsx(Box, Object.assign({
  p: 4,
  className: "sl-panel__content"
}, props, {
  children: children
}), void 0);

const titlebarVariants = {
  default: {
    bg: 'canvas-200',
    borderColor: {
      default: 'input',
      focus: 'primary'
    },
    color: 'body'
  },
  minimal: {
    pos: 'relative',
    fontWeight: 'medium'
  },
  outlined: {
    borderColor: {
      default: 'input',
      focus: 'primary'
    }
  }
};
const iconVariants = {
  default: {
    mr: 1.5
  },
  minimal: {
    pos: 'absolute',
    left: -4,
    color: 'body',
    fontWeight: 'normal'
  },
  outlined: {
    mr: 1.5
  }
};
const PanelTitlebar = /*#__PURE__*/memo(({
  children,
  icon,
  appearance = 'default',
  rightComponent,
  onClick,
  bg,
  tabIndex,
  ...props
}) => {
  const isPadded = appearance === 'default' || appearance === 'outlined';
  return jsx(FocusRing, Object.assign({
    focusRingClass: "sl-focus-ring"
  }, {
    children: jsxs(Flex, Object.assign({
      className: "sl-panel__titlebar",
      pos: "relative",
      zIndex: {
        focus: 10
      },
      align: "center",
      fontSize: "base",
      userSelect: "none",
      lineHeight: "none",
      pl: isPadded ? icon ? 3 : 4 : undefined,
      pr: isPadded ? rightComponent ? 3 : 4 : undefined
    }, titlebarVariants[appearance], {
      bg: bg || titlebarVariants[appearance].bg
    }, props, {
      tabIndex: tabIndex
    }, {
      children: [jsxs(Flex, Object.assign({
        flex: 1,
        align: "center",
        h: "lg",
        onClick: onClick
      }, {
        children: [icon && jsx(Flex, Object.assign({}, iconVariants[appearance], {
          align: "center"
        }, {
          children: icon
        }), void 0), children]
      }), void 0), rightComponent]
    }), void 0)
  }), void 0);
});

const Panel = ({
  appearance = 'default',
  id,
  className,
  children,
  isCollapsible = true,
  isOpen: isOpenProp,
  defaultIsOpen = false,
  onChange,
  rounded = appearance === 'outlined' ? true : undefined,
  ...extraProps
}) => {
  const [isOpen, setIsOpen] = useControllableState({
    value: isOpenProp,
    defaultValue: defaultIsOpen,
    onChange,
    propsMap: {
      value: 'isOpen',
      defaultValue: 'defaultIsOpen',
      onChange: 'onChange'
    }
  });
  const isMinimal = appearance === 'minimal';
  const isOutlined = appearance === 'outlined';
  const isPanelOpen = !isCollapsible || isCollapsible && isOpen;
  const handleChange = _react.useCallback(() => {
    if (!isCollapsible) return;
    setIsOpen(!isOpen);
  }, [isCollapsible, isOpen, setIsOpen]);
  const handleKeyDown = _react.useCallback(e => {
    if (!isCollapsible) return;

    if (e.keyCode === Key.Space || e.keyCode === Key.Enter) {
      e.preventDefault();
      handleChange();
    }
  }, [handleChange, isCollapsible]);
  const [titlebarElement, ...contentElements] = _react.Children.toArray(children);

  if (! /*#__PURE__*/_react.isValidElement(titlebarElement) || /*#__PURE__*/_react.isValidElement(titlebarElement) && titlebarElement.type !== PanelTitlebar) {
    throw new Error('Panel.Titlebar must be the first child in a Panel');
  }

  let icon;

  if (isCollapsible) {
    if (isMinimal || isOutlined) {
      icon = isPanelOpen ? 'chevron-down' : 'chevron-right';
    } else {
      icon = ['fas', isPanelOpen ? 'caret-down' : 'caret-right'];
    }
  }

  const titlebarComponent = /*#__PURE__*/_react.cloneElement(titlebarElement, {
    icon: icon ? jsx(Icon, {
      icon: icon,
      fixedWidth: true,
      size: isMinimal ? 'xs' : isOutlined ? 'sm' : undefined
    }, void 0) : undefined,
    role: isCollapsible ? 'button' : undefined,
    'aria-expanded': isCollapsible ? isPanelOpen : undefined,
    'aria-controls': isCollapsible ? id : undefined,
    cursor: isCollapsible ? 'pointer' : undefined,
    tabIndex: isCollapsible ? 0 : undefined,
    appearance,
    onClick: handleChange,
    onKeyDown: handleKeyDown
  });
  return jsxs(Box, Object.assign({
    w: "full",
    className: cn('sl-panel', 'sl-outline-none', className),
    overflowX: !isMinimal && rounded ? 'hidden' : undefined,
    overflowY: !isMinimal && rounded ? 'hidden' : undefined,
    rounded: rounded ? 'lg' : undefined,
    border: isOutlined ? true : undefined
  }, extraProps, {
    children: [titlebarComponent, isPanelOpen ? jsx(Box, Object.assign({
      className: "sl-panel__content-wrapper",
      bg: isMinimal || isOutlined ? undefined : 'canvas-100',
      id: isCollapsible ? id : undefined,
      role: isCollapsible ? 'region' : undefined,
      borderT: isOutlined ? true : undefined
    }, {
      children: contentElements
    }), void 0) : null]
  }), void 0);
};
Panel.Titlebar = PanelTitlebar;
Panel.Content = PanelContent;

const defaultElement$3 = 'p';
const sizes$3 = {
  leading: {
    fontSize: 'paragraph-leading',
    lineHeight: 'paragraph-leading'
  },
  default: {
    fontSize: 'paragraph',
    lineHeight: 'paragraph'
  },
  small: {
    fontSize: 'paragraph-small',
    lineHeight: 'paragraph-small'
  },
  tiny: {
    fontSize: 'paragraph-tiny',
    lineHeight: 'paragraph-tiny'
  }
};
const Paragraph = /*#__PURE__*/memo( /*#__PURE__*/forwardRef(({
  size = 'default',
  ...restProps
}, ref) => {
  /**
   * Explicitely do not allow end user to override font and color... Paragraph should only be used for prose, not UI.
   */
  return jsx(Box, Object.assign({
    as: defaultElement$3,
    ref: ref
  }, sizes$3[size], restProps, {
    fontFamily: "prose",
    color: "paragraph"
  }), void 0);
}));

const Prose = /*#__PURE__*/memo(function Prose({
  className,
  ...props
}) {
  return jsx(Box, Object.assign({
    className: cn('sl-prose', className)
  }, props), void 0);
});

function MosaicProvider(props) {
  return jsx(SSRProvider, {
    children: jsx(MosaicInnerProvider, Object.assign({}, props), void 0)
  }, void 0);
}

function MosaicInnerProvider({
  children,
  className,
  style,
  ...mosaicContext
}) {
  const providerId = `mosaic-provider-${useId()}`;
  const providerRef = useRef();
  return jsx("div", Object.assign({
    className: cn(className),
    style: style,
    id: providerId,
    ref: providerRef
  }, {
    children: jsx(OverlayProvider, Object.assign({
      className: cn(className),
      style: style
    }, {
      children: jsx(MosaicContext.Provider, Object.assign({
        value: Object.assign({}, defaultMosaicContext, mosaicContext, {
          providerId,
          providerRef
        })
      }, {
        children: children
      }), void 0)
    }), void 0)
  }), void 0);
}

/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */
const $a7d0e5df3871fb1bfdb437cffdabab2a$export$radioGroupNames = new WeakMap();

/**
 * Provides the behavior and accessibility implementation for an individual
 * radio button in a radio group.
 * @param props - Props for the radio.
 * @param state - State for the radio group, as returned by `useRadioGroupState`.
 * @param ref - Ref to the HTML input element.
 */
function useRadio(props, state, ref) {
  let {
    value,
    isRequired,
    children,
    'aria-label': ariaLabel,
    'aria-labelledby': ariaLabelledby
  } = props;
  const isDisabled = props.isDisabled || state.isDisabled; // Individual radios cannot be readonly

  const isReadOnly = state.isReadOnly;
  let hasChildren = children != null;
  let hasAriaLabel = ariaLabel != null || ariaLabelledby != null;

  if (!hasChildren && !hasAriaLabel) {
    console.warn('If you do not provide children, you must specify an aria-label for accessibility');
  }

  let checked = state.selectedValue === value;

  let onChange = e => {
    e.stopPropagation();
    state.setSelectedValue(value);
  };

  let {
    pressProps
  } = usePress({
    isDisabled
  });
  let {
    focusableProps
  } = useFocusable(mergeProps(props, {
    onFocus: () => state.setLastFocusedValue(value)
  }), ref);
  let interactions = mergeProps(pressProps, focusableProps);
  let domProps = filterDOMProps(props, {
    labelable: true
  });
  let tabIndex = state.lastFocusedValue === value || state.lastFocusedValue == null ? 0 : -1;

  if (isDisabled) {
    tabIndex = undefined;
  }

  return {
    inputProps: mergeProps(domProps, _extends({}, interactions, {
      type: 'radio',
      name: $a7d0e5df3871fb1bfdb437cffdabab2a$export$radioGroupNames.get(state),
      tabIndex,
      disabled: isDisabled,
      'aria-readonly': isReadOnly || undefined,
      required: isRequired,
      checked,
      value,
      onChange
    }))
  };
}

/**
 * Provides the behavior and accessibility implementation for a radio group component.
 * Radio groups allow users to select a single item from a list of mutually exclusive options.
 * @param props - Props for the radio group.
 * @param state - State for the radio group, as returned by `useRadioGroupState`.
 */
function useRadioGroup(props, state) {
  let {
    name,
    validationState,
    isReadOnly,
    isRequired,
    isDisabled,
    orientation = 'vertical'
  } = props;
  let {
    direction
  } = useLocale();
  let {
    labelProps,
    fieldProps
  } = useLabel(_extends({}, props, {
    // Radio group is not an HTML input element so it
    // shouldn't be labeled by a <label> element.
    labelElementType: 'span'
  }));
  let domProps = filterDOMProps(props, {
    labelable: true
  }); // When the radio group loses focus, reset the focusable radio to null if
  // there is no selection. This allows tabbing into the group from either
  // direction to go to the first or last radio.

  let {
    focusWithinProps
  } = useFocusWithin({
    onBlurWithin() {
      if (!state.selectedValue) {
        state.setLastFocusedValue(null);
      }
    }

  });

  let onKeyDown = e => {
    let nextDir;

    switch (e.key) {
      case 'ArrowRight':
        if (direction === 'rtl' && orientation !== 'vertical') {
          nextDir = 'prev';
        } else {
          nextDir = 'next';
        }

        break;

      case 'ArrowLeft':
        if (direction === 'rtl' && orientation !== 'vertical') {
          nextDir = 'next';
        } else {
          nextDir = 'prev';
        }

        break;

      case 'ArrowDown':
        nextDir = 'next';
        break;

      case 'ArrowUp':
        nextDir = 'prev';
        break;

      default:
        return;
    }

    e.preventDefault();
    let walker = getFocusableTreeWalker(e.currentTarget, {
      from: e.target
    });
    let nextElem;

    if (nextDir === 'next') {
      nextElem = walker.nextNode();

      if (!nextElem) {
        walker.currentNode = e.currentTarget;
        nextElem = walker.firstChild();
      }
    } else {
      nextElem = walker.previousNode();

      if (!nextElem) {
        walker.currentNode = e.currentTarget;
        nextElem = walker.lastChild();
      }
    }

    if (nextElem) {
      // Call focus on nextElem so that keyboard navigation scrolls the radio into view
      nextElem.focus();
      state.setSelectedValue(nextElem.value);
    }
  };

  let groupName = useId(name);
  $a7d0e5df3871fb1bfdb437cffdabab2a$export$radioGroupNames.set(state, groupName);
  return {
    radioGroupProps: mergeProps(domProps, _extends({
      // https://www.w3.org/TR/wai-aria-1.2/#radiogroup
      role: 'radiogroup',
      onKeyDown,
      'aria-invalid': validationState === 'invalid' || undefined,
      'aria-errormessage': props['aria-errormessage'],
      'aria-readonly': isReadOnly || undefined,
      'aria-required': isRequired || undefined,
      'aria-disabled': isDisabled || undefined,
      'aria-orientation': orientation
    }, fieldProps, focusWithinProps)),
    labelProps
  };
}

const RadioContext = /*#__PURE__*/_react.createContext(undefined);
function useRadioContext() {
  return _react.useContext(RadioContext);
}

const variants$2 = {
  default: {
    stroke: 'var(--color-text)',
    active: {
      stoke: 'var(--color-primary)'
    }
  },
  success: {
    stroke: 'var(--color-success)',
    color: 'success-dark',
    active: {
      stoke: 'var(--color-success)'
    }
  },
  warning: {
    stroke: 'var(--color-warning)',
    color: 'warning-dark',
    active: {
      stoke: 'var(--color-warning)'
    }
  },
  danger: {
    stroke: 'var(--color-danger)',
    color: 'danger-dark',
    active: {
      stoke: 'var(--color-danger)'
    }
  }
};
const sizes$2 = {
  lg: {
    fontSize: 'xl',
    svgHeight: 16,
    svgWidth: 16,
    svgStrokeWidth: 2
  },
  md: {
    fontSize: 'lg',
    svgHeight: 14,
    svgWidth: 14,
    svgStrokeWidth: 2
  },
  sm: {
    fontSize: 'base',
    svgHeight: 12,
    svgWidth: 12,
    svgStrokeWidth: 2
  }
};

const Radio = /*#__PURE__*/forwardRef(function Radio({
  disabled,
  ...props
}, ref) {
  const {
    children
  } = props;
  const isDisabled = props.isDisabled !== void 0 ? props.isDisabled : disabled;
  const state = useRadioContext();
  const fallbackRef = useRef();
  const inputRef = ref || fallbackRef;
  const {
    inputProps
  } = useRadio({ ...props,
    isDisabled
  }, state, inputRef);
  const {
    name,
    size,
    intent
  } = props;
  const {
    isFocusVisible,
    focusProps
  } = useFocusRing();
  const isSelected = state.selectedValue === props.value;
  const strokeWidth = isSelected ? sizes$2[size].svgStrokeWidth * 2 : sizes$2[size].svgStrokeWidth;
  inputProps.name = name !== null && name !== void 0 ? name : inputProps.name;
  return jsxs(Flex, Object.assign({
    as: "label",
    alignItems: "center",
    className: cn('sl-radio-group__radio', {
      'sl-radio-group__radio--disabled': isDisabled
    })
  }, {
    children: [jsx(VisuallyHidden, {
      children: jsx("input", Object.assign({}, inputProps, focusProps, {
        ref: inputRef
      }), void 0)
    }, void 0), jsx(Flex, Object.assign({
      flexDirection: 'col',
      justifyContent: 'center'
    }, {
      children: jsx("svg", Object.assign({
        width: sizes$2[size].svgWidth,
        height: sizes$2[size].svgHeight,
        "aria-hidden": "true",
        style: {
          marginRight: 4
        },
        className: isFocusVisible ? 'sl-svg-focus' : ''
      }, {
        children: jsx("circle", {
          cx: sizes$2[size].svgWidth / 2,
          cy: sizes$2[size].svgHeight / 2,
          r: sizes$2[size].svgHeight / 3 - 1,
          fill: "var(--color-canvas)",
          strokeWidth: strokeWidth,
          stroke: isSelected ? variants$2[intent].active.stoke : variants$2[intent].stroke
        }, void 0)
      }), void 0)
    }), void 0), jsx(Box, Object.assign({
      fontSize: sizes$2[size].fontSize,
      fontWeight: 'semibold'
    }, {
      children: children
    }), void 0)]
  }), void 0);
});

let $eaf77ba5e143129c6bb329a6e66020d3$var$instance = Math.round(Math.random() * 10000000000);
let $eaf77ba5e143129c6bb329a6e66020d3$var$i = 0;
/**
 * Provides state management for a radio group component. Provides a name for the group,
 * and manages selection and focus state.
 */

function useRadioGroupState(props) {
  // Preserved here for backward compatibility. React Aria now generates the name instead of stately.
  let name = useMemo(() => props.name || "radio-group-" + $eaf77ba5e143129c6bb329a6e66020d3$var$instance + "-" + ++$eaf77ba5e143129c6bb329a6e66020d3$var$i, [props.name]);
  let [selectedValue, setSelected] = useControlledState(props.value, props.defaultValue, props.onChange);
  let [lastFocusedValue, setLastFocusedValue] = useState(null);

  let setSelectedValue = value => {
    if (!props.isReadOnly && !props.isDisabled) {
      setSelected(value);
    }
  };

  return {
    name,
    selectedValue,
    setSelectedValue,
    lastFocusedValue,
    setLastFocusedValue,
    isDisabled: props.isDisabled || false,
    isReadOnly: props.isReadOnly || false
  };
}

const defaultElement$2 = 'div';
const RadioGroup = /*#__PURE__*/memo( /*#__PURE__*/forwardRef(({
  intent = 'default',
  size = 'md',
  orientation = 'vertical',
  name,
  className,
  label,
  isDisabled,
  children,
  ...props
}, ref) => {
  let state = useRadioGroupState(props);
  let {
    radioGroupProps,
    labelProps
  } = useRadioGroup({
    label
  }, state);
  const variant = { ...variants$2.default,
    ...variants$2[intent]
  };
  const childrenWithProps = _react.Children.map(children, child => {
    if ( /*#__PURE__*/_react.isValidElement(child)) {
      return /*#__PURE__*/_react.cloneElement(child, {
        intent,
        variant,
        name,
        size,
        isDisabled,
        ...child.props
      });
    }

    return child;
  });
  const radioBoxProps = {
    color: variant.color
  };
  return jsxs(Stack, Object.assign({
    as: defaultElement$2,
    direction: orientation,
    ref: ref,
    className: cn('sl-radio-group', className),
    spacing: 2
  }, radioGroupProps, radioBoxProps, props, {
    children: [label && jsx(Box, Object.assign({
      pr: orientation === 'horizontal' ? 3 : undefined
    }, {
      children: jsx("span", Object.assign({}, labelProps, {
        children: label
      }), void 0)
    }), void 0), jsx(RadioContext.Provider, Object.assign({
      value: state
    }, {
      children: childrenWithProps
    }), void 0)]
  }), void 0);
}));

/**
 * Provides the behavior and accessibility implementation for a select component.
 * A select displays a collapsible list of options and allows a user to select one of them.
 * @param props - Props for the select.
 * @param state - State for the select, as returned by `useListState`.
 */
function useSelect(props, state, ref) {
  let {
    keyboardDelegate,
    isDisabled
  } = props; // By default, a KeyboardDelegate is provided which uses the DOM to query layout information (e.g. for page up/page down).
  // When virtualized, the layout object will be passed in as a prop and override this.

  let collator = useCollator({
    usage: 'search',
    sensitivity: 'base'
  });
  let delegate = useMemo(() => keyboardDelegate || new ListKeyboardDelegate(state.collection, state.disabledKeys, null, collator), [keyboardDelegate, state.collection, state.disabledKeys, collator]);
  let {
    menuTriggerProps,
    menuProps
  } = useMenuTrigger({
    isDisabled,
    type: 'listbox'
  }, state, ref);

  let onKeyDown = e => {
    switch (e.key) {
      case 'ArrowLeft':
        {
          // prevent scrolling containers
          e.preventDefault();
          let key = state.selectedKey != null ? delegate.getKeyAbove(state.selectedKey) : delegate.getFirstKey();

          if (key) {
            state.setSelectedKey(key);
          }

          break;
        }

      case 'ArrowRight':
        {
          // prevent scrolling containers
          e.preventDefault();
          let key = state.selectedKey != null ? delegate.getKeyBelow(state.selectedKey) : delegate.getFirstKey();

          if (key) {
            state.setSelectedKey(key);
          }

          break;
        }
    }
  };

  let {
    typeSelectProps
  } = useTypeSelect({
    keyboardDelegate: delegate,
    selectionManager: state.selectionManager,

    onTypeSelect(key) {
      state.setSelectedKey(key);
    }

  });
  let {
    labelProps,
    fieldProps
  } = useLabel(_extends({}, props, {
    labelElementType: 'span'
  }));
  typeSelectProps.onKeyDown = typeSelectProps.onKeyDownCapture;
  delete typeSelectProps.onKeyDownCapture;
  let domProps = filterDOMProps(props, {
    labelable: true
  });
  let triggerProps = mergeProps(typeSelectProps, menuTriggerProps, fieldProps);
  let valueId = useId();
  return {
    labelProps: _extends({}, labelProps, {
      onClick: () => {
        if (!props.isDisabled) {
          ref.current.focus(); // Show the focus ring so the user knows where focus went

          setInteractionModality('keyboard');
        }
      }
    }),
    triggerProps: mergeProps(domProps, _extends({}, triggerProps, {
      onKeyDown: chain(triggerProps.onKeyDown, onKeyDown, props.onKeyDown),
      onKeyUp: props.onKeyUp,
      'aria-labelledby': [triggerProps['aria-labelledby'], triggerProps['aria-label'] && !triggerProps['aria-labelledby'] ? triggerProps.id : null, valueId].filter(Boolean).join(' '),

      onFocus(e) {
        if (state.isFocused) {
          return;
        }

        if (props.onFocus) {
          props.onFocus(e);
        }

        state.setFocused(true);
      },

      onBlur(e) {
        if (state.isOpen) {
          return;
        }

        if (props.onBlur) {
          props.onBlur(e);
        }

        state.setFocused(false);
      }

    })),
    valueProps: {
      id: valueId
    },
    menuProps: _extends({}, menuProps, {
      onBlur: e => {
        if (e.currentTarget.contains(e.relatedTarget)) {
          return;
        }

        if (props.onBlur) {
          props.onBlur(e);
        }

        state.setFocused(false);
      },
      'aria-labelledby': [fieldProps['aria-labelledby'], triggerProps['aria-label'] && !fieldProps['aria-labelledby'] ? triggerProps.id : null].filter(Boolean).join(' ')
    })
  };
}

/**
 * Provides the behavior and accessibility implementation for a hidden `<select>` element, which
 * can be used in combination with `useSelect` to support browser form autofill, mobile form
 * navigation, and native HTML form submission.
 */
function useHiddenSelect(props, state, triggerRef) {
  var _state$selectedKey;

  let {
    name,
    isDisabled
  } = props;
  let modality = useInteractionModality$1();
  let {
    visuallyHiddenProps
  } = useVisuallyHidden$1(); // In Safari, the <select> cannot have `display: none` or `hidden` for autofill to work.
  // In Firefox, there must be a <label> to identify the <select> whereas other browsers
  // seem to identify it just by surrounding text.
  // The solution is to use <VisuallyHidden> to hide the elements, which clips the elements to a
  // 1px rectangle. In addition, we hide from screen readers with aria-hidden, and make the <select>
  // non tabbable with tabIndex={-1}.
  //
  // In mobile browsers, there are next/previous buttons above the software keyboard for navigating
  // between fields in a form. These only support native form inputs that are tabbable. In order to
  // support those, an additional hidden input is used to marshall focus to the button. It is tabbable
  // except when the button is focused, so that shift tab works properly to go to the actual previous
  // input in the form. Using the <select> for this also works, but Safari on iOS briefly flashes
  // the native menu on focus, so this isn't ideal. A font-size of 16px or greater is required to
  // prevent Safari from zooming in on the input when it is focused.
  //
  // If the current interaction modality is null, then the user hasn't interacted with the page yet.
  // In this case, we set the tabIndex to -1 on the input element so that automated accessibility
  // checkers don't throw false-positives about focusable elements inside an aria-hidden parent.

  return {
    containerProps: _extends({}, visuallyHiddenProps, {
      'aria-hidden': true
    }),
    inputProps: {
      type: 'text',
      tabIndex: modality == null || state.isFocused || state.isOpen ? -1 : 0,
      style: {
        fontSize: 16
      },
      onFocus: () => triggerRef.current.focus(),
      disabled: isDisabled
    },
    selectProps: {
      tabIndex: -1,
      disabled: isDisabled,
      name,
      size: state.collection.size,
      value: (_state$selectedKey = state.selectedKey) != null ? _state$selectedKey : '',
      onChange: e => state.setSelectedKey(e.target.value)
    }
  };
}
/**
 * Renders a hidden native `<select>` element, which can be used to support browser
 * form autofill, mobile form navigation, and native form submission.
 */

function HiddenSelect(props) {
  let {
    state,
    triggerRef,
    label,
    name,
    isDisabled
  } = props;
  let {
    containerProps,
    inputProps,
    selectProps
  } = useHiddenSelect(props, state, triggerRef); // If used in a <form>, use a hidden input so the value can be submitted to a server.
  // If the collection isn't too big, use a hidden <select> element for this so that browser
  // autofill will work. Otherwise, use an <input type="hidden">.

  if (state.collection.size <= 300) {
    return /*#__PURE__*/_react__default.createElement("div", containerProps, /*#__PURE__*/_react__default.createElement("input", inputProps), /*#__PURE__*/_react__default.createElement("label", null, label, /*#__PURE__*/_react__default.createElement("select", selectProps, /*#__PURE__*/_react__default.createElement("option", null), [...state.collection.getKeys()].map(key => {
      let item = state.collection.getItem(key);

      if (item.type === 'item') {
        return /*#__PURE__*/_react__default.createElement("option", {
          key: item.key,
          value: item.key
        }, item.textValue);
      }
    }))));
  } else if (name) {
    return /*#__PURE__*/_react__default.createElement("input", {
      type: "hidden",
      name: name,
      disabled: isDisabled,
      value: state.selectedKey
    });
  }

  return null;
}

/**
 * Provides state management for a select component. Handles building a collection
 * of items from props, handles the open state for the popup menu, and manages
 * multiple selection state.
 */
function useSelectState(props) {
  let triggerState = useMenuTriggerState(props);
  let listState = useSingleSelectListState(_extends({}, props, {
    onSelectionChange: key => {
      if (props.onSelectionChange != null) {
        props.onSelectionChange(key);
      }

      triggerState.close();
    }
  }));
  let [isFocused, setFocused] = useState(false);
  return _extends({}, listState, triggerState, {
    open() {
      // Don't open if the collection is empty.
      if (listState.collection.size !== 0) {
        triggerState.open();
      }
    },

    toggle(focusStrategy) {
      if (listState.collection.size !== 0) {
        triggerState.toggle(focusStrategy);
      }
    },

    isFocused,
    setFocused
  });
}

// See examples of getCollectionNode https://github.com/adobe/react-spectrum/search?q=getCollectionNode
const SelectAction = _props => {
  return null;
};
const isSelectAction = item => {
  return item && typeof item === 'object' && item.hasOwnProperty('onPress') ? true : false;
};

SelectAction.getCollectionNode = function* getCollectionNode(props) {
  const {
    label
  } = props;
  const textValue = label || '';
  yield {
    type: 'item',
    key: label,
    props,
    rendered: textValue,
    textValue,
    'aria-label': props['aria-label'],
    hasChildNodes: false
  };
};

// See examples of getCollectionNode https://github.com/adobe/react-spectrum/search?q=getCollectionNode
const SelectOption = _props => {
  return null;
};
const isSelectOption = item => {
  return item && typeof item === 'object' && item.hasOwnProperty('value') ? true : false;
};

SelectOption.getCollectionNode = function* getCollectionNode(props) {
  const {
    value,
    label
  } = props;
  const textValue = (typeof label === 'string' ? label : '') || props['aria-label'] || value || '';
  yield {
    type: 'item',
    key: String(value) || label || 'empty',
    props,
    rendered: label || value,
    textValue,
    'aria-label': props['aria-label'],
    hasChildNodes: false
  };
};

function SelectSection(props) {
  return null;
}
const isSelectSection = item => {
  return item && typeof item === 'object' && item.hasOwnProperty('options') ? true : false;
};

SelectSection.getCollectionNode = function* getCollectionNode(props) {
  const {
    children,
    options
  } = props;
  yield {
    key: props.id || props.title,
    type: 'section',
    hasChildNodes: true,
    rendered: props.title,
    props,
    'aria-label': props['aria-label'],

    *childNodes() {
      if (typeof children === 'function') {
        if (!options) {
          throw new Error('SelectSection props.options is missing');
        }

        for (let item of options) {
          yield {
            type: 'item',
            value: item,
            renderer: children
          };
        }
      } else {
        let items = [];
        _react.Children.forEach(children, child => {
          items.push({
            type: 'item',
            element: child
          });
        });
        yield* items;
      }
    }

  };
};

function Select({
  flexGrow,
  flex,
  w,
  size,
  triggerTextPrefix,
  options,
  value,
  defaultValue,
  onChange,
  isClearable,
  placeholder = 'select an option',
  appearance,
  onOpen,
  onClose,
  isDisabled,
  icon,
  ...props
}, ref) {
  var _a;

  const listboxRef = useRef();

  const _triggerRef = useRef();

  const triggerRef = useFocusableRef(ref) || _triggerRef; // @ts-expect-error these ref typings are wonk


  const unwrappedTriggerRef = useUnwrapDOMRef(triggerRef);
  const onOpenChange = useCallback($isOpen => {
    if ($isOpen && onOpen) onOpen();
    if (!$isOpen && onClose) onClose();
  }, [onClose, onOpen]);

  function onSelectionChange(key) {
    if (onChange) {
      const item = state.collection.getItem(key); // here we make sure to pass as null when falsey, so that Select mode does not change from controlled to uncontrolled

      onChange(item ? item.props.value : null);
    }
  }

  const idAssigner = useMemo(() => createItemIdAssigner(), []);
  const optionsWithids = useMemo(() => idAssigner(options), [idAssigner, options]);
  const [disabledKeys, setDisabledKeys] = useState([]); // Create state based on the incoming props

  const state = useSelectState({
    selectedKey: value,
    defaultSelectedKey: defaultValue,
    onSelectionChange,
    isDisabled,
    placeholder,
    items: optionsWithids,
    children: generateListChildren,
    onOpenChange,
    disabledKeys
  });
  const computedDisabledKeys = useCollectionKeyAccumulator(state.collection, 'isDisabled', true);
  _react.useEffect(() => {
    setDisabledKeys(computedDisabledKeys);
  }, [computedDisabledKeys]);
  const clearSelection = useCallback(() => {
    if (isClearable) {
      state.setSelectedKey(null);
    }
  }, [isClearable, state]);
  const {
    triggerProps,
    menuProps
  } = useSelect({
    selectedKey: value,
    defaultSelectedKey: defaultValue,
    isDisabled,
    disallowEmptySelection: true,
    placeholder,
    items: optionsWithids,
    children: generateListChildren,
    'aria-label': props['aria-label']
  }, state, unwrappedTriggerRef);
  /**
   * Menu list items have a fixed height and padding, we can use
   * this information to adjust menu location so that active item
   * is focused on center, where the user's mouse is.
   *
   * This approach does not take <Section /> into account, or overflow / scrolling. Depending on need, we
   * might want to put effort into a more robust implementation at a later date.
   */

  const [buttonWidth] = useSize(unwrappedTriggerRef);
  const selectedIndex = ((_a = state.selectedItem) === null || _a === void 0 ? void 0 : _a.index) || 0;
  const offset = useMemo(() => computePopoverOffset(size, options, selectedIndex), [size, options, selectedIndex]);
  const crossOffset = size === 'sm' ? -21 : -17;

  const triggerElem = jsx(_FieldButton, Object.assign({}, triggerProps, {
    size: size,
    disabled: isDisabled,
    placeholder: placeholder,
    onClear: !isDisabled && isClearable ? clearSelection : undefined,
    appearance: appearance,
    w: "full",
    // @ts-expect-error these ref typings are wonk
    ref: triggerRef,
    icon: icon
  }, {
    children: state.selectedItem ? triggerTextPrefix ? `${triggerTextPrefix}${state.selectedItem.rendered}` : state.selectedItem.rendered : undefined
  }), void 0);

  return jsxs(Box, Object.assign({
    className: "sl-select",
    pos: "relative",
    flexGrow: flexGrow,
    flex: flex,
    w: w
  }, {
    children: [jsx(HiddenSelect, {
      state: state,
      triggerRef: unwrappedTriggerRef,
      name: props.name
    }, void 0), jsx(Popover, Object.assign({
      triggerRef: unwrappedTriggerRef,
      scrollRef: listboxRef,
      isOpen: state.isOpen,
      onClose: state.close,
      offset: offset,
      crossOffset: crossOffset,
      placement: "bottom left",
      shouldFlip: true,
      renderTrigger: triggerElem,
      appearance: "minimal",
      type: "listbox",
      isNonModal: true
    }, {
      children: jsx(ListBoxPopup, Object.assign({}, menuProps, {
        ref: listboxRef,
        options: optionsWithids,
        state: state,
        minW: buttonWidth + Math.abs(crossOffset) + 4
      }), void 0)
    }), void 0)]
  }), void 0);
}

const _Select = /*#__PURE__*/forwardRef(Select);
const ListBoxPopup = /*#__PURE__*/forwardRef(({
  state,
  minW,
  options,
  ...otherProps
}, ref) => {
  const isDark = useThemeIsDark(); // Get props for the listbox

  const {
    listBoxProps
  } = useListBox({
    autoFocus: 'first',
    shouldFocusWrap: true,
    selectionMode: 'single',
    items: options,
    disallowEmptySelection: true,
    ...otherProps
  }, state, ref); // pull color out, not needed and conflicting types

  const {
    color,
    ...restProps
  } = mergeProps(listBoxProps, otherProps);
  const pointerInteraction = getInteractionModality$1() === 'pointer';
  return jsxs(Fragment, {
    children: [jsx(DismissButton, {
      onDismiss: state.close
    }, void 0), jsx(Box, Object.assign({}, restProps, {
      ref: ref,
      bg: isDark ? 'canvas-dialog' : 'canvas-pure',
      style: {
        minWidth: minW,
        maxHeight: 'inherit'
      },
      py: 2,
      className: cn('sl-menu', {
        'sl-menu--pointer-interactions': pointerInteraction
      }),
      cursor: true,
      overflowY: "auto",
      noFocusRing: true
    }, {
      children: [...state.collection].map(item => {
        const {
          type
        } = item;

        if (type === 'item') {
          return jsx(SelectItem, {
            item: item,
            state: state
          }, item.key);
        }

        if (type === 'section') {
          return jsx(Section, {
            item: item,
            state: state
          }, item.key);
        }

        if (type === 'placeholder') {
          return jsx("div", Object.assign({
            // aria-selected isn't needed here since this option is not selectable.
            role: "option"
          }, {
            children: "no items to select"
          }), void 0);
        }
      })
    }), void 0), jsx(DismissButton, {
      onDismiss: state.close
    }, void 0)]
  }, void 0);
});

function Divider() {
  const {
    separatorProps: {
      color,
      ...separatorProps
    }
  } = useSeparator({
    elementType: 'div'
  });
  return jsx(Box, Object.assign({
    my: 2,
    h: "px",
    bg: "canvas-200"
  }, separatorProps), void 0);
}

function Section({
  item: section,
  state
}) {
  const {
    itemProps,
    headingProps: {
      color: color1,
      ...headingProps
    },
    groupProps
  } = useListBoxSection({
    heading: section.rendered,
    'aria-label': section['aria-label']
  });
  return jsxs(Fragment, {
    children: [section.key !== state.collection.getFirstKey() && jsx(Divider, {}, void 0), jsxs("div", Object.assign({}, itemProps, {
      children: [section.rendered && jsx(Box, Object.assign({}, headingProps, {
        pl: 3,
        pt: 0.5,
        pb: 1,
        textTransform: "uppercase",
        color: "light",
        cursor: true,
        fontSize: "sm"
      }, {
        children: section.rendered
      }), void 0), jsx("div", Object.assign({}, groupProps, {
        children: Array.from(section.childNodes).map(node => {
          let item;

          if (node.type === 'item') {
            item = jsx(SelectItem, {
              item: node,
              state: state
            }, node.key);
          } else {
            item = null;
          }

          if (node.wrapper) {
            item = node.wrapper(item);
          }

          return item;
        })
      }), void 0)]
    }), void 0)]
  }, void 0);
}

function SelectItem({
  item,
  state
}) {
  const ref = useRef();
  const {
    key
  } = item;
  const {
    selectionManager
  } = state;
  const isDisabled = state.disabledKeys.has(item.key);
  const isSelected = selectionManager.isSelected(item.key);
  const isFocused = selectionManager.focusedKey === key;
  const {
    optionProps
  } = useOption({
    key: item.key,
    isDisabled,
    isSelected,
    shouldFocusOnHover: true
  }, state, ref);
  let props = {};

  if (item.props.onPress) {
    props = mergeProps(optionProps, {
      onClick: () => {
        if (isDisabled) return;
        item.props.onPress();
        state.close();
      },
      onKeyUp: e => {
        if (e.key === 'Enter') {
          if (isDisabled) return;
          item.props.onPress();
          state.close();
        }
      },
      onKeyDown: null,
      onMouseDown: null,
      onPointerDown: null,
      onPointerUp: null
    });
  } else {
    props = mergeProps(optionProps);
  }

  return jsx(Internal_MenuItemRow, Object.assign({}, props, {
    ref: ref,
    title: item.rendered,
    description: item.props.description,
    isSelected: !!isSelected,
    isDisabled: isDisabled,
    meta: item.props.meta,
    isFocused: isFocused
  }), void 0);
}

function createItemIdAssigner() {
  let counter = 0;
  return function assignItemIds(items) {
    const itemsWithIds = [];

    for (const item of items) {
      if (isSelectSection(item)) {
        counter++;
        itemsWithIds.push({
          id: counter,
          ...item
        });
      } else {
        itemsWithIds.push(item);
      }
    }

    return itemsWithIds;
  };
}

function generateListChildren(item) {
  if (isSelectSection(item)) {
    return jsx(SelectSection, Object.assign({}, item, {
      children: item => {
        if (isSelectOption(item)) {
          return jsx(SelectOption, Object.assign({}, item), void 0);
        }

        if (isSelectAction(item)) {
          return jsx(SelectAction, Object.assign({}, item), void 0);
        }
      }
    }), void 0);
  }

  if (isSelectOption(item)) {
    return jsx(SelectOption, Object.assign({}, item), void 0);
  }

  if (isSelectAction(item)) {
    return jsx(SelectAction, Object.assign({}, item), void 0);
  }

  return null;
}

function computePopoverOffset(size, options, selectedIndex) {
  const baseOffset = size === 'sm' ? -32 : -37;

  if (selectedIndex === 0) {
    return baseOffset;
  }

  let offset = baseOffset;
  const iterator = options2ElementsIterator(options);
  let i = 0;

  for (const element of iterator) {
    if (element.type == 'separator') {
      offset -= 17;
    } else if (element.type === 'section-heading') {
      offset -= 22;
    } else {
      if (i++ === selectedIndex) {
        return offset;
      }

      offset -= estimateOptionHeight(element.option);
    }
  }

  return offset;
}

function* options2ElementsIterator(options) {
  let yieldSeparator = false;

  for (const option of options) {
    if (yieldSeparator) {
      yieldSeparator = false;
      yield {
        type: 'separator'
      };
    }

    if ('options' in option) {
      yield {
        type: 'section-heading'
      };
      yieldSeparator = true;

      for (const sectionOption of option.options) {
        yield {
          type: 'item',
          option: sectionOption
        };
      }
    } else {
      yield {
        type: 'item',
        option: option
      };
    }
  }
}

function estimateOptionHeight(option) {
  let height = 26;

  if (option.description) {
    height += 16;

    if (option.description.length >= 40) {
      height += 16;
    }
  }

  return height;
}

const Step = ({
  title,
  index,
  isActive,
  completed,
  className,
  isLast
}) => {
  return jsxs(Flex, Object.assign({
    flex: isLast ? 'none' : 'initial',
    flexGrow: isLast ? 0 : true,
    alignItems: "center",
    className: className
  }, {
    children: [jsxs(Box, Object.assign({
      pos: "relative",
      style: {
        color: isActive || completed ? 'var(--color-primary-dark)' : 'var(--color-text-disabled)'
      }
    }, {
      children: [jsx(Flex, Object.assign({
        bg: isActive ? 'primary-tint' : completed ? 'primary-dark' : 'canvas-100',
        justifyContent: "center",
        alignItems: "center",
        w: 10,
        h: 10,
        rounded: "full",
        color: completed ? 'on-primary' : null
      }, {
        children: completed ? jsx(Icon, {
          icon: "check"
        }, void 0) : jsx("span", {
          children: index
        }, void 0)
      }), void 0), jsx(Flex, Object.assign({
        pos: "absolute",
        textAlign: "center",
        left: -10,
        top: 10,
        h: 10,
        style: {
          width: 120
        },
        alignItems: "center",
        justifyContent: "center"
      }, {
        children: title
      }), void 0)]
    }), void 0), jsx(Flex, {
      flexGrow: true,
      h: 0.5,
      bg: completed ? 'primary-dark' : 'canvas-100'
    }, void 0)]
  }), void 0);
};
const Steps = /*#__PURE__*/memo(function Steps(props) {
  const items = _react.Children.toArray(props.children);
  const current = props.current || 0;
  const childrenWithProps = items.map((child, i) => {
    if ( /*#__PURE__*/_react.isValidElement(child)) {
      return /*#__PURE__*/_react.cloneElement(child, {
        index: i + 1,
        isActive: current === i,
        completed: i < current,
        isLast: i === items.length - 1
      });
    }

    return child;
  });
  return jsx(Flex, Object.assign({
    w: "full",
    fontSize: "base",
    px: 10,
    pb: 10,
    className: props.className
  }, {
    children: childrenWithProps
  }), void 0);
});

/**
 * Handles interactions for toggle elements, e.g. Checkboxes and Switches.
 */
function useToggle(props, state, ref) {
  let {
    isDisabled = false,
    isRequired,
    isReadOnly,
    value,
    name,
    children,
    'aria-label': ariaLabel,
    'aria-labelledby': ariaLabelledby,
    validationState = 'valid'
  } = props;

  let onChange = e => {
    // since we spread props on label, onChange will end up there as well as in here.
    // so we have to stop propagation at the lowest level that we care about
    e.stopPropagation();
    state.setSelected(e.target.checked);
  };

  let hasChildren = children != null;
  let hasAriaLabel = ariaLabel != null || ariaLabelledby != null;

  if (!hasChildren && !hasAriaLabel) {
    console.warn('If you do not provide children, you must specify an aria-label for accessibility');
  } // This handles focusing the input on pointer down, which Safari does not do by default.


  let {
    pressProps
  } = usePress({
    isDisabled
  });
  let {
    focusableProps
  } = useFocusable(props, ref);
  let interactions = mergeProps(pressProps, focusableProps);
  let domProps = filterDOMProps(props, {
    labelable: true
  });
  return {
    inputProps: mergeProps(domProps, _extends({
      'aria-invalid': validationState === 'invalid' || undefined,
      'aria-errormessage': props['aria-errormessage'],
      'aria-controls': props['aria-controls'],
      'aria-readonly': isReadOnly || undefined,
      onChange,
      disabled: isDisabled,
      required: isRequired,
      value,
      name,
      type: 'checkbox'
    }, interactions))
  };
}

/**
 * Provides the behavior and accessibility implementation for a switch component.
 * A switch is similar to a checkbox, but represents on/off values as opposed to selection.
 * @param props - Props for the switch.
 * @param state - State for the switch, as returned by `useToggleState`.
 * @param ref - Ref to the HTML input element.
 */
function useSwitch(props, state, ref) {
  let {
    inputProps
  } = useToggle(props, state, ref);
  let {
    isSelected
  } = state;
  return {
    inputProps: _extends({}, inputProps, {
      role: 'switch',
      checked: isSelected,
      'aria-checked': isSelected
    })
  };
}

/**
 * Provides state management for toggle components like checkboxes and switches.
 */
function useToggleState(props) {
  if (props === void 0) {
    props = {};
  }

  let {
    isReadOnly,
    onChange
  } = props; // have to provide an empty function so useControlledState doesn't throw a fit
  // can't use useControlledState's prop calling because we need the event object from the change

  let [isSelected, setSelected] = useControlledState(props.isSelected, props.defaultSelected || false, () => {});

  function updateSelected(value) {
    if (!isReadOnly) {
      setSelected(value);

      if (onChange) {
        onChange(value);
      }
    }
  }

  function toggleState() {
    if (!isReadOnly) {
      setSelected(prev => {
        let newVal = !prev;

        if (onChange) {
          onChange(newVal);
        }

        return newVal;
      });
    }
  }

  return {
    isSelected,
    setSelected: updateSelected,
    toggle: toggleState
  };
}

const sizes$1 = {
  lg: {
    width: 12,
    height: 6,
    fontSize: 'lg'
  },
  md: {
    width: 10,
    height: 5,
    fontSize: 'sm'
  },
  sm: {
    width: 8,
    height: 4,
    fontSize: '2xs'
  }
};

const defaultElement$1 = 'input';
const Switch = /*#__PURE__*/memo( /*#__PURE__*/forwardRef(({
  size = 'md',
  showIcon = false,
  className,
  isDisabled,
  isSelected,
  defaultSelected,
  onChange,
  ...props
}, ref) => {
  const fallbackRef = useRef();
  const inputRef = ref || fallbackRef;
  const isDark = useThemeIsDark();
  const state = useToggleState({
    onChange,
    isSelected,
    defaultSelected,
    ...props
  });
  const {
    inputProps
  } = useSwitch({
    isDisabled,
    ...props
  }, state, inputRef);
  const {
    matchedProps,
    remainingProps
  } = splitBoxProps(props);
  let disabledProps = {};

  if (isDisabled) {
    disabledProps = {
      bg: isDark ? 'canvas-100' : 'canvas-200',
      cursor: 'not-allowed'
    };
  }

  const checkboxProps = mergeProps(inputProps, {
    color: undefined
  });
  return jsx(Box, Object.assign({
    className: cn('sl-switch', className),
    h: sizes$1[size].height,
    w: sizes$1[size].width,
    fontSize: sizes$1[size].fontSize,
    pos: "relative",
    display: "block",
    userSelect: "none"
  }, matchedProps, remainingProps, {
    children: jsxs(Box, Object.assign({
      as: "label",
      pos: "absolute",
      w: "full",
      h: "full"
    }, {
      children: [jsx(Box, Object.assign({
        ref: inputRef,
        as: defaultElement$1,
        pos: "absolute",
        m: 0,
        zIndex: -1,
        top: 0,
        left: 0,
        opacity: 0,
        disabled: isDisabled
      }, checkboxProps), void 0), jsx(Box, Object.assign({
        as: "span",
        cursor: "pointer",
        className: "sl-switch__indicator",
        rounded: "full",
        w: "full",
        h: "full",
        display: "block",
        bg: isDark ? 'canvas-50' : 'canvas-500'
      }, disabledProps, {
        children: showIcon && jsx(Flex, Object.assign({
          className: "sl-switch__icon",
          pos: "absolute",
          align: "center",
          style: {
            top: 0,
            bottom: 0,
            left: 0,
            lineHeight: 1
          },
          pl: 1,
          color: isDark ? 'body' : 'canvas-pure'
        }, {
          children: jsx(Icon, {
            icon: "check",
            fixedWidth: true
          }, void 0)
        }), void 0)
      }), void 0)]
    }), void 0)
  }), void 0);
}));

/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */
const $c5c378b07d37fb3729fd37493414d657$export$tabsIds = new WeakMap();

function $c5c378b07d37fb3729fd37493414d657$export$generateId(state, key, role) {
  if (typeof key === 'string') {
    key = key.replace(/\s+/g, '');
  }

  let baseId = $c5c378b07d37fb3729fd37493414d657$export$tabsIds.get(state);
  return baseId + "-" + role + "-" + key;
}

/**
 * Provides the behavior and accessibility implementation for a tab.
 * When selected, the associated tab panel is shown.
 */
function useTab(props, state, ref) {
  let {
    key,
    isDisabled: propsDisabled
  } = props;
  let {
    selectionManager: manager,
    selectedKey
  } = state;
  let isSelected = key === selectedKey;
  let {
    itemProps
  } = useSelectableItem({
    selectionManager: manager,
    key,
    ref
  });
  let isDisabled = propsDisabled || state.disabledKeys.has(key);
  let {
    pressProps
  } = usePress(_extends({}, itemProps, {
    isDisabled
  }));
  let tabId = $c5c378b07d37fb3729fd37493414d657$export$generateId(state, key, 'tab');
  let tabPanelId = $c5c378b07d37fb3729fd37493414d657$export$generateId(state, key, 'tabpanel');
  let {
    tabIndex
  } = pressProps;
  return {
    tabProps: _extends({}, pressProps, {
      id: tabId,
      'aria-selected': isSelected,
      'aria-disabled': isDisabled || undefined,
      'aria-controls': isSelected ? tabPanelId : undefined,
      tabIndex: isDisabled ? undefined : tabIndex,
      role: 'tab'
    })
  };
}

/**
 * Provides the behavior and accessibility implementation for a tab panel. A tab panel is a container for
 * the contents of a tab, and is shown when the tab is selected.
 */
function useTabPanel(props, state, ref) {
  let [tabIndex, setTabIndex] = useState(0); // The tabpanel should have tabIndex=0 when there are no tabbable elements within it.
  // Otherwise, tabbing from the focused tab should go directly to the first tabbable element
  // within the tabpanel.

  useLayoutEffect$1(() => {
    if (ref != null && ref.current) {
      let update = () => {
        // Detect if there are any tabbable elements and update the tabIndex accordingly.
        let walker = getFocusableTreeWalker(ref.current, {
          tabbable: true
        });
        setTabIndex(walker.nextNode() ? undefined : 0);
      };

      update(); // Update when new elements are inserted, or the tabIndex/disabled attribute updates.

      let observer = new MutationObserver(update);
      observer.observe(ref.current, {
        subtree: true,
        childList: true,
        attributes: true,
        attributeFilter: ['tabIndex', 'disabled']
      });
      return () => {
        observer.disconnect();
      };
    }
  }, [ref]);
  const id = $c5c378b07d37fb3729fd37493414d657$export$generateId(state, state == null ? void 0 : state.selectedKey, 'tabpanel');
  const tabPanelProps = useLabels(_extends({}, props, {
    id,
    'aria-labelledby': $c5c378b07d37fb3729fd37493414d657$export$generateId(state, state == null ? void 0 : state.selectedKey, 'tab')
  }));
  return {
    tabPanelProps: mergeProps(tabPanelProps, {
      tabIndex,
      role: 'tabpanel',
      'aria-describedby': props['aria-describedby'],
      'aria-details': props['aria-details']
    })
  };
}

class $ace72fda23df319bd9db38f00073d9$export$TabsKeyboardDelegate {
  constructor(collection, direction, orientation, disabledKeys) {
    if (disabledKeys === void 0) {
      disabledKeys = new Set();
    }

    this.collection = void 0;
    this.flipDirection = void 0;
    this.disabledKeys = void 0;
    this.orientation = void 0;
    this.collection = collection;
    this.flipDirection = direction === 'rtl' && orientation === 'horizontal';
    this.orientation = orientation;
    this.disabledKeys = disabledKeys;
  }

  getKeyLeftOf(key) {
    if (this.flipDirection) {
      return this.getNextKey(key);
    } else {
      if (this.orientation === 'horizontal') {
        return this.getPreviousKey(key);
      }

      return null;
    }
  }

  getKeyRightOf(key) {
    if (this.flipDirection) {
      return this.getPreviousKey(key);
    } else {
      if (this.orientation === 'horizontal') {
        return this.getNextKey(key);
      }

      return null;
    }
  }

  getKeyAbove(key) {
    if (this.orientation === 'vertical') {
      return this.getPreviousKey(key);
    }

    return null;
  }

  getKeyBelow(key) {
    if (this.orientation === 'vertical') {
      return this.getNextKey(key);
    }

    return null;
  }

  getFirstKey() {
    let key = this.collection.getFirstKey();

    if (this.disabledKeys.has(key)) {
      key = this.getNextKey(key);
    }

    return key;
  }

  getLastKey() {
    let key = this.collection.getLastKey();

    if (this.disabledKeys.has(key)) {
      key = this.getPreviousKey(key);
    }

    return key;
  }

  getNextKey(key) {
    do {
      key = this.collection.getKeyAfter(key);

      if (key == null) {
        key = this.collection.getFirstKey();
      }
    } while (this.disabledKeys.has(key));

    return key;
  }

  getPreviousKey(key) {
    do {
      key = this.collection.getKeyBefore(key);

      if (key == null) {
        key = this.collection.getLastKey();
      }
    } while (this.disabledKeys.has(key));

    return key;
  }

}

/**
 * Provides the behavior and accessibility implementation for a tab list.
 * Tabs organize content into multiple sections and allow users to navigate between them.
 */
function useTabList(props, state, ref) {
  let {
    orientation = 'horizontal',
    keyboardActivation = 'automatic'
  } = props;
  let {
    collection,
    selectionManager: manager,
    disabledKeys
  } = state;
  let {
    direction
  } = useLocale();
  let delegate = useMemo(() => new $ace72fda23df319bd9db38f00073d9$export$TabsKeyboardDelegate(collection, direction, orientation, disabledKeys), [collection, disabledKeys, orientation, direction]);
  let {
    collectionProps
  } = useSelectableCollection({
    ref,
    selectionManager: manager,
    keyboardDelegate: delegate,
    selectOnFocus: keyboardActivation === 'automatic',
    disallowEmptySelection: true
  }); // Compute base id for all tabs

  let tabsId = useId();
  $c5c378b07d37fb3729fd37493414d657$export$tabsIds.set(state, tabsId);
  let tabListLabelProps = useLabels(_extends({}, props, {
    id: tabsId
  }));
  return {
    tabListProps: _extends({}, mergeProps(collectionProps, tabListLabelProps), {
      role: 'tablist',
      'aria-orientation': orientation,
      tabIndex: undefined
    })
  };
}

const TabsContext = /*#__PURE__*/_react.createContext(null);

const variants$1 = {
  minimal: {
    horizontal: {
      regular: {
        tabList: {},
        tab: {
          py: 2,
          px: 3
        }
      },
      compact: {
        tabList: {},
        tab: {
          py: 1.5,
          px: 2
        }
      }
    },
    vertical: {
      regular: {
        tabList: {},
        tab: {
          py: 1.5,
          px: 3
        }
      },
      compact: {
        tabList: {},
        tab: {
          py: 1.5,
          px: 3
        }
      }
    }
  },
  line: {
    horizontal: {
      regular: {
        tabList: {
          borderB: 2
        },
        tab: {
          mb: -0.5,
          borderB: 2,
          py: 2,
          px: 4
        }
      },
      compact: {
        tabList: {
          borderB: 2
        },
        tab: {
          mb: -0.5,
          borderB: 2,
          py: 1.5,
          px: 2
        }
      }
    },
    vertical: {
      regular: {
        tabList: {
          borderR: 2
        },
        tab: {
          mr: -0.5,
          borderR: 2,
          py: 2,
          px: 4
        }
      },
      compact: {
        tabList: {
          borderR: 2
        },
        tab: {
          mr: -0.5,
          borderR: 2,
          py: 1.5,
          px: 3
        }
      }
    }
  },
  pill: {
    horizontal: {
      regular: {
        tabList: {},
        tab: {
          py: 2,
          px: 3,
          rounded: 'lg'
        }
      },
      compact: {
        tabList: {},
        tab: {
          py: 1,
          px: 2,
          rounded: 'lg'
        }
      }
    },
    vertical: {
      regular: {
        tabList: {},
        tab: {
          py: 1.5,
          px: 3,
          rounded: 'lg'
        }
      },
      compact: {
        tabList: {},
        tab: {
          py: 1,
          px: 2,
          rounded: 'lg'
        }
      }
    }
  }
};

const Tab = props => jsx(Item, Object.assign({}, props), void 0);
Tab.getCollectionNode = Item.getCollectionNode;
const IntentColorMap = {
  default: {
    color: 'light',
    selectedColor: 'primary-dark',
    bgTint: 'primary-tint',
    selectedBg: 'primary',
    selectedBorder: 'primary'
  },
  success: {
    color: 'success',
    selectedColor: 'success-dark',
    bgTint: 'success-tint',
    selectedBg: 'success',
    selectedBorder: 'success'
  },
  warning: {
    color: 'warning',
    selectedColor: 'warning-dark',
    bgTint: 'warning-tint',
    selectedBg: 'warning',
    selectedBorder: 'warning'
  },
  danger: {
    color: 'danger',
    selectedColor: 'danger-dark',
    bgTint: 'danger-tint',
    selectedBg: 'danger',
    selectedBorder: 'danger'
  }
};
function TabImpl(props) {
  var _a;

  const {
    item,
    state,
    density,
    isDisabled: propsDisabled
  } = props;
  const {
    key,
    rendered,
    index
  } = item;
  const intent = ((_a = item.props) === null || _a === void 0 ? void 0 : _a.intent) || 'default';
  const isDisabled = propsDisabled || state.disabledKeys.has(key);
  const tabContext = useContext(TabsContext);
  const {
    tabsProps
  } = tabContext;
  const {
    appearance,
    orientation
  } = tabsProps;
  const isPill = appearance === 'pill';
  const isLine = appearance === 'line';
  const isMinimal = appearance === 'minimal';
  const disabledKeys = state.disabledKeys; // sync `isDisabled` prop with tab list state disabled keys

  _react.useEffect(() => {
    if (propsDisabled && !disabledKeys.has(key)) {
      disabledKeys.add(key);
    } else if (!propsDisabled && disabledKeys.has(key)) {
      disabledKeys.delete(key);
    }
  }, [disabledKeys, propsDisabled, key]);
  const ref = useRef();
  const {
    tabProps
  } = useTab({
    key,
    isDisabled
  }, state, ref);
  const {
    hoverProps
  } = useHover({ ...props
  });
  const isSelected = state.selectedKey === key;
  const {
    color: _color,
    ...propsWithoutColor
  } = mergeProps(tabProps, hoverProps);
  const stateProps = { ...variants$1[appearance][orientation][density].tab
  };

  if (isMinimal) {
    if (orientation === 'vertical') {
      // @ts-expect-error
      stateProps.ml = -1 * stateProps.px;

      if (index === 0) {
        // @ts-expect-error
        stateProps.mt = -1 * stateProps.py;
      }
    } else {
      if (index === 0) {
        // @ts-expect-error
        stateProps.ml = -1 * stateProps.px;
      }
    }
  } else {
    if (orientation === 'vertical') {
      // @ts-expect-error
      stateProps.ml = -1 * stateProps.px;
    }
  }
  /**
   * If in loading or disabled states, remove other ui effects like hover
   */


  if (isDisabled) {
    for (const i in stateProps) {
      const prop = stateProps[i];

      if (prop && typeof prop === 'object') {
        // remove props immutably
        const {
          active,
          hover,
          ...newProps
        } = stateProps[i];
        stateProps[i] = newProps;
      }
    }
  }

  let bg;
  let color = {
    default: isPill ? IntentColorMap[intent].color : 'light',
    hover: isDisabled ? undefined : 'body'
  };

  if (isSelected) {
    if (isPill) {
      color = 'on-primary';
    } else if (isMinimal && intent === 'default') {
      color = 'body'; // override primary color for minimal tabs with the default intent
    } else {
      color = IntentColorMap[intent].selectedColor;
    }
  }

  if (isPill) {
    bg = isSelected ? IntentColorMap[intent].selectedBg : {
      hover: !isDisabled ? IntentColorMap[intent].bgTint : undefined
    };
  }

  return jsx(FocusRing, Object.assign({
    focusRingClass: "sl-focus-ring"
  }, {
    children: jsx(Box, Object.assign({}, propsWithoutColor, {
      ref: ref
    }, stateProps, {
      borderColor: isSelected && isLine ? IntentColorMap[intent].selectedBorder : 'transparent',
      cursor: isDisabled ? 'not-allowed' : isSelected ? true : 'pointer',
      fontWeight: "medium",
      opacity: isDisabled ? 60 : undefined,
      bg: bg,
      color: color
    }, {
      children: rendered
    }), void 0)
  }), void 0);
}

/**
 * Provides state management for a Tabs component. Tabs include a TabList which tracks
 * which tab is currently selected and displays the content associated with that Tab in a TabPanel.
 */
function useTabListState(props) {
  let state = useSingleSelectListState(_extends({}, props, {
    suppressTextValueWarning: true
  }));
  useEffect(() => {
    // Ensure a tab is always selected (in case no selected key was specified or if selected item was deleted from collection)
    let selectedKey = state.selectedKey;

    if (state.selectionManager.isEmpty || !state.collection.getItem(selectedKey)) {
      selectedKey = state.collection.getFirstKey();
      state.selectionManager.replaceSelection(selectedKey);
    }

    if (state.selectionManager.focusedKey == null) {
      state.selectionManager.setFocusedKey(selectedKey);
    }
  }, [state.selectionManager, state.selectedKey, state.collection]);
  return state;
}

/**
 * A TabList is used within Tabs to group tabs that a user can switch between.
 * The keys of the items within the <TabList> must match up with a corresponding item inside the <TabPanels>.
 */

function TabList({
  fontSize = 'lg',
  density = 'regular',
  ...props
}) {
  const tabContext = useContext(TabsContext);
  const {
    refs,
    tabState,
    tabsProps
  } = tabContext;
  const {
    orientation,
    selectedId,
    onChange,
    appearance
  } = tabsProps;
  const {
    collapse,
    setTabListState
  } = tabState;
  const {
    tablistRef
  } = refs;
  const isPill = appearance === 'pill'; // Pass original Tab props but override children to create the collection.

  const state = useTabListState({ ...tabsProps,
    selectedKey: onChange ? selectedId : undefined,
    defaultSelectedKey: onChange ? undefined : selectedId,
    onSelectionChange: onChange,
    children: props.children
  });
  const {
    tabListProps
  } = useTabList({ ...tabsProps,
    ...props
  }, state, tablistRef);
  useEffect(() => {
    // Passing back to root as useTabPanel needs the TabListState
    setTabListState(state); // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [state.disabledKeys, state.selectedItem, state.selectedKey, props.children]);
  const {
    color,
    ...tabListPropsWithoutColor
  } = tabListProps;
  const stateProps = { ...variants$1[appearance][orientation][density].tabList
  };

  const tabContent = jsx(Stack, Object.assign({}, tabListPropsWithoutColor, {
    ref: tablistRef,
    direction: orientation
  }, stateProps, {
    fontSize: fontSize,
    spacing: isPill ? 2 : undefined
  }, {
    children: [...state.collection].map(item => {
      var _a;

      return jsx(TabImpl, {
        item: item,
        state: state,
        density: density,
        isDisabled: (_a = item.props) === null || _a === void 0 ? void 0 : _a.isDisabled
      }, item.key);
    })
  }), void 0);

  return tabContent; // TODO: auto collapse w Select when overflows
  // if (orientation === 'vertical') {
  //   return tabContent;
  // } else {
  //   return (
  //     <div ref={wrapperRef} className={classNames(styles, 'collapseWrapper')}>
  //       {collapse ? (
  //         <Select
  //           {...props}
  //           {...tabProps}
  //           id={tabPanelProps['aria-labelledby']}
  //           state={state}
  //           className={tabListclassName}
  //         />
  //       ) : (
  //         tabContent
  //       )}
  //     </div>
  //   );
  // }
}

const TabPanel = props => jsx(Item, Object.assign({}, props), void 0);
TabPanel.getCollectionNode = Item.getCollectionNode;

function TabPanels({
  p = 4,
  m,
  ...props
}) {
  const {
    tabState,
    tabPanelProps: ctxTabPanelProps,
    tabsProps
  } = useContext(TabsContext);
  const {
    tabListState
  } = tabState;
  const ref = useRef();
  const {
    tabPanelProps
  } = useTabPanel({}, tabListState, ref);

  if (ctxTabPanelProps['aria-labelledby']) {
    tabPanelProps['aria-labelledby'] = ctxTabPanelProps['aria-labelledby'];
  }

  const factory = nodes => new ListCollection(nodes);

  const collection = useCollection$1(props, factory, {
    suppressTextValueWarning: true
  });
  const selectedItem = tabListState ? collection.getItem(tabListState.selectedKey) : null;
  const {
    orientation
  } = tabsProps;
  const {
    color,
    ...tabPanelPropsWithoutColor
  } = tabPanelProps;
  const py = orientation === 'vertical' ? undefined : p;
  const px = orientation === 'vertical' ? p : undefined;
  return jsx(FocusRing, Object.assign({
    focusRingClass: "sl-focus-ring"
  }, {
    children: jsx(Box, Object.assign({}, tabPanelPropsWithoutColor, {
      ref: ref,
      py: py,
      px: px,
      flex: 1,
      m: m
    }, {
      children: selectedItem && selectedItem.props.children
    }), void 0)
  }), void 0);
}

const Tabs = /*#__PURE__*/_react.forwardRef((props, ref) => {
  const {
    children,
    appearance = 'minimal',
    orientation = 'horizontal'
  } = props;
  const domRef = useDOMRef(ref);
  const tablistRef = _react.useRef();
  const wrapperRef = _react.useRef();
  const [collapse, setCollapse] = useValueEffect(false);
  const [selectedTab, setSelectedTab] = _react.useState();
  const [tabListState, setTabListState] = _react.useState(null);
  _react.useEffect(() => {
    if (tablistRef.current) {
      let selectedTab = tablistRef.current.querySelector(`[data-key="${tabListState === null || tabListState === void 0 ? void 0 : tabListState.selectedKey}"]`);

      if (selectedTab != null) {
        setSelectedTab(selectedTab);
      }
    } // collapse is in the dep array so selectedTab can be updated for TabLine positioning

  }, [children, tabListState === null || tabListState === void 0 ? void 0 : tabListState.selectedKey, collapse, tablistRef]); // TODO: when we add logic to collapse overflow tabs
  // const direction: 'ltr' | 'rtl' = 'ltr';
  // const checkShouldCollapse = React.useCallback(() => {
  //   const computeShouldCollapse = () => {
  //     if (wrapperRef.current) {
  //       const tabsComponent = wrapperRef.current;
  //       const tabs = tablistRef.current.querySelectorAll('[role="tab"]');
  //       const lastTab = tabs[tabs.length - 1];
  //       // @ts-expect-error
  //       const end = direction === 'rtl' ? 'left' : 'right';
  //       const farEdgeTabList = tabsComponent.getBoundingClientRect()[end];
  //       const farEdgeLastTab = lastTab?.getBoundingClientRect()[end];
  //       // @ts-expect-error
  //       const shouldCollapse = direction === 'rtl' ? farEdgeLastTab < farEdgeTabList : farEdgeTabList < farEdgeLastTab;
  //       return shouldCollapse;
  //     }
  //   };
  //   if (orientation !== 'vertical') {
  //     setCollapse(function* () {
  //       // Make Tabs render in non-collapsed state
  //       yield false;
  //       // Compute if Tabs should collapse and update
  //       yield computeShouldCollapse();
  //     });
  //   }
  // }, [tablistRef, wrapperRef, direction, orientation, setCollapse]);
  // React.useEffect(() => {
  //   checkShouldCollapse();
  // }, [children, checkShouldCollapse]);
  // useResizeObserver({ref: wrapperRef, onResize: checkShouldCollapse});

  let tabPanelProps = {
    'aria-labelledby': undefined
  }; // When the tabs are collapsed, the tabPanel should be labelled by the Picker button element.

  let collapsibleTabListId = useId();

  if (collapse && orientation !== 'vertical') {
    tabPanelProps['aria-labelledby'] = collapsibleTabListId;
  }

  return jsx(NoSsr, {
    children: jsx(TabsContext.Provider, Object.assign({
      value: {
        tabsProps: { ...props,
          orientation,
          appearance
        },
        tabState: {
          tabListState,
          setTabListState,
          selectedTab,
          collapse
        },
        refs: {
          tablistRef,
          wrapperRef
        },
        tabPanelProps
      }
    }, {
      children: jsx(Stack, Object.assign({
        ref: domRef,
        w: "full",
        direction: orientation === 'vertical' ? 'horizontal' : 'vertical'
      }, {
        children: props.children
      }), void 0)
    }), void 0)
  }, void 0);
});

const variants = {
  default: {
    default: {
      borderColor: {
        default: 'input',
        // TODO: when have more sophisticated theme val system, slightly darker color on hover as in ui designs
        // hover: 'input',
        focus: 'primary'
      }
    },
    success: {
      borderColor: {
        default: 'success',
        focus: 'success-dark'
      }
    },
    warning: {
      borderColor: {
        default: 'warning',
        focus: 'warning-dark'
      }
    },
    danger: {
      borderColor: {
        default: 'danger',
        focus: 'danger-dark'
      }
    }
  },
  minimal: {
    default: {
      borderColor: {
        default: 'transparent',
        hover: 'input',
        focus: 'primary'
      }
    },
    success: {
      borderColor: {
        default: 'transparent',
        hover: 'success',
        focus: 'success-dark'
      }
    },
    warning: {
      borderColor: {
        default: 'transparent',
        hover: 'warning',
        focus: 'warning-dark'
      }
    },
    danger: {
      borderColor: {
        default: 'transparent',
        hover: 'danger',
        focus: 'danger-dark'
      }
    }
  }
};
const sizes = {
  lg: {
    padding: 4,
    rows: 6
  },
  md: {
    padding: 2.5,
    rows: 4
  },
  sm: {
    padding: 1.5,
    rows: 2
  }
};
const fontSizes = {
  lg: 'lg',
  md: 'base',
  sm: 'base'
};

const defaultElement = 'textarea';
const Textarea = /*#__PURE__*/memo( /*#__PURE__*/forwardRef(({
  intent = 'default',
  size = 'md',
  resize = 'y',
  appearance = 'default',
  className,
  disabled,
  required,
  readOnly,
  ...props
}, ref) => {
  const fallbackRef = useRef();
  const textAreaRef = ref || fallbackRef;
  const {
    inputProps
  } = useTextField({
    isDisabled: disabled,
    isRequired: required,
    isReadOnly: readOnly,
    ...props
  }, textAreaRef);
  const {
    matchedProps,
    remainingProps
  } = splitBoxProps(props);
  const stateProps = { ...variants.default.default,
    ...variants.default[intent],
    ...variants[appearance].default,
    ...variants[appearance][intent]
  };
  let onResizeChange = useCallback(() => {
    let input = textAreaRef.current;
    input.style.minHeight = `${input.scrollHeight + 2}px`;
    input.style.minWidth = `${input.scrollWidth + 2}px`;
  }, [textAreaRef]);
  useLayoutEffect$1(() => {
    if (textAreaRef.current) {
      onResizeChange();
    }
  }, [onResizeChange, textAreaRef]);
  let disabledProps = {};

  if (disabled) {
    disabledProps = {
      bg: 'canvas-100',
      color: 'muted',
      cursor: 'not-allowed'
    };
  }

  let readOnlyProps = {};

  if (readOnly) {
    readOnlyProps.tabIndex = -1;

    if (appearance === 'minimal') {
      readOnlyProps.borderColor = 'transparent';
    }
  }

  const textareaProps = mergeProps(inputProps, {
    color: undefined
  });
  return jsx(Box, Object.assign({
    className: cn('sl-textarea', className),
    pos: "relative"
  }, matchedProps, {
    children: jsx(Box, Object.assign({
      ref: textAreaRef,
      as: defaultElement,
      pl: sizes[size].padding,
      pr: sizes[size].padding,
      pt: 2,
      fontSize: fontSizes[size],
      rounded: true,
      resize: resize,
      rows: sizes[size].rows,
      border: true,
      w: "full",
      disabled: disabled,
      readOnly: true,
      pos: "relative"
    }, textareaProps, remainingProps, readOnlyProps, stateProps, disabledProps), void 0)
  }), void 0);
}));

/**
 * Provides the accessibility implementation for a Tooltip component.
 */
function useTooltip(props, state) {
  let domProps = filterDOMProps(props, {
    labelable: true
  });
  let {
    hoverProps
  } = useHover({
    onHoverStart: () => state == null ? void 0 : state.open(true),
    onHoverEnd: () => state == null ? void 0 : state.close()
  });
  return {
    tooltipProps: mergeProps(domProps, hoverProps, {
      role: 'tooltip'
    })
  };
}

/**
 * Provides the behavior and accessibility implementation for a tooltip trigger, e.g. a button
 * that shows a description when focused or hovered.
 */
function useTooltipTrigger(props, state, ref) {
  let {
    isDisabled,
    trigger
  } = props;
  let tooltipId = useId();
  let isHovered = useRef(false);
  let isFocused = useRef(false);

  let handleShow = () => {
    if (isHovered.current || isFocused.current) {
      state.open(isFocused.current);
    }
  };

  let handleHide = immediate => {
    if (!isHovered.current && !isFocused.current) {
      state.close(immediate);
    }
  };

  useEffect(() => {
    let onKeyDown = e => {
      if (ref && ref.current) {
        // Escape after clicking something can give it keyboard focus
        // dismiss tooltip on esc key press
        if (e.key === 'Escape') {
          state.close(true);
        }
      }
    };

    if (state.isOpen) {
      document.addEventListener('keydown', onKeyDown, true);
      return () => {
        document.removeEventListener('keydown', onKeyDown, true);
      };
    }
  }, [ref, state]);

  let onHoverStart = () => {
    if (trigger === 'focus') {
      return;
    } // In chrome, if you hover a trigger, then another element obscures it, due to keyboard
    // interactions for example, hover will end. When hover is restored after that element disappears,
    // focus moves on for example, then the tooltip will reopen. We check the modality to know if the hover
    // is the result of moving the mouse.


    if (getInteractionModality$1() === 'pointer') {
      isHovered.current = true;
    } else {
      isHovered.current = false;
    }

    handleShow();
  };

  let onHoverEnd = () => {
    if (trigger === 'focus') {
      return;
    } // no matter how the trigger is left, we should close the tooltip


    isFocused.current = false;
    isHovered.current = false;
    handleHide();
  };

  let onPressStart = () => {
    // no matter how the trigger is pressed, we should close the tooltip
    isFocused.current = false;
    isHovered.current = false;
    handleHide(true);
  };

  let onFocus = () => {
    let isVisible = isFocusVisible();

    if (isVisible) {
      isFocused.current = true;
      handleShow();
    }
  };

  let onBlur = () => {
    isFocused.current = false;
    isHovered.current = false;
    handleHide(true);
  };

  let {
    hoverProps
  } = useHover({
    isDisabled,
    onHoverStart,
    onHoverEnd
  });
  let {
    pressProps
  } = usePress({
    onPressStart
  });
  let {
    focusableProps
  } = useFocusable({
    isDisabled,
    onFocus,
    onBlur
  }, ref);
  return {
    triggerProps: _extends({
      'aria-describedby': state.isOpen ? tooltipId : undefined
    }, mergeProps(focusableProps, hoverProps, pressProps)),
    tooltipProps: {
      id: tooltipId
    }
  };
}

const $af9cde49ea815e766aeca6386e9$var$TOOLTIP_DELAY = 1500; // this seems to be a 1.5 second delay, check with design

const $af9cde49ea815e766aeca6386e9$var$TOOLTIP_COOLDOWN = 500;
let $af9cde49ea815e766aeca6386e9$var$tooltips = {};
let $af9cde49ea815e766aeca6386e9$var$tooltipId = 0;
let $af9cde49ea815e766aeca6386e9$var$globalWarmedUp = false;
let $af9cde49ea815e766aeca6386e9$var$globalWarmUpTimeout = null;
let $af9cde49ea815e766aeca6386e9$var$globalCooldownTimeout = null;
/**
 * Manages state for a tooltip trigger. Tracks whether the tooltip is open, and provides
 * methods to toggle this state. Ensures only one tooltip is open at a time and controls
 * the delay for showing a tooltip.
 */

function useTooltipTriggerState(props) {
  if (props === void 0) {
    props = {};
  }

  let {
    delay = $af9cde49ea815e766aeca6386e9$var$TOOLTIP_DELAY
  } = props;
  let {
    isOpen,
    open,
    close
  } = useOverlayTriggerState(props);
  let id = useMemo(() => "" + ++$af9cde49ea815e766aeca6386e9$var$tooltipId, []);
  let closeTimeout = useRef();

  let ensureTooltipEntry = () => {
    $af9cde49ea815e766aeca6386e9$var$tooltips[id] = hideTooltip;
  };

  let closeOpenTooltips = () => {
    for (let hideTooltipId in $af9cde49ea815e766aeca6386e9$var$tooltips) {
      if (hideTooltipId !== id) {
        $af9cde49ea815e766aeca6386e9$var$tooltips[hideTooltipId](true);
        delete $af9cde49ea815e766aeca6386e9$var$tooltips[hideTooltipId];
      }
    }
  };

  let showTooltip = () => {
    clearTimeout(closeTimeout.current);
    closeTimeout.current = null;
    closeOpenTooltips();
    ensureTooltipEntry();
    $af9cde49ea815e766aeca6386e9$var$globalWarmedUp = true;
    open();

    if ($af9cde49ea815e766aeca6386e9$var$globalWarmUpTimeout) {
      clearTimeout($af9cde49ea815e766aeca6386e9$var$globalWarmUpTimeout);
      $af9cde49ea815e766aeca6386e9$var$globalWarmUpTimeout = null;
    }

    if ($af9cde49ea815e766aeca6386e9$var$globalCooldownTimeout) {
      clearTimeout($af9cde49ea815e766aeca6386e9$var$globalCooldownTimeout);
      $af9cde49ea815e766aeca6386e9$var$globalCooldownTimeout = null;
    }
  };

  let hideTooltip = immediate => {
    if (immediate) {
      clearTimeout(closeTimeout.current);
      closeTimeout.current = null;
      close();
    } else if (!closeTimeout.current) {
      closeTimeout.current = setTimeout(() => {
        closeTimeout.current = null;
        close();
      }, $af9cde49ea815e766aeca6386e9$var$TOOLTIP_COOLDOWN);
    }

    if ($af9cde49ea815e766aeca6386e9$var$globalWarmUpTimeout) {
      clearTimeout($af9cde49ea815e766aeca6386e9$var$globalWarmUpTimeout);
      $af9cde49ea815e766aeca6386e9$var$globalWarmUpTimeout = null;
    }

    if ($af9cde49ea815e766aeca6386e9$var$globalWarmedUp) {
      if ($af9cde49ea815e766aeca6386e9$var$globalCooldownTimeout) {
        clearTimeout($af9cde49ea815e766aeca6386e9$var$globalCooldownTimeout);
      }

      $af9cde49ea815e766aeca6386e9$var$globalCooldownTimeout = setTimeout(() => {
        delete $af9cde49ea815e766aeca6386e9$var$tooltips[id];
        $af9cde49ea815e766aeca6386e9$var$globalCooldownTimeout = null;
        $af9cde49ea815e766aeca6386e9$var$globalWarmedUp = false;
      }, $af9cde49ea815e766aeca6386e9$var$TOOLTIP_COOLDOWN);
    }
  };

  let warmupTooltip = () => {
    closeOpenTooltips();
    ensureTooltipEntry();

    if (!isOpen && !$af9cde49ea815e766aeca6386e9$var$globalWarmUpTimeout && !$af9cde49ea815e766aeca6386e9$var$globalWarmedUp) {
      $af9cde49ea815e766aeca6386e9$var$globalWarmUpTimeout = setTimeout(() => {
        $af9cde49ea815e766aeca6386e9$var$globalWarmUpTimeout = null;
        $af9cde49ea815e766aeca6386e9$var$globalWarmedUp = true;
        showTooltip();
      }, delay);
    } else if (!isOpen) {
      showTooltip();
    }
  }; // eslint-disable-next-line arrow-body-style


  useEffect(() => {
    return () => {
      clearTimeout(closeTimeout.current);
      let tooltip = $af9cde49ea815e766aeca6386e9$var$tooltips[id];

      if (tooltip) {
        delete $af9cde49ea815e766aeca6386e9$var$tooltips[id];
      }
    };
  }, [id]);
  return {
    isOpen,
    open: immediate => {
      if (!immediate && delay > 0 && !closeTimeout.current) {
        warmupTooltip();
      } else {
        showTooltip();
      }
    },
    close: hideTooltip
  };
}

const TOOLTIP_DELAY = 500;
const TOOLTIP_OFFSET = 10;
const Tooltip = props => {
  const {
    renderTrigger,
    children,
    placement = 'bottom',
    isOpen,
    defaultOpen,
    onOpen,
    onClose,
    delay = TOOLTIP_DELAY,
    offset = TOOLTIP_OFFSET,
    crossOffset,
    isDisabled,
    shouldFlip = true,
    hideArrow
  } = props;
  const overlayRef = useRef();

  const _triggerRef = useRef();

  const tooltipTriggerRef = props.triggerRef || _triggerRef;
  const onOpenChange = useCallback($isOpen => {
    if ($isOpen && onOpen) onOpen();
    if (!$isOpen && onClose) onClose();
  }, [onClose, onOpen]);
  let state = useTooltipTriggerState({
    isOpen,
    defaultOpen,
    delay,
    isDisabled,
    onOpenChange
  }); // Get props for the trigger and overlay. This also handles
  // hiding the overlay when a parent element of the trigger scrolls
  // (which invalidates the popover positioning).

  let {
    triggerProps,
    tooltipProps
  } = useTooltipTrigger({
    isDisabled
  }, state, tooltipTriggerRef); // Get popover positioning props relative to the trigger

  let {
    overlayProps: positionProps,
    arrowProps,
    arrowIcon
  } = useOverlayPosition({
    targetRef: tooltipTriggerRef,
    overlayRef,
    placement,
    offset,
    crossOffset,
    shouldFlip,
    isOpen: state.isOpen,
    onClose
  });
  const triggerElem = runIfFn(renderTrigger, {
    isOpen: state.isOpen
  });
  return jsxs(FocusableProvider, Object.assign({}, triggerProps, {
    ref: tooltipTriggerRef
  }, {
    children: [/*#__PURE__*/_react.cloneElement(triggerElem, { ...mergeProps(triggerElem.props, triggerProps),
      ref: tooltipTriggerRef
    }), jsx(_Overlay, Object.assign({
      isOpen: state.isOpen
    }, {
      children: jsxs(TooltipWrapper, Object.assign({}, tooltipProps, positionProps, {
        ref: overlayRef,
        state: state
      }, {
        children: [runIfFn(children, {
          close: state.close
        }), !hideArrow && jsx(TooltipArrow, {
          icon: arrowIcon,
          style: arrowProps.style
        }, void 0)]
      }), void 0)
    }), void 0)]
  }), void 0);
};
const TooltipWrapper = /*#__PURE__*/forwardRef(({
  children,
  state,
  ...otherProps
}, ref) => {
  const isDark = useThemeIsDark(); // Handle interacting outside the dialog and pressing
  // the Escape key to close the modal. Using expect-error so that we know when to remove this
  // @ts-expect-error useTooltip typing is incorrect, state is expected

  let {
    tooltipProps
  } = useTooltip({
    children
  }, state);
  const {
    color,
    ...containerProps
  } = mergeProps(tooltipProps, otherProps);
  return jsx(Box, Object.assign({}, containerProps, {
    className: "sl-tooltip",
    ref: ref,
    "data-testid": "tooltip",
    "data-theme": "dark",
    bg: isDark ? 'canvas-dialog' : 'canvas-pure'
  }, {
    children: children
  }), void 0);
});

function TooltipArrow({
  icon,
  style
}) {
  const isDark = useThemeIsDark();
  return jsx(Box, Object.assign({
    className: "sl-tooltip_tip",
    pos: "absolute",
    color: isDark ? 'canvas-dialog' : 'canvas-pure',
    style: style
  }, {
    children: jsx(Icon, {
      icon: icon
    }, void 0)
  }), void 0);
}

const TreeItem = props => {
  return jsx("div", Object.assign({}, props), void 0);
};

var css = "blockquote,dd,dl,figure,h1,h2,h3,h4,h5,h6,hr,p,pre{margin:0}button{background-color:initial;background-image:none}:focus{outline:none}fieldset,ol,ul{margin:0;padding:0}ol,ul{list-style:none}html{font-family:var(--font-ui);line-height:1.5}body{text-rendering:optimizeSpeed;font-family:inherit;line-height:inherit;margin:0;min-height:100vh}*,:after,:before{border:0 solid var(--color-border,currentColor);box-sizing:border-box}hr{border-top-width:1px}img{border-style:solid}textarea{resize:vertical}input::-ms-input-placeholder,textarea::-ms-input-placeholder{color:#a1a1aa}input::-ms-input-placeholder, textarea::-ms-input-placeholder{color:#a1a1aa}input::placeholder,textarea::placeholder{color:#a1a1aa}[role=button],button{cursor:pointer}table{border-collapse:collapse}h1,h2,h3,h4,h5,h6{font-size:inherit;font-weight:inherit}a{color:inherit;text-decoration:inherit}button,input,optgroup,select,textarea{color:inherit;line-height:inherit;padding:0}code,kbd,pre,samp{font-family:var(--font-mono)}audio,canvas,embed,iframe,img,object,svg,video{display:block;vertical-align:middle}img,video{height:auto;max-width:100%}button{font-family:var(--font-ui)}select{-moz-appearance:none;-webkit-appearance:none}select::-ms-expand{display:none}select{font-size:inherit}iframe{border:0}@media (prefers-reduced-motion:reduce){*{animation-duration:.01ms!important;animation-iteration-count:1!important;scroll-behavior:auto!important;transition-duration:.01ms!important}}.sl-content-center{align-content:center}.sl-content-start{align-content:flex-start}.sl-content-end{align-content:flex-end}.sl-content-between{align-content:space-between}.sl-content-around{align-content:space-around}.sl-content-evenly{align-content:space-evenly}.sl-items-start{align-items:flex-start}.sl-items-end{align-items:flex-end}.sl-items-center{align-items:center}.sl-items-baseline{align-items:baseline}.sl-items-stretch{align-items:stretch}.sl-self-auto{align-self:auto}.sl-self-start{align-self:flex-start}.sl-self-end{align-self:flex-end}.sl-self-center{align-self:center}.sl-self-stretch{align-self:stretch}.sl-bg-transparent{background-color:initial}.sl-bg-current{background-color:currentColor}.sl-bg-lighten-100{background-color:var(--color-lighten-100)}.sl-bg-darken-100{background-color:var(--color-darken-100)}.sl-bg-primary{background-color:var(--color-primary)}.sl-bg-primary-tint{background-color:var(--color-primary-tint)}.sl-bg-primary-light{background-color:var(--color-primary-light)}.sl-bg-primary-dark{background-color:var(--color-primary-dark)}.sl-bg-primary-darker{background-color:var(--color-primary-darker)}.sl-bg-success{background-color:var(--color-success)}.sl-bg-success-tint{background-color:var(--color-success-tint)}.sl-bg-success-light{background-color:var(--color-success-light)}.sl-bg-success-dark{background-color:var(--color-success-dark)}.sl-bg-success-darker{background-color:var(--color-success-darker)}.sl-bg-warning{background-color:var(--color-warning)}.sl-bg-warning-tint{background-color:var(--color-warning-tint)}.sl-bg-warning-light{background-color:var(--color-warning-light)}.sl-bg-warning-dark{background-color:var(--color-warning-dark)}.sl-bg-warning-darker{background-color:var(--color-warning-darker)}.sl-bg-danger{background-color:var(--color-danger)}.sl-bg-danger-tint{background-color:var(--color-danger-tint)}.sl-bg-danger-light{background-color:var(--color-danger-light)}.sl-bg-danger-dark{background-color:var(--color-danger-dark)}.sl-bg-danger-darker{background-color:var(--color-danger-darker)}.sl-bg-code{background-color:var(--color-code)}.sl-bg-on-code{background-color:var(--color-on-code)}.sl-bg-on-primary{background-color:var(--color-on-primary)}.sl-bg-on-success{background-color:var(--color-on-success)}.sl-bg-on-warning{background-color:var(--color-on-warning)}.sl-bg-on-danger{background-color:var(--color-on-danger)}.sl-bg-canvas-50{background-color:var(--color-canvas-50)}.sl-bg-canvas-100{background-color:var(--color-canvas-100)}.sl-bg-canvas-200{background-color:var(--color-canvas-200)}.sl-bg-canvas-300{background-color:var(--color-canvas-300)}.sl-bg-canvas-400{background-color:var(--color-canvas-400)}.sl-bg-canvas-500{background-color:var(--color-canvas-500)}.sl-bg-canvas-pure{background-color:var(--color-canvas-pure)}.sl-bg-canvas{background-color:var(--color-canvas)}.sl-bg-canvas-tint{background-color:var(--color-canvas-tint)}.sl-bg-canvas-dialog{background-color:var(--color-canvas-dialog)}.sl-bg-body{background-color:var(--color-text)}.sl-bg-body-muted{background-color:var(--color-text-muted)}.sl-bg-body-light{background-color:var(--color-text-light)}.hover\\:sl-bg-transparent:hover{background-color:initial}.hover\\:sl-bg-current:hover{background-color:currentColor}.hover\\:sl-bg-lighten-100:hover{background-color:var(--color-lighten-100)}.hover\\:sl-bg-darken-100:hover{background-color:var(--color-darken-100)}.hover\\:sl-bg-primary:hover{background-color:var(--color-primary)}.hover\\:sl-bg-primary-tint:hover{background-color:var(--color-primary-tint)}.hover\\:sl-bg-primary-light:hover{background-color:var(--color-primary-light)}.hover\\:sl-bg-primary-dark:hover{background-color:var(--color-primary-dark)}.hover\\:sl-bg-primary-darker:hover{background-color:var(--color-primary-darker)}.hover\\:sl-bg-success:hover{background-color:var(--color-success)}.hover\\:sl-bg-success-tint:hover{background-color:var(--color-success-tint)}.hover\\:sl-bg-success-light:hover{background-color:var(--color-success-light)}.hover\\:sl-bg-success-dark:hover{background-color:var(--color-success-dark)}.hover\\:sl-bg-success-darker:hover{background-color:var(--color-success-darker)}.hover\\:sl-bg-warning:hover{background-color:var(--color-warning)}.hover\\:sl-bg-warning-tint:hover{background-color:var(--color-warning-tint)}.hover\\:sl-bg-warning-light:hover{background-color:var(--color-warning-light)}.hover\\:sl-bg-warning-dark:hover{background-color:var(--color-warning-dark)}.hover\\:sl-bg-warning-darker:hover{background-color:var(--color-warning-darker)}.hover\\:sl-bg-danger:hover{background-color:var(--color-danger)}.hover\\:sl-bg-danger-tint:hover{background-color:var(--color-danger-tint)}.hover\\:sl-bg-danger-light:hover{background-color:var(--color-danger-light)}.hover\\:sl-bg-danger-dark:hover{background-color:var(--color-danger-dark)}.hover\\:sl-bg-danger-darker:hover{background-color:var(--color-danger-darker)}.hover\\:sl-bg-code:hover{background-color:var(--color-code)}.hover\\:sl-bg-on-code:hover{background-color:var(--color-on-code)}.hover\\:sl-bg-on-primary:hover{background-color:var(--color-on-primary)}.hover\\:sl-bg-on-success:hover{background-color:var(--color-on-success)}.hover\\:sl-bg-on-warning:hover{background-color:var(--color-on-warning)}.hover\\:sl-bg-on-danger:hover{background-color:var(--color-on-danger)}.hover\\:sl-bg-canvas-50:hover{background-color:var(--color-canvas-50)}.hover\\:sl-bg-canvas-100:hover{background-color:var(--color-canvas-100)}.hover\\:sl-bg-canvas-200:hover{background-color:var(--color-canvas-200)}.hover\\:sl-bg-canvas-300:hover{background-color:var(--color-canvas-300)}.hover\\:sl-bg-canvas-400:hover{background-color:var(--color-canvas-400)}.hover\\:sl-bg-canvas-500:hover{background-color:var(--color-canvas-500)}.hover\\:sl-bg-canvas-pure:hover{background-color:var(--color-canvas-pure)}.hover\\:sl-bg-canvas:hover{background-color:var(--color-canvas)}.hover\\:sl-bg-canvas-tint:hover{background-color:var(--color-canvas-tint)}.hover\\:sl-bg-canvas-dialog:hover{background-color:var(--color-canvas-dialog)}.hover\\:sl-bg-body:hover{background-color:var(--color-text)}.hover\\:sl-bg-body-muted:hover{background-color:var(--color-text-muted)}.hover\\:sl-bg-body-light:hover{background-color:var(--color-text-light)}.focus\\:sl-bg-transparent:focus{background-color:initial}.focus\\:sl-bg-current:focus{background-color:currentColor}.focus\\:sl-bg-lighten-100:focus{background-color:var(--color-lighten-100)}.focus\\:sl-bg-darken-100:focus{background-color:var(--color-darken-100)}.focus\\:sl-bg-primary:focus{background-color:var(--color-primary)}.focus\\:sl-bg-primary-tint:focus{background-color:var(--color-primary-tint)}.focus\\:sl-bg-primary-light:focus{background-color:var(--color-primary-light)}.focus\\:sl-bg-primary-dark:focus{background-color:var(--color-primary-dark)}.focus\\:sl-bg-primary-darker:focus{background-color:var(--color-primary-darker)}.focus\\:sl-bg-success:focus{background-color:var(--color-success)}.focus\\:sl-bg-success-tint:focus{background-color:var(--color-success-tint)}.focus\\:sl-bg-success-light:focus{background-color:var(--color-success-light)}.focus\\:sl-bg-success-dark:focus{background-color:var(--color-success-dark)}.focus\\:sl-bg-success-darker:focus{background-color:var(--color-success-darker)}.focus\\:sl-bg-warning:focus{background-color:var(--color-warning)}.focus\\:sl-bg-warning-tint:focus{background-color:var(--color-warning-tint)}.focus\\:sl-bg-warning-light:focus{background-color:var(--color-warning-light)}.focus\\:sl-bg-warning-dark:focus{background-color:var(--color-warning-dark)}.focus\\:sl-bg-warning-darker:focus{background-color:var(--color-warning-darker)}.focus\\:sl-bg-danger:focus{background-color:var(--color-danger)}.focus\\:sl-bg-danger-tint:focus{background-color:var(--color-danger-tint)}.focus\\:sl-bg-danger-light:focus{background-color:var(--color-danger-light)}.focus\\:sl-bg-danger-dark:focus{background-color:var(--color-danger-dark)}.focus\\:sl-bg-danger-darker:focus{background-color:var(--color-danger-darker)}.focus\\:sl-bg-code:focus{background-color:var(--color-code)}.focus\\:sl-bg-on-code:focus{background-color:var(--color-on-code)}.focus\\:sl-bg-on-primary:focus{background-color:var(--color-on-primary)}.focus\\:sl-bg-on-success:focus{background-color:var(--color-on-success)}.focus\\:sl-bg-on-warning:focus{background-color:var(--color-on-warning)}.focus\\:sl-bg-on-danger:focus{background-color:var(--color-on-danger)}.focus\\:sl-bg-canvas-50:focus{background-color:var(--color-canvas-50)}.focus\\:sl-bg-canvas-100:focus{background-color:var(--color-canvas-100)}.focus\\:sl-bg-canvas-200:focus{background-color:var(--color-canvas-200)}.focus\\:sl-bg-canvas-300:focus{background-color:var(--color-canvas-300)}.focus\\:sl-bg-canvas-400:focus{background-color:var(--color-canvas-400)}.focus\\:sl-bg-canvas-500:focus{background-color:var(--color-canvas-500)}.focus\\:sl-bg-canvas-pure:focus{background-color:var(--color-canvas-pure)}.focus\\:sl-bg-canvas:focus{background-color:var(--color-canvas)}.focus\\:sl-bg-canvas-tint:focus{background-color:var(--color-canvas-tint)}.focus\\:sl-bg-canvas-dialog:focus{background-color:var(--color-canvas-dialog)}.focus\\:sl-bg-body:focus{background-color:var(--color-text)}.focus\\:sl-bg-body-muted:focus{background-color:var(--color-text-muted)}.focus\\:sl-bg-body-light:focus{background-color:var(--color-text-light)}.active\\:sl-bg-transparent:active{background-color:initial}.active\\:sl-bg-current:active{background-color:currentColor}.active\\:sl-bg-lighten-100:active{background-color:var(--color-lighten-100)}.active\\:sl-bg-darken-100:active{background-color:var(--color-darken-100)}.active\\:sl-bg-primary:active{background-color:var(--color-primary)}.active\\:sl-bg-primary-tint:active{background-color:var(--color-primary-tint)}.active\\:sl-bg-primary-light:active{background-color:var(--color-primary-light)}.active\\:sl-bg-primary-dark:active{background-color:var(--color-primary-dark)}.active\\:sl-bg-primary-darker:active{background-color:var(--color-primary-darker)}.active\\:sl-bg-success:active{background-color:var(--color-success)}.active\\:sl-bg-success-tint:active{background-color:var(--color-success-tint)}.active\\:sl-bg-success-light:active{background-color:var(--color-success-light)}.active\\:sl-bg-success-dark:active{background-color:var(--color-success-dark)}.active\\:sl-bg-success-darker:active{background-color:var(--color-success-darker)}.active\\:sl-bg-warning:active{background-color:var(--color-warning)}.active\\:sl-bg-warning-tint:active{background-color:var(--color-warning-tint)}.active\\:sl-bg-warning-light:active{background-color:var(--color-warning-light)}.active\\:sl-bg-warning-dark:active{background-color:var(--color-warning-dark)}.active\\:sl-bg-warning-darker:active{background-color:var(--color-warning-darker)}.active\\:sl-bg-danger:active{background-color:var(--color-danger)}.active\\:sl-bg-danger-tint:active{background-color:var(--color-danger-tint)}.active\\:sl-bg-danger-light:active{background-color:var(--color-danger-light)}.active\\:sl-bg-danger-dark:active{background-color:var(--color-danger-dark)}.active\\:sl-bg-danger-darker:active{background-color:var(--color-danger-darker)}.active\\:sl-bg-code:active{background-color:var(--color-code)}.active\\:sl-bg-on-code:active{background-color:var(--color-on-code)}.active\\:sl-bg-on-primary:active{background-color:var(--color-on-primary)}.active\\:sl-bg-on-success:active{background-color:var(--color-on-success)}.active\\:sl-bg-on-warning:active{background-color:var(--color-on-warning)}.active\\:sl-bg-on-danger:active{background-color:var(--color-on-danger)}.active\\:sl-bg-canvas-50:active{background-color:var(--color-canvas-50)}.active\\:sl-bg-canvas-100:active{background-color:var(--color-canvas-100)}.active\\:sl-bg-canvas-200:active{background-color:var(--color-canvas-200)}.active\\:sl-bg-canvas-300:active{background-color:var(--color-canvas-300)}.active\\:sl-bg-canvas-400:active{background-color:var(--color-canvas-400)}.active\\:sl-bg-canvas-500:active{background-color:var(--color-canvas-500)}.active\\:sl-bg-canvas-pure:active{background-color:var(--color-canvas-pure)}.active\\:sl-bg-canvas:active{background-color:var(--color-canvas)}.active\\:sl-bg-canvas-tint:active{background-color:var(--color-canvas-tint)}.active\\:sl-bg-canvas-dialog:active{background-color:var(--color-canvas-dialog)}.active\\:sl-bg-body:active{background-color:var(--color-text)}.active\\:sl-bg-body-muted:active{background-color:var(--color-text-muted)}.active\\:sl-bg-body-light:active{background-color:var(--color-text-light)}.disabled\\:sl-bg-transparent:disabled{background-color:initial}.disabled\\:sl-bg-current:disabled{background-color:currentColor}.disabled\\:sl-bg-lighten-100:disabled{background-color:var(--color-lighten-100)}.disabled\\:sl-bg-darken-100:disabled{background-color:var(--color-darken-100)}.disabled\\:sl-bg-primary:disabled{background-color:var(--color-primary)}.disabled\\:sl-bg-primary-tint:disabled{background-color:var(--color-primary-tint)}.disabled\\:sl-bg-primary-light:disabled{background-color:var(--color-primary-light)}.disabled\\:sl-bg-primary-dark:disabled{background-color:var(--color-primary-dark)}.disabled\\:sl-bg-primary-darker:disabled{background-color:var(--color-primary-darker)}.disabled\\:sl-bg-success:disabled{background-color:var(--color-success)}.disabled\\:sl-bg-success-tint:disabled{background-color:var(--color-success-tint)}.disabled\\:sl-bg-success-light:disabled{background-color:var(--color-success-light)}.disabled\\:sl-bg-success-dark:disabled{background-color:var(--color-success-dark)}.disabled\\:sl-bg-success-darker:disabled{background-color:var(--color-success-darker)}.disabled\\:sl-bg-warning:disabled{background-color:var(--color-warning)}.disabled\\:sl-bg-warning-tint:disabled{background-color:var(--color-warning-tint)}.disabled\\:sl-bg-warning-light:disabled{background-color:var(--color-warning-light)}.disabled\\:sl-bg-warning-dark:disabled{background-color:var(--color-warning-dark)}.disabled\\:sl-bg-warning-darker:disabled{background-color:var(--color-warning-darker)}.disabled\\:sl-bg-danger:disabled{background-color:var(--color-danger)}.disabled\\:sl-bg-danger-tint:disabled{background-color:var(--color-danger-tint)}.disabled\\:sl-bg-danger-light:disabled{background-color:var(--color-danger-light)}.disabled\\:sl-bg-danger-dark:disabled{background-color:var(--color-danger-dark)}.disabled\\:sl-bg-danger-darker:disabled{background-color:var(--color-danger-darker)}.disabled\\:sl-bg-code:disabled{background-color:var(--color-code)}.disabled\\:sl-bg-on-code:disabled{background-color:var(--color-on-code)}.disabled\\:sl-bg-on-primary:disabled{background-color:var(--color-on-primary)}.disabled\\:sl-bg-on-success:disabled{background-color:var(--color-on-success)}.disabled\\:sl-bg-on-warning:disabled{background-color:var(--color-on-warning)}.disabled\\:sl-bg-on-danger:disabled{background-color:var(--color-on-danger)}.disabled\\:sl-bg-canvas-50:disabled{background-color:var(--color-canvas-50)}.disabled\\:sl-bg-canvas-100:disabled{background-color:var(--color-canvas-100)}.disabled\\:sl-bg-canvas-200:disabled{background-color:var(--color-canvas-200)}.disabled\\:sl-bg-canvas-300:disabled{background-color:var(--color-canvas-300)}.disabled\\:sl-bg-canvas-400:disabled{background-color:var(--color-canvas-400)}.disabled\\:sl-bg-canvas-500:disabled{background-color:var(--color-canvas-500)}.disabled\\:sl-bg-canvas-pure:disabled{background-color:var(--color-canvas-pure)}.disabled\\:sl-bg-canvas:disabled{background-color:var(--color-canvas)}.disabled\\:sl-bg-canvas-tint:disabled{background-color:var(--color-canvas-tint)}.disabled\\:sl-bg-canvas-dialog:disabled{background-color:var(--color-canvas-dialog)}.disabled\\:sl-bg-body:disabled{background-color:var(--color-text)}.disabled\\:sl-bg-body-muted:disabled{background-color:var(--color-text-muted)}.disabled\\:sl-bg-body-light:disabled{background-color:var(--color-text-light)}.sl-bg-none{background-image:none}.sl-bg-gradient-to-t{background-image:linear-gradient(to top,var(--tw-gradient-stops))}.sl-bg-gradient-to-tr{background-image:linear-gradient(to top right,var(--tw-gradient-stops))}.sl-bg-gradient-to-r{background-image:linear-gradient(to right,var(--tw-gradient-stops))}.sl-bg-gradient-to-br{background-image:linear-gradient(to bottom right,var(--tw-gradient-stops))}.sl-bg-gradient-to-b{background-image:linear-gradient(to bottom,var(--tw-gradient-stops))}.sl-bg-gradient-to-bl{background-image:linear-gradient(to bottom left,var(--tw-gradient-stops))}.sl-bg-gradient-to-l{background-image:linear-gradient(to left,var(--tw-gradient-stops))}.sl-bg-gradient-to-tl{background-image:linear-gradient(to top left,var(--tw-gradient-stops))}.sl-blur-0,.sl-blur-none{--tw-blur:blur(0)}.sl-blur-sm{--tw-blur:blur(4px)}.sl-blur{--tw-blur:blur(8px)}.sl-blur-md{--tw-blur:blur(12px)}.sl-blur-lg{--tw-blur:blur(16px)}.sl-blur-xl{--tw-blur:blur(24px)}.sl-blur-2xl{--tw-blur:blur(40px)}.sl-blur-3xl{--tw-blur:blur(64px)}.sl-border-transparent{border-color:transparent}.sl-border-current{border-color:currentColor}.sl-border-lighten-100{border-color:var(--color-lighten-100)}.sl-border-darken-100{border-color:var(--color-darken-100)}.sl-border-primary{border-color:var(--color-primary)}.sl-border-primary-tint{border-color:var(--color-primary-tint)}.sl-border-primary-light{border-color:var(--color-primary-light)}.sl-border-primary-dark{border-color:var(--color-primary-dark)}.sl-border-primary-darker{border-color:var(--color-primary-darker)}.sl-border-success{border-color:var(--color-success)}.sl-border-success-tint{border-color:var(--color-success-tint)}.sl-border-success-light{border-color:var(--color-success-light)}.sl-border-success-dark{border-color:var(--color-success-dark)}.sl-border-success-darker{border-color:var(--color-success-darker)}.sl-border-warning{border-color:var(--color-warning)}.sl-border-warning-tint{border-color:var(--color-warning-tint)}.sl-border-warning-light{border-color:var(--color-warning-light)}.sl-border-warning-dark{border-color:var(--color-warning-dark)}.sl-border-warning-darker{border-color:var(--color-warning-darker)}.sl-border-danger{border-color:var(--color-danger)}.sl-border-danger-tint{border-color:var(--color-danger-tint)}.sl-border-danger-light{border-color:var(--color-danger-light)}.sl-border-danger-dark{border-color:var(--color-danger-dark)}.sl-border-danger-darker{border-color:var(--color-danger-darker)}.sl-border-code{border-color:var(--color-code)}.sl-border-on-code{border-color:var(--color-on-code)}.sl-border-on-primary{border-color:var(--color-on-primary)}.sl-border-on-success{border-color:var(--color-on-success)}.sl-border-on-warning{border-color:var(--color-on-warning)}.sl-border-on-danger{border-color:var(--color-on-danger)}.sl-border-light{border-color:var(--color-border-light)}.sl-border-dark{border-color:var(--color-border-dark)}.sl-border-button{border-color:var(--color-border-button)}.sl-border-input{border-color:var(--color-border-input)}.sl-border-body{border-color:var(--color-text)}.hover\\:sl-border-transparent:hover{border-color:transparent}.hover\\:sl-border-current:hover{border-color:currentColor}.hover\\:sl-border-lighten-100:hover{border-color:var(--color-lighten-100)}.hover\\:sl-border-darken-100:hover{border-color:var(--color-darken-100)}.hover\\:sl-border-primary:hover{border-color:var(--color-primary)}.hover\\:sl-border-primary-tint:hover{border-color:var(--color-primary-tint)}.hover\\:sl-border-primary-light:hover{border-color:var(--color-primary-light)}.hover\\:sl-border-primary-dark:hover{border-color:var(--color-primary-dark)}.hover\\:sl-border-primary-darker:hover{border-color:var(--color-primary-darker)}.hover\\:sl-border-success:hover{border-color:var(--color-success)}.hover\\:sl-border-success-tint:hover{border-color:var(--color-success-tint)}.hover\\:sl-border-success-light:hover{border-color:var(--color-success-light)}.hover\\:sl-border-success-dark:hover{border-color:var(--color-success-dark)}.hover\\:sl-border-success-darker:hover{border-color:var(--color-success-darker)}.hover\\:sl-border-warning:hover{border-color:var(--color-warning)}.hover\\:sl-border-warning-tint:hover{border-color:var(--color-warning-tint)}.hover\\:sl-border-warning-light:hover{border-color:var(--color-warning-light)}.hover\\:sl-border-warning-dark:hover{border-color:var(--color-warning-dark)}.hover\\:sl-border-warning-darker:hover{border-color:var(--color-warning-darker)}.hover\\:sl-border-danger:hover{border-color:var(--color-danger)}.hover\\:sl-border-danger-tint:hover{border-color:var(--color-danger-tint)}.hover\\:sl-border-danger-light:hover{border-color:var(--color-danger-light)}.hover\\:sl-border-danger-dark:hover{border-color:var(--color-danger-dark)}.hover\\:sl-border-danger-darker:hover{border-color:var(--color-danger-darker)}.hover\\:sl-border-code:hover{border-color:var(--color-code)}.hover\\:sl-border-on-code:hover{border-color:var(--color-on-code)}.hover\\:sl-border-on-primary:hover{border-color:var(--color-on-primary)}.hover\\:sl-border-on-success:hover{border-color:var(--color-on-success)}.hover\\:sl-border-on-warning:hover{border-color:var(--color-on-warning)}.hover\\:sl-border-on-danger:hover{border-color:var(--color-on-danger)}.hover\\:sl-border-light:hover{border-color:var(--color-border-light)}.hover\\:sl-border-dark:hover{border-color:var(--color-border-dark)}.hover\\:sl-border-button:hover{border-color:var(--color-border-button)}.hover\\:sl-border-input:hover{border-color:var(--color-border-input)}.hover\\:sl-border-body:hover{border-color:var(--color-text)}.focus\\:sl-border-transparent:focus{border-color:transparent}.focus\\:sl-border-current:focus{border-color:currentColor}.focus\\:sl-border-lighten-100:focus{border-color:var(--color-lighten-100)}.focus\\:sl-border-darken-100:focus{border-color:var(--color-darken-100)}.focus\\:sl-border-primary:focus{border-color:var(--color-primary)}.focus\\:sl-border-primary-tint:focus{border-color:var(--color-primary-tint)}.focus\\:sl-border-primary-light:focus{border-color:var(--color-primary-light)}.focus\\:sl-border-primary-dark:focus{border-color:var(--color-primary-dark)}.focus\\:sl-border-primary-darker:focus{border-color:var(--color-primary-darker)}.focus\\:sl-border-success:focus{border-color:var(--color-success)}.focus\\:sl-border-success-tint:focus{border-color:var(--color-success-tint)}.focus\\:sl-border-success-light:focus{border-color:var(--color-success-light)}.focus\\:sl-border-success-dark:focus{border-color:var(--color-success-dark)}.focus\\:sl-border-success-darker:focus{border-color:var(--color-success-darker)}.focus\\:sl-border-warning:focus{border-color:var(--color-warning)}.focus\\:sl-border-warning-tint:focus{border-color:var(--color-warning-tint)}.focus\\:sl-border-warning-light:focus{border-color:var(--color-warning-light)}.focus\\:sl-border-warning-dark:focus{border-color:var(--color-warning-dark)}.focus\\:sl-border-warning-darker:focus{border-color:var(--color-warning-darker)}.focus\\:sl-border-danger:focus{border-color:var(--color-danger)}.focus\\:sl-border-danger-tint:focus{border-color:var(--color-danger-tint)}.focus\\:sl-border-danger-light:focus{border-color:var(--color-danger-light)}.focus\\:sl-border-danger-dark:focus{border-color:var(--color-danger-dark)}.focus\\:sl-border-danger-darker:focus{border-color:var(--color-danger-darker)}.focus\\:sl-border-code:focus{border-color:var(--color-code)}.focus\\:sl-border-on-code:focus{border-color:var(--color-on-code)}.focus\\:sl-border-on-primary:focus{border-color:var(--color-on-primary)}.focus\\:sl-border-on-success:focus{border-color:var(--color-on-success)}.focus\\:sl-border-on-warning:focus{border-color:var(--color-on-warning)}.focus\\:sl-border-on-danger:focus{border-color:var(--color-on-danger)}.focus\\:sl-border-light:focus{border-color:var(--color-border-light)}.focus\\:sl-border-dark:focus{border-color:var(--color-border-dark)}.focus\\:sl-border-button:focus{border-color:var(--color-border-button)}.focus\\:sl-border-input:focus{border-color:var(--color-border-input)}.focus\\:sl-border-body:focus{border-color:var(--color-text)}.active\\:sl-border-transparent:active{border-color:transparent}.active\\:sl-border-current:active{border-color:currentColor}.active\\:sl-border-lighten-100:active{border-color:var(--color-lighten-100)}.active\\:sl-border-darken-100:active{border-color:var(--color-darken-100)}.active\\:sl-border-primary:active{border-color:var(--color-primary)}.active\\:sl-border-primary-tint:active{border-color:var(--color-primary-tint)}.active\\:sl-border-primary-light:active{border-color:var(--color-primary-light)}.active\\:sl-border-primary-dark:active{border-color:var(--color-primary-dark)}.active\\:sl-border-primary-darker:active{border-color:var(--color-primary-darker)}.active\\:sl-border-success:active{border-color:var(--color-success)}.active\\:sl-border-success-tint:active{border-color:var(--color-success-tint)}.active\\:sl-border-success-light:active{border-color:var(--color-success-light)}.active\\:sl-border-success-dark:active{border-color:var(--color-success-dark)}.active\\:sl-border-success-darker:active{border-color:var(--color-success-darker)}.active\\:sl-border-warning:active{border-color:var(--color-warning)}.active\\:sl-border-warning-tint:active{border-color:var(--color-warning-tint)}.active\\:sl-border-warning-light:active{border-color:var(--color-warning-light)}.active\\:sl-border-warning-dark:active{border-color:var(--color-warning-dark)}.active\\:sl-border-warning-darker:active{border-color:var(--color-warning-darker)}.active\\:sl-border-danger:active{border-color:var(--color-danger)}.active\\:sl-border-danger-tint:active{border-color:var(--color-danger-tint)}.active\\:sl-border-danger-light:active{border-color:var(--color-danger-light)}.active\\:sl-border-danger-dark:active{border-color:var(--color-danger-dark)}.active\\:sl-border-danger-darker:active{border-color:var(--color-danger-darker)}.active\\:sl-border-code:active{border-color:var(--color-code)}.active\\:sl-border-on-code:active{border-color:var(--color-on-code)}.active\\:sl-border-on-primary:active{border-color:var(--color-on-primary)}.active\\:sl-border-on-success:active{border-color:var(--color-on-success)}.active\\:sl-border-on-warning:active{border-color:var(--color-on-warning)}.active\\:sl-border-on-danger:active{border-color:var(--color-on-danger)}.active\\:sl-border-light:active{border-color:var(--color-border-light)}.active\\:sl-border-dark:active{border-color:var(--color-border-dark)}.active\\:sl-border-button:active{border-color:var(--color-border-button)}.active\\:sl-border-input:active{border-color:var(--color-border-input)}.active\\:sl-border-body:active{border-color:var(--color-text)}.sl-rounded-none{border-radius:0}.sl-rounded-sm{border-radius:1px}.sl-rounded{border-radius:2px}.sl-rounded-lg{border-radius:5px}.sl-rounded-xl{border-radius:7px}.sl-rounded-full{border-radius:9999px}.sl-rounded-t-none{border-top-left-radius:0;border-top-right-radius:0}.sl-rounded-r-none{border-bottom-right-radius:0;border-top-right-radius:0}.sl-rounded-b-none{border-bottom-left-radius:0;border-bottom-right-radius:0}.sl-rounded-l-none{border-bottom-left-radius:0;border-top-left-radius:0}.sl-rounded-t-sm{border-top-left-radius:1px;border-top-right-radius:1px}.sl-rounded-r-sm{border-bottom-right-radius:1px;border-top-right-radius:1px}.sl-rounded-b-sm{border-bottom-left-radius:1px;border-bottom-right-radius:1px}.sl-rounded-l-sm{border-bottom-left-radius:1px;border-top-left-radius:1px}.sl-rounded-t{border-top-left-radius:2px;border-top-right-radius:2px}.sl-rounded-r{border-top-right-radius:2px}.sl-rounded-b,.sl-rounded-r{border-bottom-right-radius:2px}.sl-rounded-b,.sl-rounded-l{border-bottom-left-radius:2px}.sl-rounded-l{border-top-left-radius:2px}.sl-rounded-t-lg{border-top-left-radius:5px;border-top-right-radius:5px}.sl-rounded-r-lg{border-bottom-right-radius:5px;border-top-right-radius:5px}.sl-rounded-b-lg{border-bottom-left-radius:5px;border-bottom-right-radius:5px}.sl-rounded-l-lg{border-bottom-left-radius:5px;border-top-left-radius:5px}.sl-rounded-t-xl{border-top-left-radius:7px;border-top-right-radius:7px}.sl-rounded-r-xl{border-bottom-right-radius:7px;border-top-right-radius:7px}.sl-rounded-b-xl{border-bottom-left-radius:7px;border-bottom-right-radius:7px}.sl-rounded-l-xl{border-bottom-left-radius:7px;border-top-left-radius:7px}.sl-rounded-t-full{border-top-left-radius:9999px;border-top-right-radius:9999px}.sl-rounded-r-full{border-bottom-right-radius:9999px;border-top-right-radius:9999px}.sl-rounded-b-full{border-bottom-left-radius:9999px;border-bottom-right-radius:9999px}.sl-rounded-l-full{border-bottom-left-radius:9999px;border-top-left-radius:9999px}.sl-rounded-tl-none{border-top-left-radius:0}.sl-rounded-tr-none{border-top-right-radius:0}.sl-rounded-br-none{border-bottom-right-radius:0}.sl-rounded-bl-none{border-bottom-left-radius:0}.sl-rounded-tl-sm{border-top-left-radius:1px}.sl-rounded-tr-sm{border-top-right-radius:1px}.sl-rounded-br-sm{border-bottom-right-radius:1px}.sl-rounded-bl-sm{border-bottom-left-radius:1px}.sl-rounded-tl{border-top-left-radius:2px}.sl-rounded-tr{border-top-right-radius:2px}.sl-rounded-br{border-bottom-right-radius:2px}.sl-rounded-bl{border-bottom-left-radius:2px}.sl-rounded-tl-lg{border-top-left-radius:5px}.sl-rounded-tr-lg{border-top-right-radius:5px}.sl-rounded-br-lg{border-bottom-right-radius:5px}.sl-rounded-bl-lg{border-bottom-left-radius:5px}.sl-rounded-tl-xl{border-top-left-radius:7px}.sl-rounded-tr-xl{border-top-right-radius:7px}.sl-rounded-br-xl{border-bottom-right-radius:7px}.sl-rounded-bl-xl{border-bottom-left-radius:7px}.sl-rounded-tl-full{border-top-left-radius:9999px}.sl-rounded-tr-full{border-top-right-radius:9999px}.sl-rounded-br-full{border-bottom-right-radius:9999px}.sl-rounded-bl-full{border-bottom-left-radius:9999px}.sl-border-solid{border-style:solid}.sl-border-dashed{border-style:dashed}.sl-border-dotted{border-style:dotted}.sl-border-double{border-style:double}.sl-border-none{border-style:none}.sl-border-0{border-width:0}.sl-border-2{border-width:2px}.sl-border-4{border-width:4px}.sl-border-8{border-width:8px}.sl-border{border-width:1px}.sl-border-t-0{border-top-width:0}.sl-border-r-0{border-right-width:0}.sl-border-b-0{border-bottom-width:0}.sl-border-l-0{border-left-width:0}.sl-border-t-2{border-top-width:2px}.sl-border-r-2{border-right-width:2px}.sl-border-b-2{border-bottom-width:2px}.sl-border-l-2{border-left-width:2px}.sl-border-t-4{border-top-width:4px}.sl-border-r-4{border-right-width:4px}.sl-border-b-4{border-bottom-width:4px}.sl-border-l-4{border-left-width:4px}.sl-border-t-8{border-top-width:8px}.sl-border-r-8{border-right-width:8px}.sl-border-b-8{border-bottom-width:8px}.sl-border-l-8{border-left-width:8px}.sl-border-t{border-top-width:1px}.sl-border-r{border-right-width:1px}.sl-border-b{border-bottom-width:1px}.sl-border-l{border-left-width:1px}*{--tw-shadow:0 0 #0000}.sl-shadow-sm{--tw-shadow:var(--shadow-sm);box-shadow:var(--tw-ring-offset-shadow,0 0 #0000),var(--tw-ring-shadow,0 0 #0000),var(--tw-shadow)}.sl-shadow,.sl-shadow-md{--tw-shadow:var(--shadow-md)}.sl-shadow,.sl-shadow-lg,.sl-shadow-md{box-shadow:var(--tw-ring-offset-shadow,0 0 #0000),var(--tw-ring-shadow,0 0 #0000),var(--tw-shadow)}.sl-shadow-lg{--tw-shadow:var(--shadow-lg)}.sl-shadow-xl{--tw-shadow:var(--shadow-xl)}.sl-shadow-2xl,.sl-shadow-xl{box-shadow:var(--tw-ring-offset-shadow,0 0 #0000),var(--tw-ring-shadow,0 0 #0000),var(--tw-shadow)}.sl-shadow-2xl{--tw-shadow:var(--shadow-2xl)}.hover\\:sl-shadow-sm:hover{--tw-shadow:var(--shadow-sm);box-shadow:var(--tw-ring-offset-shadow,0 0 #0000),var(--tw-ring-shadow,0 0 #0000),var(--tw-shadow)}.hover\\:sl-shadow-md:hover,.hover\\:sl-shadow:hover{--tw-shadow:var(--shadow-md)}.hover\\:sl-shadow-lg:hover,.hover\\:sl-shadow-md:hover,.hover\\:sl-shadow:hover{box-shadow:var(--tw-ring-offset-shadow,0 0 #0000),var(--tw-ring-shadow,0 0 #0000),var(--tw-shadow)}.hover\\:sl-shadow-lg:hover{--tw-shadow:var(--shadow-lg)}.hover\\:sl-shadow-xl:hover{--tw-shadow:var(--shadow-xl)}.hover\\:sl-shadow-2xl:hover,.hover\\:sl-shadow-xl:hover{box-shadow:var(--tw-ring-offset-shadow,0 0 #0000),var(--tw-ring-shadow,0 0 #0000),var(--tw-shadow)}.hover\\:sl-shadow-2xl:hover{--tw-shadow:var(--shadow-2xl)}.focus\\:sl-shadow-sm:focus{--tw-shadow:var(--shadow-sm);box-shadow:var(--tw-ring-offset-shadow,0 0 #0000),var(--tw-ring-shadow,0 0 #0000),var(--tw-shadow)}.focus\\:sl-shadow-md:focus,.focus\\:sl-shadow:focus{--tw-shadow:var(--shadow-md)}.focus\\:sl-shadow-lg:focus,.focus\\:sl-shadow-md:focus,.focus\\:sl-shadow:focus{box-shadow:var(--tw-ring-offset-shadow,0 0 #0000),var(--tw-ring-shadow,0 0 #0000),var(--tw-shadow)}.focus\\:sl-shadow-lg:focus{--tw-shadow:var(--shadow-lg)}.focus\\:sl-shadow-xl:focus{--tw-shadow:var(--shadow-xl)}.focus\\:sl-shadow-2xl:focus,.focus\\:sl-shadow-xl:focus{box-shadow:var(--tw-ring-offset-shadow,0 0 #0000),var(--tw-ring-shadow,0 0 #0000),var(--tw-shadow)}.focus\\:sl-shadow-2xl:focus{--tw-shadow:var(--shadow-2xl)}.sl-box-border{box-sizing:border-box}.sl-box-content{box-sizing:initial}.sl-cursor-auto{cursor:auto}.sl-cursor{cursor:default}.sl-cursor-pointer{cursor:pointer}.sl-cursor-wait{cursor:wait}.sl-cursor-text{cursor:text}.sl-cursor-move{cursor:move}.sl-cursor-not-allowed{cursor:not-allowed}.sl-cursor-zoom-in{cursor:zoom-in}.sl-cursor-zoom-out{cursor:zoom-out}.sl-block{display:block}.sl-inline-block{display:inline-block}.sl-inline{display:inline}.sl-flex{display:flex}.sl-inline-flex{display:inline-flex}.sl-table{display:table}.sl-inline-table{display:inline-table}.sl-table-caption{display:table-caption}.sl-table-cell{display:table-cell}.sl-table-column{display:table-column}.sl-table-column-group{display:table-column-group}.sl-table-footer-group{display:table-footer-group}.sl-table-header-group{display:table-header-group}.sl-table-row-group{display:table-row-group}.sl-table-row{display:table-row}.sl-flow-root{display:flow-root}.sl-grid{display:grid}.sl-inline-grid{display:inline-grid}.sl-contents{display:contents}.sl-list-item{display:list-item}.sl-hidden{display:none}.sl-drop-shadow{--tw-drop-shadow:drop-shadow(var(--drop-shadow-default1)) drop-shadow(var(--drop-shadow-default2))}.sl-filter{--tw-blur:var(--tw-empty,/*!*/ /*!*/);--tw-brightness:var(--tw-empty,/*!*/ /*!*/);--tw-contrast:var(--tw-empty,/*!*/ /*!*/);--tw-grayscale:var(--tw-empty,/*!*/ /*!*/);--tw-hue-rotate:var(--tw-empty,/*!*/ /*!*/);--tw-invert:var(--tw-empty,/*!*/ /*!*/);--tw-saturate:var(--tw-empty,/*!*/ /*!*/);--tw-sepia:var(--tw-empty,/*!*/ /*!*/);--tw-drop-shadow:var(--tw-empty,/*!*/ /*!*/);filter:var(--tw-blur) var(--tw-brightness) var(--tw-contrast) var(--tw-grayscale) var(--tw-hue-rotate) var(--tw-invert) var(--tw-saturate) var(--tw-sepia) var(--tw-drop-shadow)}.sl-filter-none{filter:none}.sl-flex-1{flex:1 1}.sl-flex-auto{flex:1 1 auto}.sl-flex-initial{flex:0 1 auto}.sl-flex-none{flex:none}.sl-flex-row{flex-direction:row}.sl-flex-row-reverse{flex-direction:row-reverse}.sl-flex-col{flex-direction:column}.sl-flex-col-reverse{flex-direction:column-reverse}.sl-flex-grow-0{flex-grow:0}.sl-flex-grow{flex-grow:1}.sl-flex-shrink-0{flex-shrink:0}.sl-flex-shrink{flex-shrink:1}.sl-flex-wrap{flex-wrap:wrap}.sl-flex-wrap-reverse{flex-wrap:wrap-reverse}.sl-flex-nowrap{flex-wrap:nowrap}.sl-font-sans,.sl-font-ui{font-family:var(--font-ui)}.sl-font-prose{font-family:var(--font-prose)}.sl-font-mono{font-family:var(--font-mono)}.sl-text-2xs{font-size:9px}.sl-text-xs{font-size:10px}.sl-text-sm{font-size:11px}.sl-text-base{font-size:12px}.sl-text-lg{font-size:14px}.sl-text-xl{font-size:16px}.sl-text-2xl{font-size:20px}.sl-text-3xl{font-size:24px}.sl-text-4xl{font-size:28px}.sl-text-5xl{font-size:36px}.sl-text-6xl{font-size:44px}.sl-text-paragraph-leading{font-size:var(--fs-paragraph-leading)}.sl-text-paragraph{font-size:var(--fs-paragraph)}.sl-text-paragraph-small{font-size:var(--fs-paragraph-small)}.sl-text-paragraph-tiny{font-size:var(--fs-paragraph-tiny)}.sl-antialiased{-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale}.sl-subpixel-antialiased{-webkit-font-smoothing:auto;-moz-osx-font-smoothing:auto}.sl-italic{font-style:italic}.sl-not-italic{font-style:normal}.sl-font-light{font-weight:300}.sl-font-normal{font-weight:400}.sl-font-medium{font-weight:500}.sl-font-semibold{font-weight:600}.sl-font-bold{font-weight:700}.sl-h-0{height:0}.sl-h-1{height:4px}.sl-h-2{height:8px}.sl-h-3{height:12px}.sl-h-4{height:16px}.sl-h-5{height:20px}.sl-h-6{height:24px}.sl-h-7{height:28px}.sl-h-8{height:32px}.sl-h-9{height:36px}.sl-h-10{height:40px}.sl-h-11{height:44px}.sl-h-12{height:48px}.sl-h-14{height:56px}.sl-h-16{height:64px}.sl-h-20{height:80px}.sl-h-24{height:96px}.sl-h-32{height:128px}.sl-h-40{height:160px}.sl-h-60{height:240px}.sl-h-80{height:320px}.sl-h-auto{height:auto}.sl-h-px{height:1px}.sl-h-0\\.5{height:2px}.sl-h-1\\.5{height:6px}.sl-h-2\\.5{height:10px}.sl-h-3\\.5{height:14px}.sl-h-xs{height:20px}.sl-h-sm{height:24px}.sl-h-md{height:32px}.sl-h-lg{height:36px}.sl-h-xl{height:44px}.sl-h-2xl{height:52px}.sl-h-3xl{height:60px}.sl-h-full{height:100%}.sl-h-screen{height:100vh}.sl-inset-0{bottom:0;left:0;right:0;top:0}.sl-inset-1{bottom:4px;left:4px;right:4px;top:4px}.sl-inset-2{bottom:8px;left:8px;right:8px;top:8px}.sl-inset-3{bottom:12px;left:12px;right:12px;top:12px}.sl-inset-4{bottom:16px;left:16px;right:16px;top:16px}.sl-inset-5{bottom:20px;left:20px;right:20px;top:20px}.sl-inset-6{bottom:24px;left:24px;right:24px;top:24px}.sl-inset-7{bottom:28px;left:28px;right:28px;top:28px}.sl-inset-8{bottom:32px;left:32px;right:32px;top:32px}.sl-inset-9{bottom:36px;left:36px;right:36px;top:36px}.sl-inset-10{bottom:40px;left:40px;right:40px;top:40px}.sl-inset-11{bottom:44px;left:44px;right:44px;top:44px}.sl-inset-12{bottom:48px;left:48px;right:48px;top:48px}.sl-inset-14{bottom:56px;left:56px;right:56px;top:56px}.sl-inset-16{bottom:64px;left:64px;right:64px;top:64px}.sl-inset-20{bottom:80px;left:80px;right:80px;top:80px}.sl-inset-24{bottom:96px;left:96px;right:96px;top:96px}.sl-inset-32{bottom:128px;left:128px;right:128px;top:128px}.sl-inset-40{bottom:160px;left:160px;right:160px;top:160px}.sl-inset-60{bottom:240px;left:240px;right:240px;top:240px}.sl-inset-80{bottom:320px;left:320px;right:320px;top:320px}.sl-inset-auto{bottom:auto;left:auto;right:auto;top:auto}.sl-inset-px{bottom:1px;left:1px;right:1px;top:1px}.sl-inset-0\\.5{bottom:2px;left:2px;right:2px;top:2px}.sl-inset-1\\.5{bottom:6px;left:6px;right:6px;top:6px}.sl-inset-2\\.5{bottom:10px;left:10px;right:10px;top:10px}.sl-inset-3\\.5{bottom:14px;left:14px;right:14px;top:14px}.sl--inset-0{bottom:0;left:0;right:0;top:0}.sl--inset-1{bottom:-4px;left:-4px;right:-4px;top:-4px}.sl--inset-2{bottom:-8px;left:-8px;right:-8px;top:-8px}.sl--inset-3{bottom:-12px;left:-12px;right:-12px;top:-12px}.sl--inset-4{bottom:-16px;left:-16px;right:-16px;top:-16px}.sl--inset-5{bottom:-20px;left:-20px;right:-20px;top:-20px}.sl--inset-6{bottom:-24px;left:-24px;right:-24px;top:-24px}.sl--inset-7{bottom:-28px;left:-28px;right:-28px;top:-28px}.sl--inset-8{bottom:-32px;left:-32px;right:-32px;top:-32px}.sl--inset-9{bottom:-36px;left:-36px;right:-36px;top:-36px}.sl--inset-10{bottom:-40px;left:-40px;right:-40px;top:-40px}.sl--inset-11{bottom:-44px;left:-44px;right:-44px;top:-44px}.sl--inset-12{bottom:-48px;left:-48px;right:-48px;top:-48px}.sl--inset-14{bottom:-56px;left:-56px;right:-56px;top:-56px}.sl--inset-16{bottom:-64px;left:-64px;right:-64px;top:-64px}.sl--inset-20{bottom:-80px;left:-80px;right:-80px;top:-80px}.sl--inset-24{bottom:-96px;left:-96px;right:-96px;top:-96px}.sl--inset-32{bottom:-128px;left:-128px;right:-128px;top:-128px}.sl--inset-40{bottom:-160px;left:-160px;right:-160px;top:-160px}.sl--inset-60{bottom:-240px;left:-240px;right:-240px;top:-240px}.sl--inset-80{bottom:-320px;left:-320px;right:-320px;top:-320px}.sl--inset-px{bottom:-1px;left:-1px;right:-1px;top:-1px}.sl--inset-0\\.5{bottom:-2px;left:-2px;right:-2px;top:-2px}.sl--inset-1\\.5{bottom:-6px;left:-6px;right:-6px;top:-6px}.sl--inset-2\\.5{bottom:-10px;left:-10px;right:-10px;top:-10px}.sl--inset-3\\.5{bottom:-14px;left:-14px;right:-14px;top:-14px}.sl-inset-y-0{bottom:0;top:0}.sl-inset-x-0{left:0;right:0}.sl-inset-y-1{bottom:4px;top:4px}.sl-inset-x-1{left:4px;right:4px}.sl-inset-y-2{bottom:8px;top:8px}.sl-inset-x-2{left:8px;right:8px}.sl-inset-y-3{bottom:12px;top:12px}.sl-inset-x-3{left:12px;right:12px}.sl-inset-y-4{bottom:16px;top:16px}.sl-inset-x-4{left:16px;right:16px}.sl-inset-y-5{bottom:20px;top:20px}.sl-inset-x-5{left:20px;right:20px}.sl-inset-y-6{bottom:24px;top:24px}.sl-inset-x-6{left:24px;right:24px}.sl-inset-y-7{bottom:28px;top:28px}.sl-inset-x-7{left:28px;right:28px}.sl-inset-y-8{bottom:32px;top:32px}.sl-inset-x-8{left:32px;right:32px}.sl-inset-y-9{bottom:36px;top:36px}.sl-inset-x-9{left:36px;right:36px}.sl-inset-y-10{bottom:40px;top:40px}.sl-inset-x-10{left:40px;right:40px}.sl-inset-y-11{bottom:44px;top:44px}.sl-inset-x-11{left:44px;right:44px}.sl-inset-y-12{bottom:48px;top:48px}.sl-inset-x-12{left:48px;right:48px}.sl-inset-y-14{bottom:56px;top:56px}.sl-inset-x-14{left:56px;right:56px}.sl-inset-y-16{bottom:64px;top:64px}.sl-inset-x-16{left:64px;right:64px}.sl-inset-y-20{bottom:80px;top:80px}.sl-inset-x-20{left:80px;right:80px}.sl-inset-y-24{bottom:96px;top:96px}.sl-inset-x-24{left:96px;right:96px}.sl-inset-y-32{bottom:128px;top:128px}.sl-inset-x-32{left:128px;right:128px}.sl-inset-y-40{bottom:160px;top:160px}.sl-inset-x-40{left:160px;right:160px}.sl-inset-y-60{bottom:240px;top:240px}.sl-inset-x-60{left:240px;right:240px}.sl-inset-y-80{bottom:320px;top:320px}.sl-inset-x-80{left:320px;right:320px}.sl-inset-y-auto{bottom:auto;top:auto}.sl-inset-x-auto{left:auto;right:auto}.sl-inset-y-px{bottom:1px;top:1px}.sl-inset-x-px{left:1px;right:1px}.sl-inset-y-0\\.5{bottom:2px;top:2px}.sl-inset-x-0\\.5{left:2px;right:2px}.sl-inset-y-1\\.5{bottom:6px;top:6px}.sl-inset-x-1\\.5{left:6px;right:6px}.sl-inset-y-2\\.5{bottom:10px;top:10px}.sl-inset-x-2\\.5{left:10px;right:10px}.sl-inset-y-3\\.5{bottom:14px;top:14px}.sl-inset-x-3\\.5{left:14px;right:14px}.sl--inset-y-0{bottom:0;top:0}.sl--inset-x-0{left:0;right:0}.sl--inset-y-1{bottom:-4px;top:-4px}.sl--inset-x-1{left:-4px;right:-4px}.sl--inset-y-2{bottom:-8px;top:-8px}.sl--inset-x-2{left:-8px;right:-8px}.sl--inset-y-3{bottom:-12px;top:-12px}.sl--inset-x-3{left:-12px;right:-12px}.sl--inset-y-4{bottom:-16px;top:-16px}.sl--inset-x-4{left:-16px;right:-16px}.sl--inset-y-5{bottom:-20px;top:-20px}.sl--inset-x-5{left:-20px;right:-20px}.sl--inset-y-6{bottom:-24px;top:-24px}.sl--inset-x-6{left:-24px;right:-24px}.sl--inset-y-7{bottom:-28px;top:-28px}.sl--inset-x-7{left:-28px;right:-28px}.sl--inset-y-8{bottom:-32px;top:-32px}.sl--inset-x-8{left:-32px;right:-32px}.sl--inset-y-9{bottom:-36px;top:-36px}.sl--inset-x-9{left:-36px;right:-36px}.sl--inset-y-10{bottom:-40px;top:-40px}.sl--inset-x-10{left:-40px;right:-40px}.sl--inset-y-11{bottom:-44px;top:-44px}.sl--inset-x-11{left:-44px;right:-44px}.sl--inset-y-12{bottom:-48px;top:-48px}.sl--inset-x-12{left:-48px;right:-48px}.sl--inset-y-14{bottom:-56px;top:-56px}.sl--inset-x-14{left:-56px;right:-56px}.sl--inset-y-16{bottom:-64px;top:-64px}.sl--inset-x-16{left:-64px;right:-64px}.sl--inset-y-20{bottom:-80px;top:-80px}.sl--inset-x-20{left:-80px;right:-80px}.sl--inset-y-24{bottom:-96px;top:-96px}.sl--inset-x-24{left:-96px;right:-96px}.sl--inset-y-32{bottom:-128px;top:-128px}.sl--inset-x-32{left:-128px;right:-128px}.sl--inset-y-40{bottom:-160px;top:-160px}.sl--inset-x-40{left:-160px;right:-160px}.sl--inset-y-60{bottom:-240px;top:-240px}.sl--inset-x-60{left:-240px;right:-240px}.sl--inset-y-80{bottom:-320px;top:-320px}.sl--inset-x-80{left:-320px;right:-320px}.sl--inset-y-px{bottom:-1px;top:-1px}.sl--inset-x-px{left:-1px;right:-1px}.sl--inset-y-0\\.5{bottom:-2px;top:-2px}.sl--inset-x-0\\.5{left:-2px;right:-2px}.sl--inset-y-1\\.5{bottom:-6px;top:-6px}.sl--inset-x-1\\.5{left:-6px;right:-6px}.sl--inset-y-2\\.5{bottom:-10px;top:-10px}.sl--inset-x-2\\.5{left:-10px;right:-10px}.sl--inset-y-3\\.5{bottom:-14px;top:-14px}.sl--inset-x-3\\.5{left:-14px;right:-14px}.sl-top-0{top:0}.sl-right-0{right:0}.sl-bottom-0{bottom:0}.sl-left-0{left:0}.sl-top-1{top:4px}.sl-right-1{right:4px}.sl-bottom-1{bottom:4px}.sl-left-1{left:4px}.sl-top-2{top:8px}.sl-right-2{right:8px}.sl-bottom-2{bottom:8px}.sl-left-2{left:8px}.sl-top-3{top:12px}.sl-right-3{right:12px}.sl-bottom-3{bottom:12px}.sl-left-3{left:12px}.sl-top-4{top:16px}.sl-right-4{right:16px}.sl-bottom-4{bottom:16px}.sl-left-4{left:16px}.sl-top-5{top:20px}.sl-right-5{right:20px}.sl-bottom-5{bottom:20px}.sl-left-5{left:20px}.sl-top-6{top:24px}.sl-right-6{right:24px}.sl-bottom-6{bottom:24px}.sl-left-6{left:24px}.sl-top-7{top:28px}.sl-right-7{right:28px}.sl-bottom-7{bottom:28px}.sl-left-7{left:28px}.sl-top-8{top:32px}.sl-right-8{right:32px}.sl-bottom-8{bottom:32px}.sl-left-8{left:32px}.sl-top-9{top:36px}.sl-right-9{right:36px}.sl-bottom-9{bottom:36px}.sl-left-9{left:36px}.sl-top-10{top:40px}.sl-right-10{right:40px}.sl-bottom-10{bottom:40px}.sl-left-10{left:40px}.sl-top-11{top:44px}.sl-right-11{right:44px}.sl-bottom-11{bottom:44px}.sl-left-11{left:44px}.sl-top-12{top:48px}.sl-right-12{right:48px}.sl-bottom-12{bottom:48px}.sl-left-12{left:48px}.sl-top-14{top:56px}.sl-right-14{right:56px}.sl-bottom-14{bottom:56px}.sl-left-14{left:56px}.sl-top-16{top:64px}.sl-right-16{right:64px}.sl-bottom-16{bottom:64px}.sl-left-16{left:64px}.sl-top-20{top:80px}.sl-right-20{right:80px}.sl-bottom-20{bottom:80px}.sl-left-20{left:80px}.sl-top-24{top:96px}.sl-right-24{right:96px}.sl-bottom-24{bottom:96px}.sl-left-24{left:96px}.sl-top-32{top:128px}.sl-right-32{right:128px}.sl-bottom-32{bottom:128px}.sl-left-32{left:128px}.sl-top-40{top:160px}.sl-right-40{right:160px}.sl-bottom-40{bottom:160px}.sl-left-40{left:160px}.sl-top-60{top:240px}.sl-right-60{right:240px}.sl-bottom-60{bottom:240px}.sl-left-60{left:240px}.sl-top-80{top:320px}.sl-right-80{right:320px}.sl-bottom-80{bottom:320px}.sl-left-80{left:320px}.sl-top-auto{top:auto}.sl-right-auto{right:auto}.sl-bottom-auto{bottom:auto}.sl-left-auto{left:auto}.sl-top-px{top:1px}.sl-right-px{right:1px}.sl-bottom-px{bottom:1px}.sl-left-px{left:1px}.sl-top-0\\.5{top:2px}.sl-right-0\\.5{right:2px}.sl-bottom-0\\.5{bottom:2px}.sl-left-0\\.5{left:2px}.sl-top-1\\.5{top:6px}.sl-right-1\\.5{right:6px}.sl-bottom-1\\.5{bottom:6px}.sl-left-1\\.5{left:6px}.sl-top-2\\.5{top:10px}.sl-right-2\\.5{right:10px}.sl-bottom-2\\.5{bottom:10px}.sl-left-2\\.5{left:10px}.sl-top-3\\.5{top:14px}.sl-right-3\\.5{right:14px}.sl-bottom-3\\.5{bottom:14px}.sl-left-3\\.5{left:14px}.sl--top-0{top:0}.sl--right-0{right:0}.sl--bottom-0{bottom:0}.sl--left-0{left:0}.sl--top-1{top:-4px}.sl--right-1{right:-4px}.sl--bottom-1{bottom:-4px}.sl--left-1{left:-4px}.sl--top-2{top:-8px}.sl--right-2{right:-8px}.sl--bottom-2{bottom:-8px}.sl--left-2{left:-8px}.sl--top-3{top:-12px}.sl--right-3{right:-12px}.sl--bottom-3{bottom:-12px}.sl--left-3{left:-12px}.sl--top-4{top:-16px}.sl--right-4{right:-16px}.sl--bottom-4{bottom:-16px}.sl--left-4{left:-16px}.sl--top-5{top:-20px}.sl--right-5{right:-20px}.sl--bottom-5{bottom:-20px}.sl--left-5{left:-20px}.sl--top-6{top:-24px}.sl--right-6{right:-24px}.sl--bottom-6{bottom:-24px}.sl--left-6{left:-24px}.sl--top-7{top:-28px}.sl--right-7{right:-28px}.sl--bottom-7{bottom:-28px}.sl--left-7{left:-28px}.sl--top-8{top:-32px}.sl--right-8{right:-32px}.sl--bottom-8{bottom:-32px}.sl--left-8{left:-32px}.sl--top-9{top:-36px}.sl--right-9{right:-36px}.sl--bottom-9{bottom:-36px}.sl--left-9{left:-36px}.sl--top-10{top:-40px}.sl--right-10{right:-40px}.sl--bottom-10{bottom:-40px}.sl--left-10{left:-40px}.sl--top-11{top:-44px}.sl--right-11{right:-44px}.sl--bottom-11{bottom:-44px}.sl--left-11{left:-44px}.sl--top-12{top:-48px}.sl--right-12{right:-48px}.sl--bottom-12{bottom:-48px}.sl--left-12{left:-48px}.sl--top-14{top:-56px}.sl--right-14{right:-56px}.sl--bottom-14{bottom:-56px}.sl--left-14{left:-56px}.sl--top-16{top:-64px}.sl--right-16{right:-64px}.sl--bottom-16{bottom:-64px}.sl--left-16{left:-64px}.sl--top-20{top:-80px}.sl--right-20{right:-80px}.sl--bottom-20{bottom:-80px}.sl--left-20{left:-80px}.sl--top-24{top:-96px}.sl--right-24{right:-96px}.sl--bottom-24{bottom:-96px}.sl--left-24{left:-96px}.sl--top-32{top:-128px}.sl--right-32{right:-128px}.sl--bottom-32{bottom:-128px}.sl--left-32{left:-128px}.sl--top-40{top:-160px}.sl--right-40{right:-160px}.sl--bottom-40{bottom:-160px}.sl--left-40{left:-160px}.sl--top-60{top:-240px}.sl--right-60{right:-240px}.sl--bottom-60{bottom:-240px}.sl--left-60{left:-240px}.sl--top-80{top:-320px}.sl--right-80{right:-320px}.sl--bottom-80{bottom:-320px}.sl--left-80{left:-320px}.sl--top-px{top:-1px}.sl--right-px{right:-1px}.sl--bottom-px{bottom:-1px}.sl--left-px{left:-1px}.sl--top-0\\.5{top:-2px}.sl--right-0\\.5{right:-2px}.sl--bottom-0\\.5{bottom:-2px}.sl--left-0\\.5{left:-2px}.sl--top-1\\.5{top:-6px}.sl--right-1\\.5{right:-6px}.sl--bottom-1\\.5{bottom:-6px}.sl--left-1\\.5{left:-6px}.sl--top-2\\.5{top:-10px}.sl--right-2\\.5{right:-10px}.sl--bottom-2\\.5{bottom:-10px}.sl--left-2\\.5{left:-10px}.sl--top-3\\.5{top:-14px}.sl--right-3\\.5{right:-14px}.sl--bottom-3\\.5{bottom:-14px}.sl--left-3\\.5{left:-14px}.sl-justify-start{justify-content:flex-start}.sl-justify-end{justify-content:flex-end}.sl-justify-center{justify-content:center}.sl-justify-between{justify-content:space-between}.sl-justify-around{justify-content:space-around}.sl-justify-evenly{justify-content:space-evenly}.sl-justify-items-start{justify-items:start}.sl-justify-items-end{justify-items:end}.sl-justify-items-center{justify-items:center}.sl-justify-items-stretch{justify-items:stretch}.sl-justify-self-auto{justify-self:auto}.sl-justify-self-start{justify-self:start}.sl-justify-self-end{justify-self:end}.sl-justify-self-center{justify-self:center}.sl-justify-self-stretch{justify-self:stretch}.sl-tracking-tight{letter-spacing:-.025em}.sl-tracking-normal{letter-spacing:0}.sl-tracking-wide{letter-spacing:.025em}.sl-leading-none{line-height:1}.sl-leading-tight{line-height:1.2}.sl-leading-snug{line-height:1.375}.sl-leading-normal{line-height:1.5}.sl-leading-relaxed{line-height:1.625}.sl-leading-loose{line-height:2}.sl-leading-paragraph-leading{line-height:var(--lh-paragraph-leading)}.sl-leading-paragraph{line-height:var(--lh-paragraph)}.sl-leading-paragraph-small{line-height:var(--lh-paragraph-small)}.sl-leading-paragraph-tiny{line-height:var(--lh-paragraph-tiny)}.sl-m-0{margin:0}.sl-m-1{margin:4px}.sl-m-2{margin:8px}.sl-m-3{margin:12px}.sl-m-4{margin:16px}.sl-m-5{margin:20px}.sl-m-6{margin:24px}.sl-m-7{margin:28px}.sl-m-8{margin:32px}.sl-m-9{margin:36px}.sl-m-10{margin:40px}.sl-m-11{margin:44px}.sl-m-12{margin:48px}.sl-m-14{margin:56px}.sl-m-16{margin:64px}.sl-m-20{margin:80px}.sl-m-24{margin:96px}.sl-m-32{margin:128px}.sl-m-40{margin:160px}.sl-m-60{margin:240px}.sl-m-80{margin:320px}.sl-m-auto{margin:auto}.sl-m-px{margin:1px}.sl-m-0\\.5{margin:2px}.sl-m-1\\.5{margin:6px}.sl-m-2\\.5{margin:10px}.sl-m-3\\.5{margin:14px}.sl--m-0{margin:0}.sl--m-1{margin:-4px}.sl--m-2{margin:-8px}.sl--m-3{margin:-12px}.sl--m-4{margin:-16px}.sl--m-5{margin:-20px}.sl--m-6{margin:-24px}.sl--m-7{margin:-28px}.sl--m-8{margin:-32px}.sl--m-9{margin:-36px}.sl--m-10{margin:-40px}.sl--m-11{margin:-44px}.sl--m-12{margin:-48px}.sl--m-14{margin:-56px}.sl--m-16{margin:-64px}.sl--m-20{margin:-80px}.sl--m-24{margin:-96px}.sl--m-32{margin:-128px}.sl--m-40{margin:-160px}.sl--m-60{margin:-240px}.sl--m-80{margin:-320px}.sl--m-px{margin:-1px}.sl--m-0\\.5{margin:-2px}.sl--m-1\\.5{margin:-6px}.sl--m-2\\.5{margin:-10px}.sl--m-3\\.5{margin:-14px}.sl-my-0{margin-bottom:0;margin-top:0}.sl-mx-0{margin-left:0;margin-right:0}.sl-my-1{margin-bottom:4px;margin-top:4px}.sl-mx-1{margin-left:4px;margin-right:4px}.sl-my-2{margin-bottom:8px;margin-top:8px}.sl-mx-2{margin-left:8px;margin-right:8px}.sl-my-3{margin-bottom:12px;margin-top:12px}.sl-mx-3{margin-left:12px;margin-right:12px}.sl-my-4{margin-bottom:16px;margin-top:16px}.sl-mx-4{margin-left:16px;margin-right:16px}.sl-my-5{margin-bottom:20px;margin-top:20px}.sl-mx-5{margin-left:20px;margin-right:20px}.sl-my-6{margin-bottom:24px;margin-top:24px}.sl-mx-6{margin-left:24px;margin-right:24px}.sl-my-7{margin-bottom:28px;margin-top:28px}.sl-mx-7{margin-left:28px;margin-right:28px}.sl-my-8{margin-bottom:32px;margin-top:32px}.sl-mx-8{margin-left:32px;margin-right:32px}.sl-my-9{margin-bottom:36px;margin-top:36px}.sl-mx-9{margin-left:36px;margin-right:36px}.sl-my-10{margin-bottom:40px;margin-top:40px}.sl-mx-10{margin-left:40px;margin-right:40px}.sl-my-11{margin-bottom:44px;margin-top:44px}.sl-mx-11{margin-left:44px;margin-right:44px}.sl-my-12{margin-bottom:48px;margin-top:48px}.sl-mx-12{margin-left:48px;margin-right:48px}.sl-my-14{margin-bottom:56px;margin-top:56px}.sl-mx-14{margin-left:56px;margin-right:56px}.sl-my-16{margin-bottom:64px;margin-top:64px}.sl-mx-16{margin-left:64px;margin-right:64px}.sl-my-20{margin-bottom:80px;margin-top:80px}.sl-mx-20{margin-left:80px;margin-right:80px}.sl-my-24{margin-bottom:96px;margin-top:96px}.sl-mx-24{margin-left:96px;margin-right:96px}.sl-my-32{margin-bottom:128px;margin-top:128px}.sl-mx-32{margin-left:128px;margin-right:128px}.sl-my-40{margin-bottom:160px;margin-top:160px}.sl-mx-40{margin-left:160px;margin-right:160px}.sl-my-60{margin-bottom:240px;margin-top:240px}.sl-mx-60{margin-left:240px;margin-right:240px}.sl-my-80{margin-bottom:320px;margin-top:320px}.sl-mx-80{margin-left:320px;margin-right:320px}.sl-my-auto{margin-bottom:auto;margin-top:auto}.sl-mx-auto{margin-left:auto;margin-right:auto}.sl-my-px{margin-bottom:1px;margin-top:1px}.sl-mx-px{margin-left:1px;margin-right:1px}.sl-my-0\\.5{margin-bottom:2px;margin-top:2px}.sl-mx-0\\.5{margin-left:2px;margin-right:2px}.sl-my-1\\.5{margin-bottom:6px;margin-top:6px}.sl-mx-1\\.5{margin-left:6px;margin-right:6px}.sl-my-2\\.5{margin-bottom:10px;margin-top:10px}.sl-mx-2\\.5{margin-left:10px;margin-right:10px}.sl-my-3\\.5{margin-bottom:14px;margin-top:14px}.sl-mx-3\\.5{margin-left:14px;margin-right:14px}.sl--my-0{margin-bottom:0;margin-top:0}.sl--mx-0{margin-left:0;margin-right:0}.sl--my-1{margin-bottom:-4px;margin-top:-4px}.sl--mx-1{margin-left:-4px;margin-right:-4px}.sl--my-2{margin-bottom:-8px;margin-top:-8px}.sl--mx-2{margin-left:-8px;margin-right:-8px}.sl--my-3{margin-bottom:-12px;margin-top:-12px}.sl--mx-3{margin-left:-12px;margin-right:-12px}.sl--my-4{margin-bottom:-16px;margin-top:-16px}.sl--mx-4{margin-left:-16px;margin-right:-16px}.sl--my-5{margin-bottom:-20px;margin-top:-20px}.sl--mx-5{margin-left:-20px;margin-right:-20px}.sl--my-6{margin-bottom:-24px;margin-top:-24px}.sl--mx-6{margin-left:-24px;margin-right:-24px}.sl--my-7{margin-bottom:-28px;margin-top:-28px}.sl--mx-7{margin-left:-28px;margin-right:-28px}.sl--my-8{margin-bottom:-32px;margin-top:-32px}.sl--mx-8{margin-left:-32px;margin-right:-32px}.sl--my-9{margin-bottom:-36px;margin-top:-36px}.sl--mx-9{margin-left:-36px;margin-right:-36px}.sl--my-10{margin-bottom:-40px;margin-top:-40px}.sl--mx-10{margin-left:-40px;margin-right:-40px}.sl--my-11{margin-bottom:-44px;margin-top:-44px}.sl--mx-11{margin-left:-44px;margin-right:-44px}.sl--my-12{margin-bottom:-48px;margin-top:-48px}.sl--mx-12{margin-left:-48px;margin-right:-48px}.sl--my-14{margin-bottom:-56px;margin-top:-56px}.sl--mx-14{margin-left:-56px;margin-right:-56px}.sl--my-16{margin-bottom:-64px;margin-top:-64px}.sl--mx-16{margin-left:-64px;margin-right:-64px}.sl--my-20{margin-bottom:-80px;margin-top:-80px}.sl--mx-20{margin-left:-80px;margin-right:-80px}.sl--my-24{margin-bottom:-96px;margin-top:-96px}.sl--mx-24{margin-left:-96px;margin-right:-96px}.sl--my-32{margin-bottom:-128px;margin-top:-128px}.sl--mx-32{margin-left:-128px;margin-right:-128px}.sl--my-40{margin-bottom:-160px;margin-top:-160px}.sl--mx-40{margin-left:-160px;margin-right:-160px}.sl--my-60{margin-bottom:-240px;margin-top:-240px}.sl--mx-60{margin-left:-240px;margin-right:-240px}.sl--my-80{margin-bottom:-320px;margin-top:-320px}.sl--mx-80{margin-left:-320px;margin-right:-320px}.sl--my-px{margin-bottom:-1px;margin-top:-1px}.sl--mx-px{margin-left:-1px;margin-right:-1px}.sl--my-0\\.5{margin-bottom:-2px;margin-top:-2px}.sl--mx-0\\.5{margin-left:-2px;margin-right:-2px}.sl--my-1\\.5{margin-bottom:-6px;margin-top:-6px}.sl--mx-1\\.5{margin-left:-6px;margin-right:-6px}.sl--my-2\\.5{margin-bottom:-10px;margin-top:-10px}.sl--mx-2\\.5{margin-left:-10px;margin-right:-10px}.sl--my-3\\.5{margin-bottom:-14px;margin-top:-14px}.sl--mx-3\\.5{margin-left:-14px;margin-right:-14px}.sl-mt-0{margin-top:0}.sl-mr-0{margin-right:0}.sl-mb-0{margin-bottom:0}.sl-ml-0{margin-left:0}.sl-mt-1{margin-top:4px}.sl-mr-1{margin-right:4px}.sl-mb-1{margin-bottom:4px}.sl-ml-1{margin-left:4px}.sl-mt-2{margin-top:8px}.sl-mr-2{margin-right:8px}.sl-mb-2{margin-bottom:8px}.sl-ml-2{margin-left:8px}.sl-mt-3{margin-top:12px}.sl-mr-3{margin-right:12px}.sl-mb-3{margin-bottom:12px}.sl-ml-3{margin-left:12px}.sl-mt-4{margin-top:16px}.sl-mr-4{margin-right:16px}.sl-mb-4{margin-bottom:16px}.sl-ml-4{margin-left:16px}.sl-mt-5{margin-top:20px}.sl-mr-5{margin-right:20px}.sl-mb-5{margin-bottom:20px}.sl-ml-5{margin-left:20px}.sl-mt-6{margin-top:24px}.sl-mr-6{margin-right:24px}.sl-mb-6{margin-bottom:24px}.sl-ml-6{margin-left:24px}.sl-mt-7{margin-top:28px}.sl-mr-7{margin-right:28px}.sl-mb-7{margin-bottom:28px}.sl-ml-7{margin-left:28px}.sl-mt-8{margin-top:32px}.sl-mr-8{margin-right:32px}.sl-mb-8{margin-bottom:32px}.sl-ml-8{margin-left:32px}.sl-mt-9{margin-top:36px}.sl-mr-9{margin-right:36px}.sl-mb-9{margin-bottom:36px}.sl-ml-9{margin-left:36px}.sl-mt-10{margin-top:40px}.sl-mr-10{margin-right:40px}.sl-mb-10{margin-bottom:40px}.sl-ml-10{margin-left:40px}.sl-mt-11{margin-top:44px}.sl-mr-11{margin-right:44px}.sl-mb-11{margin-bottom:44px}.sl-ml-11{margin-left:44px}.sl-mt-12{margin-top:48px}.sl-mr-12{margin-right:48px}.sl-mb-12{margin-bottom:48px}.sl-ml-12{margin-left:48px}.sl-mt-14{margin-top:56px}.sl-mr-14{margin-right:56px}.sl-mb-14{margin-bottom:56px}.sl-ml-14{margin-left:56px}.sl-mt-16{margin-top:64px}.sl-mr-16{margin-right:64px}.sl-mb-16{margin-bottom:64px}.sl-ml-16{margin-left:64px}.sl-mt-20{margin-top:80px}.sl-mr-20{margin-right:80px}.sl-mb-20{margin-bottom:80px}.sl-ml-20{margin-left:80px}.sl-mt-24{margin-top:96px}.sl-mr-24{margin-right:96px}.sl-mb-24{margin-bottom:96px}.sl-ml-24{margin-left:96px}.sl-mt-32{margin-top:128px}.sl-mr-32{margin-right:128px}.sl-mb-32{margin-bottom:128px}.sl-ml-32{margin-left:128px}.sl-mt-40{margin-top:160px}.sl-mr-40{margin-right:160px}.sl-mb-40{margin-bottom:160px}.sl-ml-40{margin-left:160px}.sl-mt-60{margin-top:240px}.sl-mr-60{margin-right:240px}.sl-mb-60{margin-bottom:240px}.sl-ml-60{margin-left:240px}.sl-mt-80{margin-top:320px}.sl-mr-80{margin-right:320px}.sl-mb-80{margin-bottom:320px}.sl-ml-80{margin-left:320px}.sl-mt-auto{margin-top:auto}.sl-mr-auto{margin-right:auto}.sl-mb-auto{margin-bottom:auto}.sl-ml-auto{margin-left:auto}.sl-mt-px{margin-top:1px}.sl-mr-px{margin-right:1px}.sl-mb-px{margin-bottom:1px}.sl-ml-px{margin-left:1px}.sl-mt-0\\.5{margin-top:2px}.sl-mr-0\\.5{margin-right:2px}.sl-mb-0\\.5{margin-bottom:2px}.sl-ml-0\\.5{margin-left:2px}.sl-mt-1\\.5{margin-top:6px}.sl-mr-1\\.5{margin-right:6px}.sl-mb-1\\.5{margin-bottom:6px}.sl-ml-1\\.5{margin-left:6px}.sl-mt-2\\.5{margin-top:10px}.sl-mr-2\\.5{margin-right:10px}.sl-mb-2\\.5{margin-bottom:10px}.sl-ml-2\\.5{margin-left:10px}.sl-mt-3\\.5{margin-top:14px}.sl-mr-3\\.5{margin-right:14px}.sl-mb-3\\.5{margin-bottom:14px}.sl-ml-3\\.5{margin-left:14px}.sl--mt-0{margin-top:0}.sl--mr-0{margin-right:0}.sl--mb-0{margin-bottom:0}.sl--ml-0{margin-left:0}.sl--mt-1{margin-top:-4px}.sl--mr-1{margin-right:-4px}.sl--mb-1{margin-bottom:-4px}.sl--ml-1{margin-left:-4px}.sl--mt-2{margin-top:-8px}.sl--mr-2{margin-right:-8px}.sl--mb-2{margin-bottom:-8px}.sl--ml-2{margin-left:-8px}.sl--mt-3{margin-top:-12px}.sl--mr-3{margin-right:-12px}.sl--mb-3{margin-bottom:-12px}.sl--ml-3{margin-left:-12px}.sl--mt-4{margin-top:-16px}.sl--mr-4{margin-right:-16px}.sl--mb-4{margin-bottom:-16px}.sl--ml-4{margin-left:-16px}.sl--mt-5{margin-top:-20px}.sl--mr-5{margin-right:-20px}.sl--mb-5{margin-bottom:-20px}.sl--ml-5{margin-left:-20px}.sl--mt-6{margin-top:-24px}.sl--mr-6{margin-right:-24px}.sl--mb-6{margin-bottom:-24px}.sl--ml-6{margin-left:-24px}.sl--mt-7{margin-top:-28px}.sl--mr-7{margin-right:-28px}.sl--mb-7{margin-bottom:-28px}.sl--ml-7{margin-left:-28px}.sl--mt-8{margin-top:-32px}.sl--mr-8{margin-right:-32px}.sl--mb-8{margin-bottom:-32px}.sl--ml-8{margin-left:-32px}.sl--mt-9{margin-top:-36px}.sl--mr-9{margin-right:-36px}.sl--mb-9{margin-bottom:-36px}.sl--ml-9{margin-left:-36px}.sl--mt-10{margin-top:-40px}.sl--mr-10{margin-right:-40px}.sl--mb-10{margin-bottom:-40px}.sl--ml-10{margin-left:-40px}.sl--mt-11{margin-top:-44px}.sl--mr-11{margin-right:-44px}.sl--mb-11{margin-bottom:-44px}.sl--ml-11{margin-left:-44px}.sl--mt-12{margin-top:-48px}.sl--mr-12{margin-right:-48px}.sl--mb-12{margin-bottom:-48px}.sl--ml-12{margin-left:-48px}.sl--mt-14{margin-top:-56px}.sl--mr-14{margin-right:-56px}.sl--mb-14{margin-bottom:-56px}.sl--ml-14{margin-left:-56px}.sl--mt-16{margin-top:-64px}.sl--mr-16{margin-right:-64px}.sl--mb-16{margin-bottom:-64px}.sl--ml-16{margin-left:-64px}.sl--mt-20{margin-top:-80px}.sl--mr-20{margin-right:-80px}.sl--mb-20{margin-bottom:-80px}.sl--ml-20{margin-left:-80px}.sl--mt-24{margin-top:-96px}.sl--mr-24{margin-right:-96px}.sl--mb-24{margin-bottom:-96px}.sl--ml-24{margin-left:-96px}.sl--mt-32{margin-top:-128px}.sl--mr-32{margin-right:-128px}.sl--mb-32{margin-bottom:-128px}.sl--ml-32{margin-left:-128px}.sl--mt-40{margin-top:-160px}.sl--mr-40{margin-right:-160px}.sl--mb-40{margin-bottom:-160px}.sl--ml-40{margin-left:-160px}.sl--mt-60{margin-top:-240px}.sl--mr-60{margin-right:-240px}.sl--mb-60{margin-bottom:-240px}.sl--ml-60{margin-left:-240px}.sl--mt-80{margin-top:-320px}.sl--mr-80{margin-right:-320px}.sl--mb-80{margin-bottom:-320px}.sl--ml-80{margin-left:-320px}.sl--mt-px{margin-top:-1px}.sl--mr-px{margin-right:-1px}.sl--mb-px{margin-bottom:-1px}.sl--ml-px{margin-left:-1px}.sl--mt-0\\.5{margin-top:-2px}.sl--mr-0\\.5{margin-right:-2px}.sl--mb-0\\.5{margin-bottom:-2px}.sl--ml-0\\.5{margin-left:-2px}.sl--mt-1\\.5{margin-top:-6px}.sl--mr-1\\.5{margin-right:-6px}.sl--mb-1\\.5{margin-bottom:-6px}.sl--ml-1\\.5{margin-left:-6px}.sl--mt-2\\.5{margin-top:-10px}.sl--mr-2\\.5{margin-right:-10px}.sl--mb-2\\.5{margin-bottom:-10px}.sl--ml-2\\.5{margin-left:-10px}.sl--mt-3\\.5{margin-top:-14px}.sl--mr-3\\.5{margin-right:-14px}.sl--mb-3\\.5{margin-bottom:-14px}.sl--ml-3\\.5{margin-left:-14px}.sl-max-h-full{max-height:100%}.sl-max-h-screen{max-height:100vh}.sl-max-w-none{max-width:none}.sl-max-w-full{max-width:100%}.sl-max-w-min{max-width:-moz-min-content;max-width:min-content}.sl-max-w-max{max-width:-moz-max-content;max-width:max-content}.sl-max-w-prose{max-width:65ch}.sl-min-h-full{min-height:100%}.sl-min-h-screen{min-height:100vh}.sl-min-w-full{min-width:100%}.sl-min-w-min{min-width:-moz-min-content;min-width:min-content}.sl-min-w-max{min-width:-moz-max-content;min-width:max-content}.sl-object-contain{object-fit:contain}.sl-object-cover{object-fit:cover}.sl-object-fill{object-fit:fill}.sl-object-none{object-fit:none}.sl-object-scale-down{object-fit:scale-down}.sl-object-bottom{object-position:bottom}.sl-object-center{object-position:center}.sl-object-left{object-position:left}.sl-object-left-bottom{object-position:left bottom}.sl-object-left-top{object-position:left top}.sl-object-right{object-position:right}.sl-object-right-bottom{object-position:right bottom}.sl-object-right-top{object-position:right top}.sl-object-top{object-position:top}.sl-opacity-0{opacity:0}.sl-opacity-5{opacity:.05}.sl-opacity-10{opacity:.1}.sl-opacity-20{opacity:.2}.sl-opacity-30{opacity:.3}.sl-opacity-40{opacity:.4}.sl-opacity-50{opacity:.5}.sl-opacity-60{opacity:.6}.sl-opacity-70{opacity:.7}.sl-opacity-90{opacity:.9}.sl-opacity-100{opacity:1}.hover\\:sl-opacity-0:hover{opacity:0}.hover\\:sl-opacity-5:hover{opacity:.05}.hover\\:sl-opacity-10:hover{opacity:.1}.hover\\:sl-opacity-20:hover{opacity:.2}.hover\\:sl-opacity-30:hover{opacity:.3}.hover\\:sl-opacity-40:hover{opacity:.4}.hover\\:sl-opacity-50:hover{opacity:.5}.hover\\:sl-opacity-60:hover{opacity:.6}.hover\\:sl-opacity-70:hover{opacity:.7}.hover\\:sl-opacity-90:hover{opacity:.9}.hover\\:sl-opacity-100:hover{opacity:1}.focus\\:sl-opacity-0:focus{opacity:0}.focus\\:sl-opacity-5:focus{opacity:.05}.focus\\:sl-opacity-10:focus{opacity:.1}.focus\\:sl-opacity-20:focus{opacity:.2}.focus\\:sl-opacity-30:focus{opacity:.3}.focus\\:sl-opacity-40:focus{opacity:.4}.focus\\:sl-opacity-50:focus{opacity:.5}.focus\\:sl-opacity-60:focus{opacity:.6}.focus\\:sl-opacity-70:focus{opacity:.7}.focus\\:sl-opacity-90:focus{opacity:.9}.focus\\:sl-opacity-100:focus{opacity:1}.active\\:sl-opacity-0:active{opacity:0}.active\\:sl-opacity-5:active{opacity:.05}.active\\:sl-opacity-10:active{opacity:.1}.active\\:sl-opacity-20:active{opacity:.2}.active\\:sl-opacity-30:active{opacity:.3}.active\\:sl-opacity-40:active{opacity:.4}.active\\:sl-opacity-50:active{opacity:.5}.active\\:sl-opacity-60:active{opacity:.6}.active\\:sl-opacity-70:active{opacity:.7}.active\\:sl-opacity-90:active{opacity:.9}.active\\:sl-opacity-100:active{opacity:1}.disabled\\:sl-opacity-0:disabled{opacity:0}.disabled\\:sl-opacity-5:disabled{opacity:.05}.disabled\\:sl-opacity-10:disabled{opacity:.1}.disabled\\:sl-opacity-20:disabled{opacity:.2}.disabled\\:sl-opacity-30:disabled{opacity:.3}.disabled\\:sl-opacity-40:disabled{opacity:.4}.disabled\\:sl-opacity-50:disabled{opacity:.5}.disabled\\:sl-opacity-60:disabled{opacity:.6}.disabled\\:sl-opacity-70:disabled{opacity:.7}.disabled\\:sl-opacity-90:disabled{opacity:.9}.disabled\\:sl-opacity-100:disabled{opacity:1}.sl-outline-none{outline:2px solid transparent;outline-offset:2px}.sl-overflow-auto{overflow:auto}.sl-overflow-hidden{overflow:hidden}.sl-overflow-visible{overflow:visible}.sl-overflow-scroll{overflow:scroll}.sl-overflow-x-auto{overflow-x:auto}.sl-overflow-y-auto{overflow-y:auto}.sl-overflow-x-hidden{overflow-x:hidden}.sl-overflow-y-hidden{overflow-y:hidden}.sl-overflow-x-visible{overflow-x:visible}.sl-overflow-y-visible{overflow-y:visible}.sl-overflow-x-scroll{overflow-x:scroll}.sl-overflow-y-scroll{overflow-y:scroll}.sl-overscroll-auto{overscroll-behavior:auto}.sl-overscroll-contain{overscroll-behavior:contain}.sl-overscroll-none{overscroll-behavior:none}.sl-overscroll-y-auto{overscroll-behavior-y:auto}.sl-overscroll-y-contain{overscroll-behavior-y:contain}.sl-overscroll-y-none{overscroll-behavior-y:none}.sl-overscroll-x-auto{overscroll-behavior-x:auto}.sl-overscroll-x-contain{overscroll-behavior-x:contain}.sl-overscroll-x-none{overscroll-behavior-x:none}.sl-p-0{padding:0}.sl-p-1{padding:4px}.sl-p-2{padding:8px}.sl-p-3{padding:12px}.sl-p-4{padding:16px}.sl-p-5{padding:20px}.sl-p-6{padding:24px}.sl-p-7{padding:28px}.sl-p-8{padding:32px}.sl-p-9{padding:36px}.sl-p-10{padding:40px}.sl-p-11{padding:44px}.sl-p-12{padding:48px}.sl-p-14{padding:56px}.sl-p-16{padding:64px}.sl-p-20{padding:80px}.sl-p-24{padding:96px}.sl-p-32{padding:128px}.sl-p-40{padding:160px}.sl-p-60{padding:240px}.sl-p-80{padding:320px}.sl-p-px{padding:1px}.sl-p-0\\.5{padding:2px}.sl-p-1\\.5{padding:6px}.sl-p-2\\.5{padding:10px}.sl-p-3\\.5{padding:14px}.sl-py-0{padding-bottom:0;padding-top:0}.sl-px-0{padding-left:0;padding-right:0}.sl-py-1{padding-bottom:4px;padding-top:4px}.sl-px-1{padding-left:4px;padding-right:4px}.sl-py-2{padding-bottom:8px;padding-top:8px}.sl-px-2{padding-left:8px;padding-right:8px}.sl-py-3{padding-bottom:12px;padding-top:12px}.sl-px-3{padding-left:12px;padding-right:12px}.sl-py-4{padding-bottom:16px;padding-top:16px}.sl-px-4{padding-left:16px;padding-right:16px}.sl-py-5{padding-bottom:20px;padding-top:20px}.sl-px-5{padding-left:20px;padding-right:20px}.sl-py-6{padding-bottom:24px;padding-top:24px}.sl-px-6{padding-left:24px;padding-right:24px}.sl-py-7{padding-bottom:28px;padding-top:28px}.sl-px-7{padding-left:28px;padding-right:28px}.sl-py-8{padding-bottom:32px;padding-top:32px}.sl-px-8{padding-left:32px;padding-right:32px}.sl-py-9{padding-bottom:36px;padding-top:36px}.sl-px-9{padding-left:36px;padding-right:36px}.sl-py-10{padding-bottom:40px;padding-top:40px}.sl-px-10{padding-left:40px;padding-right:40px}.sl-py-11{padding-bottom:44px;padding-top:44px}.sl-px-11{padding-left:44px;padding-right:44px}.sl-py-12{padding-bottom:48px;padding-top:48px}.sl-px-12{padding-left:48px;padding-right:48px}.sl-py-14{padding-bottom:56px;padding-top:56px}.sl-px-14{padding-left:56px;padding-right:56px}.sl-py-16{padding-bottom:64px;padding-top:64px}.sl-px-16{padding-left:64px;padding-right:64px}.sl-py-20{padding-bottom:80px;padding-top:80px}.sl-px-20{padding-left:80px;padding-right:80px}.sl-py-24{padding-bottom:96px;padding-top:96px}.sl-px-24{padding-left:96px;padding-right:96px}.sl-py-32{padding-bottom:128px;padding-top:128px}.sl-px-32{padding-left:128px;padding-right:128px}.sl-py-40{padding-bottom:160px;padding-top:160px}.sl-px-40{padding-left:160px;padding-right:160px}.sl-py-60{padding-bottom:240px;padding-top:240px}.sl-px-60{padding-left:240px;padding-right:240px}.sl-py-80{padding-bottom:320px;padding-top:320px}.sl-px-80{padding-left:320px;padding-right:320px}.sl-py-px{padding-bottom:1px;padding-top:1px}.sl-px-px{padding-left:1px;padding-right:1px}.sl-py-0\\.5{padding-bottom:2px;padding-top:2px}.sl-px-0\\.5{padding-left:2px;padding-right:2px}.sl-py-1\\.5{padding-bottom:6px;padding-top:6px}.sl-px-1\\.5{padding-left:6px;padding-right:6px}.sl-py-2\\.5{padding-bottom:10px;padding-top:10px}.sl-px-2\\.5{padding-left:10px;padding-right:10px}.sl-py-3\\.5{padding-bottom:14px;padding-top:14px}.sl-px-3\\.5{padding-left:14px;padding-right:14px}.sl-pt-0{padding-top:0}.sl-pr-0{padding-right:0}.sl-pb-0{padding-bottom:0}.sl-pl-0{padding-left:0}.sl-pt-1{padding-top:4px}.sl-pr-1{padding-right:4px}.sl-pb-1{padding-bottom:4px}.sl-pl-1{padding-left:4px}.sl-pt-2{padding-top:8px}.sl-pr-2{padding-right:8px}.sl-pb-2{padding-bottom:8px}.sl-pl-2{padding-left:8px}.sl-pt-3{padding-top:12px}.sl-pr-3{padding-right:12px}.sl-pb-3{padding-bottom:12px}.sl-pl-3{padding-left:12px}.sl-pt-4{padding-top:16px}.sl-pr-4{padding-right:16px}.sl-pb-4{padding-bottom:16px}.sl-pl-4{padding-left:16px}.sl-pt-5{padding-top:20px}.sl-pr-5{padding-right:20px}.sl-pb-5{padding-bottom:20px}.sl-pl-5{padding-left:20px}.sl-pt-6{padding-top:24px}.sl-pr-6{padding-right:24px}.sl-pb-6{padding-bottom:24px}.sl-pl-6{padding-left:24px}.sl-pt-7{padding-top:28px}.sl-pr-7{padding-right:28px}.sl-pb-7{padding-bottom:28px}.sl-pl-7{padding-left:28px}.sl-pt-8{padding-top:32px}.sl-pr-8{padding-right:32px}.sl-pb-8{padding-bottom:32px}.sl-pl-8{padding-left:32px}.sl-pt-9{padding-top:36px}.sl-pr-9{padding-right:36px}.sl-pb-9{padding-bottom:36px}.sl-pl-9{padding-left:36px}.sl-pt-10{padding-top:40px}.sl-pr-10{padding-right:40px}.sl-pb-10{padding-bottom:40px}.sl-pl-10{padding-left:40px}.sl-pt-11{padding-top:44px}.sl-pr-11{padding-right:44px}.sl-pb-11{padding-bottom:44px}.sl-pl-11{padding-left:44px}.sl-pt-12{padding-top:48px}.sl-pr-12{padding-right:48px}.sl-pb-12{padding-bottom:48px}.sl-pl-12{padding-left:48px}.sl-pt-14{padding-top:56px}.sl-pr-14{padding-right:56px}.sl-pb-14{padding-bottom:56px}.sl-pl-14{padding-left:56px}.sl-pt-16{padding-top:64px}.sl-pr-16{padding-right:64px}.sl-pb-16{padding-bottom:64px}.sl-pl-16{padding-left:64px}.sl-pt-20{padding-top:80px}.sl-pr-20{padding-right:80px}.sl-pb-20{padding-bottom:80px}.sl-pl-20{padding-left:80px}.sl-pt-24{padding-top:96px}.sl-pr-24{padding-right:96px}.sl-pb-24{padding-bottom:96px}.sl-pl-24{padding-left:96px}.sl-pt-32{padding-top:128px}.sl-pr-32{padding-right:128px}.sl-pb-32{padding-bottom:128px}.sl-pl-32{padding-left:128px}.sl-pt-40{padding-top:160px}.sl-pr-40{padding-right:160px}.sl-pb-40{padding-bottom:160px}.sl-pl-40{padding-left:160px}.sl-pt-60{padding-top:240px}.sl-pr-60{padding-right:240px}.sl-pb-60{padding-bottom:240px}.sl-pl-60{padding-left:240px}.sl-pt-80{padding-top:320px}.sl-pr-80{padding-right:320px}.sl-pb-80{padding-bottom:320px}.sl-pl-80{padding-left:320px}.sl-pt-px{padding-top:1px}.sl-pr-px{padding-right:1px}.sl-pb-px{padding-bottom:1px}.sl-pl-px{padding-left:1px}.sl-pt-0\\.5{padding-top:2px}.sl-pr-0\\.5{padding-right:2px}.sl-pb-0\\.5{padding-bottom:2px}.sl-pl-0\\.5{padding-left:2px}.sl-pt-1\\.5{padding-top:6px}.sl-pr-1\\.5{padding-right:6px}.sl-pb-1\\.5{padding-bottom:6px}.sl-pl-1\\.5{padding-left:6px}.sl-pt-2\\.5{padding-top:10px}.sl-pr-2\\.5{padding-right:10px}.sl-pb-2\\.5{padding-bottom:10px}.sl-pl-2\\.5{padding-left:10px}.sl-pt-3\\.5{padding-top:14px}.sl-pr-3\\.5{padding-right:14px}.sl-pb-3\\.5{padding-bottom:14px}.sl-pl-3\\.5{padding-left:14px}.sl-placeholder::-ms-input-placeholder{color:var(--color-text-light)}.sl-placeholder::placeholder{color:var(--color-text-light)}.sl-placeholder-primary::-ms-input-placeholder{color:#3898ff ;}.sl-placeholder-primary::placeholder{color:#3898ff ;}.sl-placeholder-success::-ms-input-placeholder{color:#0ea06f ;}.sl-placeholder-success::placeholder{color:#0ea06f ;}.sl-placeholder-warning::-ms-input-placeholder{color:#f3602b ;}.sl-placeholder-warning::placeholder{color:#f3602b ;}.sl-placeholder-danger::-ms-input-placeholder{color:#f05151 ;}.sl-placeholder-danger::placeholder{color:#f05151 ;}.sl-pointer-events-none{pointer-events:none}.sl-pointer-events-auto{pointer-events:auto}.sl-static{position:static}.sl-fixed{position:fixed}.sl-absolute{position:absolute}.sl-relative{position:relative}.sl-sticky{position:-webkit-sticky;position:sticky}.sl-resize-none{resize:none}.sl-resize-y{resize:vertical}.sl-resize-x{resize:horizontal}.sl-resize{resize:both}.sl-ring-primary{--tw-ring-color:hsla(var(--primary-h),80%,61%,var(--tw-ring-opacity)) ;}.sl-ring-success{--tw-ring-color:hsla(var(--success-h),84%,34%,var(--tw-ring-opacity)) ;}.sl-ring-warning{--tw-ring-color:hsla(var(--warning-h),89%,56%,var(--tw-ring-opacity)) ;}.sl-ring-danger{--tw-ring-color:hsla(var(--danger-h),84%,63%,var(--tw-ring-opacity)) ;}.focus\\:sl-ring-primary:focus{--tw-ring-color:hsla(var(--primary-h),80%,61%,var(--tw-ring-opacity)) ;}.focus\\:sl-ring-success:focus{--tw-ring-color:hsla(var(--success-h),84%,34%,var(--tw-ring-opacity)) ;}.focus\\:sl-ring-warning:focus{--tw-ring-color:hsla(var(--warning-h),89%,56%,var(--tw-ring-opacity)) ;}.focus\\:sl-ring-danger:focus{--tw-ring-color:hsla(var(--danger-h),84%,63%,var(--tw-ring-opacity)) ;}.sl-ring-opacity-0{--tw-ring-opacity:0}.sl-ring-opacity-5{--tw-ring-opacity:0.05}.sl-ring-opacity-10{--tw-ring-opacity:0.1}.sl-ring-opacity-20{--tw-ring-opacity:0.2}.sl-ring-opacity-30{--tw-ring-opacity:0.3}.sl-ring-opacity-40{--tw-ring-opacity:0.4}.sl-ring-opacity-50{--tw-ring-opacity:0.5}.sl-ring-opacity-60{--tw-ring-opacity:0.6}.sl-ring-opacity-70{--tw-ring-opacity:0.7}.sl-ring-opacity-90{--tw-ring-opacity:0.9}.sl-ring-opacity-100{--tw-ring-opacity:1}.focus\\:sl-ring-opacity-0:focus{--tw-ring-opacity:0}.focus\\:sl-ring-opacity-5:focus{--tw-ring-opacity:0.05}.focus\\:sl-ring-opacity-10:focus{--tw-ring-opacity:0.1}.focus\\:sl-ring-opacity-20:focus{--tw-ring-opacity:0.2}.focus\\:sl-ring-opacity-30:focus{--tw-ring-opacity:0.3}.focus\\:sl-ring-opacity-40:focus{--tw-ring-opacity:0.4}.focus\\:sl-ring-opacity-50:focus{--tw-ring-opacity:0.5}.focus\\:sl-ring-opacity-60:focus{--tw-ring-opacity:0.6}.focus\\:sl-ring-opacity-70:focus{--tw-ring-opacity:0.7}.focus\\:sl-ring-opacity-90:focus{--tw-ring-opacity:0.9}.focus\\:sl-ring-opacity-100:focus{--tw-ring-opacity:1}*{--tw-ring-inset:var(--tw-empty,/*!*/ /*!*/);--tw-ring-offset-width:0px;--tw-ring-offset-color:#fff;--tw-ring-color:rgba(147,197,253,0.5);--tw-ring-offset-shadow:0 0 #0000;--tw-ring-shadow:0 0 #0000}.sl-ring{--tw-ring-offset-shadow:var(--tw-ring-inset) 0 0 0 var(--tw-ring-offset-width) var(--tw-ring-offset-color);--tw-ring-shadow:var(--tw-ring-inset) 0 0 0 calc(3px + var(--tw-ring-offset-width)) var(--tw-ring-color);box-shadow:var(--tw-ring-offset-shadow),var(--tw-ring-shadow),var(--tw-shadow,0 0 #0000)}.sl-ring-inset{--tw-ring-inset:inset}.focus\\:sl-ring:focus{--tw-ring-offset-shadow:var(--tw-ring-inset) 0 0 0 var(--tw-ring-offset-width) var(--tw-ring-offset-color);--tw-ring-shadow:var(--tw-ring-inset) 0 0 0 calc(3px + var(--tw-ring-offset-width)) var(--tw-ring-color);box-shadow:var(--tw-ring-offset-shadow),var(--tw-ring-shadow),var(--tw-shadow,0 0 #0000)}.focus\\:sl-ring-inset:focus{--tw-ring-inset:inset}.sl-stroke-transparent{stroke:transparent}.sl-stroke-current{stroke:currentColor}.sl-stroke-lighten-100{stroke:var(--color-lighten-100)}.sl-stroke-darken-100{stroke:var(--color-darken-100)}.sl-stroke-primary{stroke:var(--color-primary)}.sl-stroke-primary-tint{stroke:var(--color-primary-tint)}.sl-stroke-primary-light{stroke:var(--color-primary-light)}.sl-stroke-primary-dark{stroke:var(--color-primary-dark)}.sl-stroke-primary-darker{stroke:var(--color-primary-darker)}.sl-stroke-success{stroke:var(--color-success)}.sl-stroke-success-tint{stroke:var(--color-success-tint)}.sl-stroke-success-light{stroke:var(--color-success-light)}.sl-stroke-success-dark{stroke:var(--color-success-dark)}.sl-stroke-success-darker{stroke:var(--color-success-darker)}.sl-stroke-warning{stroke:var(--color-warning)}.sl-stroke-warning-tint{stroke:var(--color-warning-tint)}.sl-stroke-warning-light{stroke:var(--color-warning-light)}.sl-stroke-warning-dark{stroke:var(--color-warning-dark)}.sl-stroke-warning-darker{stroke:var(--color-warning-darker)}.sl-stroke-danger{stroke:var(--color-danger)}.sl-stroke-danger-tint{stroke:var(--color-danger-tint)}.sl-stroke-danger-light{stroke:var(--color-danger-light)}.sl-stroke-danger-dark{stroke:var(--color-danger-dark)}.sl-stroke-danger-darker{stroke:var(--color-danger-darker)}.sl-stroke-code{stroke:var(--color-code)}.sl-stroke-on-code{stroke:var(--color-on-code)}.sl-stroke-on-primary{stroke:var(--color-on-primary)}.sl-stroke-on-success{stroke:var(--color-on-success)}.sl-stroke-on-warning{stroke:var(--color-on-warning)}.sl-stroke-on-danger{stroke:var(--color-on-danger)}.sl-stroke-text{stroke:var(--color-text)}.sl-table-auto{table-layout:auto}.sl-table-fixed{table-layout:fixed}.sl-text-left{text-align:left}.sl-text-center{text-align:center}.sl-text-right{text-align:right}.sl-text-justify{text-align:justify}.sl-text-transparent{color:transparent}.sl-text-current{color:currentColor}.sl-text-lighten-100{color:var(--color-lighten-100)}.sl-text-darken-100{color:var(--color-darken-100)}.sl-text-primary{color:var(--color-primary)}.sl-text-primary-tint{color:var(--color-primary-tint)}.sl-text-primary-light{color:var(--color-primary-light)}.sl-text-primary-dark{color:var(--color-primary-dark)}.sl-text-primary-darker{color:var(--color-primary-darker)}.sl-text-success{color:var(--color-success)}.sl-text-success-tint{color:var(--color-success-tint)}.sl-text-success-light{color:var(--color-success-light)}.sl-text-success-dark{color:var(--color-success-dark)}.sl-text-success-darker{color:var(--color-success-darker)}.sl-text-warning{color:var(--color-warning)}.sl-text-warning-tint{color:var(--color-warning-tint)}.sl-text-warning-light{color:var(--color-warning-light)}.sl-text-warning-dark{color:var(--color-warning-dark)}.sl-text-warning-darker{color:var(--color-warning-darker)}.sl-text-danger{color:var(--color-danger)}.sl-text-danger-tint{color:var(--color-danger-tint)}.sl-text-danger-light{color:var(--color-danger-light)}.sl-text-danger-dark{color:var(--color-danger-dark)}.sl-text-danger-darker{color:var(--color-danger-darker)}.sl-text-code{color:var(--color-code)}.sl-text-on-code{color:var(--color-on-code)}.sl-text-on-primary{color:var(--color-on-primary)}.sl-text-on-success{color:var(--color-on-success)}.sl-text-on-warning{color:var(--color-on-warning)}.sl-text-on-danger{color:var(--color-on-danger)}.sl-text-body{color:var(--color-text)}.sl-text-muted{color:var(--color-text-muted)}.sl-text-light{color:var(--color-text-light)}.sl-text-heading{color:var(--color-text-heading)}.sl-text-paragraph{color:var(--color-text-paragraph)}.sl-text-canvas-50{color:var(--color-canvas-50)}.sl-text-canvas-100{color:var(--color-canvas-100)}.sl-text-canvas-200{color:var(--color-canvas-200)}.sl-text-canvas-300{color:var(--color-canvas-300)}.sl-text-canvas-pure{color:var(--color-canvas-pure)}.sl-text-canvas{color:var(--color-canvas)}.sl-text-canvas-dialog{color:var(--color-canvas-dialog)}.sl-text-link{color:var(--color-link)}.sl-text-link-dark{color:var(--color-link-dark)}.hover\\:sl-text-transparent:hover{color:transparent}.hover\\:sl-text-current:hover{color:currentColor}.hover\\:sl-text-lighten-100:hover{color:var(--color-lighten-100)}.hover\\:sl-text-darken-100:hover{color:var(--color-darken-100)}.hover\\:sl-text-primary:hover{color:var(--color-primary)}.hover\\:sl-text-primary-tint:hover{color:var(--color-primary-tint)}.hover\\:sl-text-primary-light:hover{color:var(--color-primary-light)}.hover\\:sl-text-primary-dark:hover{color:var(--color-primary-dark)}.hover\\:sl-text-primary-darker:hover{color:var(--color-primary-darker)}.hover\\:sl-text-success:hover{color:var(--color-success)}.hover\\:sl-text-success-tint:hover{color:var(--color-success-tint)}.hover\\:sl-text-success-light:hover{color:var(--color-success-light)}.hover\\:sl-text-success-dark:hover{color:var(--color-success-dark)}.hover\\:sl-text-success-darker:hover{color:var(--color-success-darker)}.hover\\:sl-text-warning:hover{color:var(--color-warning)}.hover\\:sl-text-warning-tint:hover{color:var(--color-warning-tint)}.hover\\:sl-text-warning-light:hover{color:var(--color-warning-light)}.hover\\:sl-text-warning-dark:hover{color:var(--color-warning-dark)}.hover\\:sl-text-warning-darker:hover{color:var(--color-warning-darker)}.hover\\:sl-text-danger:hover{color:var(--color-danger)}.hover\\:sl-text-danger-tint:hover{color:var(--color-danger-tint)}.hover\\:sl-text-danger-light:hover{color:var(--color-danger-light)}.hover\\:sl-text-danger-dark:hover{color:var(--color-danger-dark)}.hover\\:sl-text-danger-darker:hover{color:var(--color-danger-darker)}.hover\\:sl-text-code:hover{color:var(--color-code)}.hover\\:sl-text-on-code:hover{color:var(--color-on-code)}.hover\\:sl-text-on-primary:hover{color:var(--color-on-primary)}.hover\\:sl-text-on-success:hover{color:var(--color-on-success)}.hover\\:sl-text-on-warning:hover{color:var(--color-on-warning)}.hover\\:sl-text-on-danger:hover{color:var(--color-on-danger)}.hover\\:sl-text-body:hover{color:var(--color-text)}.hover\\:sl-text-muted:hover{color:var(--color-text-muted)}.hover\\:sl-text-light:hover{color:var(--color-text-light)}.hover\\:sl-text-heading:hover{color:var(--color-text-heading)}.hover\\:sl-text-paragraph:hover{color:var(--color-text-paragraph)}.hover\\:sl-text-canvas-50:hover{color:var(--color-canvas-50)}.hover\\:sl-text-canvas-100:hover{color:var(--color-canvas-100)}.hover\\:sl-text-canvas-200:hover{color:var(--color-canvas-200)}.hover\\:sl-text-canvas-300:hover{color:var(--color-canvas-300)}.hover\\:sl-text-canvas-pure:hover{color:var(--color-canvas-pure)}.hover\\:sl-text-canvas:hover{color:var(--color-canvas)}.hover\\:sl-text-canvas-dialog:hover{color:var(--color-canvas-dialog)}.hover\\:sl-text-link:hover{color:var(--color-link)}.hover\\:sl-text-link-dark:hover{color:var(--color-link-dark)}.focus\\:sl-text-transparent:focus{color:transparent}.focus\\:sl-text-current:focus{color:currentColor}.focus\\:sl-text-lighten-100:focus{color:var(--color-lighten-100)}.focus\\:sl-text-darken-100:focus{color:var(--color-darken-100)}.focus\\:sl-text-primary:focus{color:var(--color-primary)}.focus\\:sl-text-primary-tint:focus{color:var(--color-primary-tint)}.focus\\:sl-text-primary-light:focus{color:var(--color-primary-light)}.focus\\:sl-text-primary-dark:focus{color:var(--color-primary-dark)}.focus\\:sl-text-primary-darker:focus{color:var(--color-primary-darker)}.focus\\:sl-text-success:focus{color:var(--color-success)}.focus\\:sl-text-success-tint:focus{color:var(--color-success-tint)}.focus\\:sl-text-success-light:focus{color:var(--color-success-light)}.focus\\:sl-text-success-dark:focus{color:var(--color-success-dark)}.focus\\:sl-text-success-darker:focus{color:var(--color-success-darker)}.focus\\:sl-text-warning:focus{color:var(--color-warning)}.focus\\:sl-text-warning-tint:focus{color:var(--color-warning-tint)}.focus\\:sl-text-warning-light:focus{color:var(--color-warning-light)}.focus\\:sl-text-warning-dark:focus{color:var(--color-warning-dark)}.focus\\:sl-text-warning-darker:focus{color:var(--color-warning-darker)}.focus\\:sl-text-danger:focus{color:var(--color-danger)}.focus\\:sl-text-danger-tint:focus{color:var(--color-danger-tint)}.focus\\:sl-text-danger-light:focus{color:var(--color-danger-light)}.focus\\:sl-text-danger-dark:focus{color:var(--color-danger-dark)}.focus\\:sl-text-danger-darker:focus{color:var(--color-danger-darker)}.focus\\:sl-text-code:focus{color:var(--color-code)}.focus\\:sl-text-on-code:focus{color:var(--color-on-code)}.focus\\:sl-text-on-primary:focus{color:var(--color-on-primary)}.focus\\:sl-text-on-success:focus{color:var(--color-on-success)}.focus\\:sl-text-on-warning:focus{color:var(--color-on-warning)}.focus\\:sl-text-on-danger:focus{color:var(--color-on-danger)}.focus\\:sl-text-body:focus{color:var(--color-text)}.focus\\:sl-text-muted:focus{color:var(--color-text-muted)}.focus\\:sl-text-light:focus{color:var(--color-text-light)}.focus\\:sl-text-heading:focus{color:var(--color-text-heading)}.focus\\:sl-text-paragraph:focus{color:var(--color-text-paragraph)}.focus\\:sl-text-canvas-50:focus{color:var(--color-canvas-50)}.focus\\:sl-text-canvas-100:focus{color:var(--color-canvas-100)}.focus\\:sl-text-canvas-200:focus{color:var(--color-canvas-200)}.focus\\:sl-text-canvas-300:focus{color:var(--color-canvas-300)}.focus\\:sl-text-canvas-pure:focus{color:var(--color-canvas-pure)}.focus\\:sl-text-canvas:focus{color:var(--color-canvas)}.focus\\:sl-text-canvas-dialog:focus{color:var(--color-canvas-dialog)}.focus\\:sl-text-link:focus{color:var(--color-link)}.focus\\:sl-text-link-dark:focus{color:var(--color-link-dark)}.disabled\\:sl-text-transparent:disabled{color:transparent}.disabled\\:sl-text-current:disabled{color:currentColor}.disabled\\:sl-text-lighten-100:disabled{color:var(--color-lighten-100)}.disabled\\:sl-text-darken-100:disabled{color:var(--color-darken-100)}.disabled\\:sl-text-primary:disabled{color:var(--color-primary)}.disabled\\:sl-text-primary-tint:disabled{color:var(--color-primary-tint)}.disabled\\:sl-text-primary-light:disabled{color:var(--color-primary-light)}.disabled\\:sl-text-primary-dark:disabled{color:var(--color-primary-dark)}.disabled\\:sl-text-primary-darker:disabled{color:var(--color-primary-darker)}.disabled\\:sl-text-success:disabled{color:var(--color-success)}.disabled\\:sl-text-success-tint:disabled{color:var(--color-success-tint)}.disabled\\:sl-text-success-light:disabled{color:var(--color-success-light)}.disabled\\:sl-text-success-dark:disabled{color:var(--color-success-dark)}.disabled\\:sl-text-success-darker:disabled{color:var(--color-success-darker)}.disabled\\:sl-text-warning:disabled{color:var(--color-warning)}.disabled\\:sl-text-warning-tint:disabled{color:var(--color-warning-tint)}.disabled\\:sl-text-warning-light:disabled{color:var(--color-warning-light)}.disabled\\:sl-text-warning-dark:disabled{color:var(--color-warning-dark)}.disabled\\:sl-text-warning-darker:disabled{color:var(--color-warning-darker)}.disabled\\:sl-text-danger:disabled{color:var(--color-danger)}.disabled\\:sl-text-danger-tint:disabled{color:var(--color-danger-tint)}.disabled\\:sl-text-danger-light:disabled{color:var(--color-danger-light)}.disabled\\:sl-text-danger-dark:disabled{color:var(--color-danger-dark)}.disabled\\:sl-text-danger-darker:disabled{color:var(--color-danger-darker)}.disabled\\:sl-text-code:disabled{color:var(--color-code)}.disabled\\:sl-text-on-code:disabled{color:var(--color-on-code)}.disabled\\:sl-text-on-primary:disabled{color:var(--color-on-primary)}.disabled\\:sl-text-on-success:disabled{color:var(--color-on-success)}.disabled\\:sl-text-on-warning:disabled{color:var(--color-on-warning)}.disabled\\:sl-text-on-danger:disabled{color:var(--color-on-danger)}.disabled\\:sl-text-body:disabled{color:var(--color-text)}.disabled\\:sl-text-muted:disabled{color:var(--color-text-muted)}.disabled\\:sl-text-light:disabled{color:var(--color-text-light)}.disabled\\:sl-text-heading:disabled{color:var(--color-text-heading)}.disabled\\:sl-text-paragraph:disabled{color:var(--color-text-paragraph)}.disabled\\:sl-text-canvas-50:disabled{color:var(--color-canvas-50)}.disabled\\:sl-text-canvas-100:disabled{color:var(--color-canvas-100)}.disabled\\:sl-text-canvas-200:disabled{color:var(--color-canvas-200)}.disabled\\:sl-text-canvas-300:disabled{color:var(--color-canvas-300)}.disabled\\:sl-text-canvas-pure:disabled{color:var(--color-canvas-pure)}.disabled\\:sl-text-canvas:disabled{color:var(--color-canvas)}.disabled\\:sl-text-canvas-dialog:disabled{color:var(--color-canvas-dialog)}.disabled\\:sl-text-link:disabled{color:var(--color-link)}.disabled\\:sl-text-link-dark:disabled{color:var(--color-link-dark)}.sl-underline{text-decoration:underline}.sl-line-through{text-decoration:line-through}.sl-no-underline{text-decoration:none}.sl-truncate{overflow:hidden;white-space:nowrap}.sl-overflow-ellipsis,.sl-truncate{text-overflow:ellipsis}.sl-overflow-clip{text-overflow:clip}.sl-uppercase{text-transform:uppercase}.sl-lowercase{text-transform:lowercase}.sl-capitalize{text-transform:capitalize}.sl-normal-case{text-transform:none}.sl-transform{transform:translateX(var(--tw-translate-x)) translateY(var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y))}.sl-transform,.sl-transform-gpu{--tw-translate-x:0;--tw-translate-y:0;--tw-rotate:0;--tw-skew-x:0;--tw-skew-y:0;--tw-scale-x:1;--tw-scale-y:1}.sl-transform-gpu{transform:translate3d(var(--tw-translate-x),var(--tw-translate-y),0) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y))}.sl-transform-none{transform:none}.sl-delay-75{transition-delay:75ms}.sl-delay-150{transition-delay:.15s}.sl-delay-300{transition-delay:.3s}.sl-delay-500{transition-delay:.5s}.sl-delay-1000{transition-delay:1s}.sl-duration-75{transition-duration:75ms}.sl-duration-150{transition-duration:.15s}.sl-duration-300{transition-duration:.3s}.sl-duration-500{transition-duration:.5s}.sl-duration-1000{transition-duration:1s}.sl-transition{transition-duration:.15s;transition-property:background-color,border-color,color,fill,stroke,opacity,box-shadow,transform;transition-timing-function:cubic-bezier(.4,0,.2,1)}.sl-translate-x-0{--tw-translate-x:0px}.sl-translate-x-1{--tw-translate-x:4px}.sl-translate-x-2{--tw-translate-x:8px}.sl-translate-x-3{--tw-translate-x:12px}.sl-translate-x-4{--tw-translate-x:16px}.sl-translate-x-5{--tw-translate-x:20px}.sl-translate-x-6{--tw-translate-x:24px}.sl-translate-x-7{--tw-translate-x:28px}.sl-translate-x-8{--tw-translate-x:32px}.sl-translate-x-9{--tw-translate-x:36px}.sl-translate-x-10{--tw-translate-x:40px}.sl-translate-x-11{--tw-translate-x:44px}.sl-translate-x-12{--tw-translate-x:48px}.sl-translate-x-14{--tw-translate-x:56px}.sl-translate-x-16{--tw-translate-x:64px}.sl-translate-x-20{--tw-translate-x:80px}.sl-translate-x-24{--tw-translate-x:96px}.sl-translate-x-32{--tw-translate-x:128px}.sl-translate-x-40{--tw-translate-x:160px}.sl-translate-x-60{--tw-translate-x:240px}.sl-translate-x-80{--tw-translate-x:320px}.sl-translate-x-px{--tw-translate-x:1px}.sl-translate-x-0\\.5{--tw-translate-x:2px}.sl-translate-x-1\\.5{--tw-translate-x:6px}.sl-translate-x-2\\.5{--tw-translate-x:10px}.sl-translate-x-3\\.5{--tw-translate-x:14px}.sl--translate-x-0{--tw-translate-x:0px}.sl--translate-x-1{--tw-translate-x:-4px}.sl--translate-x-2{--tw-translate-x:-8px}.sl--translate-x-3{--tw-translate-x:-12px}.sl--translate-x-4{--tw-translate-x:-16px}.sl--translate-x-5{--tw-translate-x:-20px}.sl--translate-x-6{--tw-translate-x:-24px}.sl--translate-x-7{--tw-translate-x:-28px}.sl--translate-x-8{--tw-translate-x:-32px}.sl--translate-x-9{--tw-translate-x:-36px}.sl--translate-x-10{--tw-translate-x:-40px}.sl--translate-x-11{--tw-translate-x:-44px}.sl--translate-x-12{--tw-translate-x:-48px}.sl--translate-x-14{--tw-translate-x:-56px}.sl--translate-x-16{--tw-translate-x:-64px}.sl--translate-x-20{--tw-translate-x:-80px}.sl--translate-x-24{--tw-translate-x:-96px}.sl--translate-x-32{--tw-translate-x:-128px}.sl--translate-x-40{--tw-translate-x:-160px}.sl--translate-x-60{--tw-translate-x:-240px}.sl--translate-x-80{--tw-translate-x:-320px}.sl--translate-x-px{--tw-translate-x:-1px}.sl--translate-x-0\\.5{--tw-translate-x:-2px}.sl--translate-x-1\\.5{--tw-translate-x:-6px}.sl--translate-x-2\\.5{--tw-translate-x:-10px}.sl--translate-x-3\\.5{--tw-translate-x:-14px}.sl-translate-y-0{--tw-translate-y:0px}.sl-translate-y-1{--tw-translate-y:4px}.sl-translate-y-2{--tw-translate-y:8px}.sl-translate-y-3{--tw-translate-y:12px}.sl-translate-y-4{--tw-translate-y:16px}.sl-translate-y-5{--tw-translate-y:20px}.sl-translate-y-6{--tw-translate-y:24px}.sl-translate-y-7{--tw-translate-y:28px}.sl-translate-y-8{--tw-translate-y:32px}.sl-translate-y-9{--tw-translate-y:36px}.sl-translate-y-10{--tw-translate-y:40px}.sl-translate-y-11{--tw-translate-y:44px}.sl-translate-y-12{--tw-translate-y:48px}.sl-translate-y-14{--tw-translate-y:56px}.sl-translate-y-16{--tw-translate-y:64px}.sl-translate-y-20{--tw-translate-y:80px}.sl-translate-y-24{--tw-translate-y:96px}.sl-translate-y-32{--tw-translate-y:128px}.sl-translate-y-40{--tw-translate-y:160px}.sl-translate-y-60{--tw-translate-y:240px}.sl-translate-y-80{--tw-translate-y:320px}.sl-translate-y-px{--tw-translate-y:1px}.sl-translate-y-0\\.5{--tw-translate-y:2px}.sl-translate-y-1\\.5{--tw-translate-y:6px}.sl-translate-y-2\\.5{--tw-translate-y:10px}.sl-translate-y-3\\.5{--tw-translate-y:14px}.sl--translate-y-0{--tw-translate-y:0px}.sl--translate-y-1{--tw-translate-y:-4px}.sl--translate-y-2{--tw-translate-y:-8px}.sl--translate-y-3{--tw-translate-y:-12px}.sl--translate-y-4{--tw-translate-y:-16px}.sl--translate-y-5{--tw-translate-y:-20px}.sl--translate-y-6{--tw-translate-y:-24px}.sl--translate-y-7{--tw-translate-y:-28px}.sl--translate-y-8{--tw-translate-y:-32px}.sl--translate-y-9{--tw-translate-y:-36px}.sl--translate-y-10{--tw-translate-y:-40px}.sl--translate-y-11{--tw-translate-y:-44px}.sl--translate-y-12{--tw-translate-y:-48px}.sl--translate-y-14{--tw-translate-y:-56px}.sl--translate-y-16{--tw-translate-y:-64px}.sl--translate-y-20{--tw-translate-y:-80px}.sl--translate-y-24{--tw-translate-y:-96px}.sl--translate-y-32{--tw-translate-y:-128px}.sl--translate-y-40{--tw-translate-y:-160px}.sl--translate-y-60{--tw-translate-y:-240px}.sl--translate-y-80{--tw-translate-y:-320px}.sl--translate-y-px{--tw-translate-y:-1px}.sl--translate-y-0\\.5{--tw-translate-y:-2px}.sl--translate-y-1\\.5{--tw-translate-y:-6px}.sl--translate-y-2\\.5{--tw-translate-y:-10px}.sl--translate-y-3\\.5{--tw-translate-y:-14px}.hover\\:sl-translate-x-0:hover{--tw-translate-x:0px}.hover\\:sl-translate-x-1:hover{--tw-translate-x:4px}.hover\\:sl-translate-x-2:hover{--tw-translate-x:8px}.hover\\:sl-translate-x-3:hover{--tw-translate-x:12px}.hover\\:sl-translate-x-4:hover{--tw-translate-x:16px}.hover\\:sl-translate-x-5:hover{--tw-translate-x:20px}.hover\\:sl-translate-x-6:hover{--tw-translate-x:24px}.hover\\:sl-translate-x-7:hover{--tw-translate-x:28px}.hover\\:sl-translate-x-8:hover{--tw-translate-x:32px}.hover\\:sl-translate-x-9:hover{--tw-translate-x:36px}.hover\\:sl-translate-x-10:hover{--tw-translate-x:40px}.hover\\:sl-translate-x-11:hover{--tw-translate-x:44px}.hover\\:sl-translate-x-12:hover{--tw-translate-x:48px}.hover\\:sl-translate-x-14:hover{--tw-translate-x:56px}.hover\\:sl-translate-x-16:hover{--tw-translate-x:64px}.hover\\:sl-translate-x-20:hover{--tw-translate-x:80px}.hover\\:sl-translate-x-24:hover{--tw-translate-x:96px}.hover\\:sl-translate-x-32:hover{--tw-translate-x:128px}.hover\\:sl-translate-x-40:hover{--tw-translate-x:160px}.hover\\:sl-translate-x-60:hover{--tw-translate-x:240px}.hover\\:sl-translate-x-80:hover{--tw-translate-x:320px}.hover\\:sl-translate-x-px:hover{--tw-translate-x:1px}.hover\\:sl-translate-x-0\\.5:hover{--tw-translate-x:2px}.hover\\:sl-translate-x-1\\.5:hover{--tw-translate-x:6px}.hover\\:sl-translate-x-2\\.5:hover{--tw-translate-x:10px}.hover\\:sl-translate-x-3\\.5:hover{--tw-translate-x:14px}.hover\\:sl--translate-x-0:hover{--tw-translate-x:0px}.hover\\:sl--translate-x-1:hover{--tw-translate-x:-4px}.hover\\:sl--translate-x-2:hover{--tw-translate-x:-8px}.hover\\:sl--translate-x-3:hover{--tw-translate-x:-12px}.hover\\:sl--translate-x-4:hover{--tw-translate-x:-16px}.hover\\:sl--translate-x-5:hover{--tw-translate-x:-20px}.hover\\:sl--translate-x-6:hover{--tw-translate-x:-24px}.hover\\:sl--translate-x-7:hover{--tw-translate-x:-28px}.hover\\:sl--translate-x-8:hover{--tw-translate-x:-32px}.hover\\:sl--translate-x-9:hover{--tw-translate-x:-36px}.hover\\:sl--translate-x-10:hover{--tw-translate-x:-40px}.hover\\:sl--translate-x-11:hover{--tw-translate-x:-44px}.hover\\:sl--translate-x-12:hover{--tw-translate-x:-48px}.hover\\:sl--translate-x-14:hover{--tw-translate-x:-56px}.hover\\:sl--translate-x-16:hover{--tw-translate-x:-64px}.hover\\:sl--translate-x-20:hover{--tw-translate-x:-80px}.hover\\:sl--translate-x-24:hover{--tw-translate-x:-96px}.hover\\:sl--translate-x-32:hover{--tw-translate-x:-128px}.hover\\:sl--translate-x-40:hover{--tw-translate-x:-160px}.hover\\:sl--translate-x-60:hover{--tw-translate-x:-240px}.hover\\:sl--translate-x-80:hover{--tw-translate-x:-320px}.hover\\:sl--translate-x-px:hover{--tw-translate-x:-1px}.hover\\:sl--translate-x-0\\.5:hover{--tw-translate-x:-2px}.hover\\:sl--translate-x-1\\.5:hover{--tw-translate-x:-6px}.hover\\:sl--translate-x-2\\.5:hover{--tw-translate-x:-10px}.hover\\:sl--translate-x-3\\.5:hover{--tw-translate-x:-14px}.hover\\:sl-translate-y-0:hover{--tw-translate-y:0px}.hover\\:sl-translate-y-1:hover{--tw-translate-y:4px}.hover\\:sl-translate-y-2:hover{--tw-translate-y:8px}.hover\\:sl-translate-y-3:hover{--tw-translate-y:12px}.hover\\:sl-translate-y-4:hover{--tw-translate-y:16px}.hover\\:sl-translate-y-5:hover{--tw-translate-y:20px}.hover\\:sl-translate-y-6:hover{--tw-translate-y:24px}.hover\\:sl-translate-y-7:hover{--tw-translate-y:28px}.hover\\:sl-translate-y-8:hover{--tw-translate-y:32px}.hover\\:sl-translate-y-9:hover{--tw-translate-y:36px}.hover\\:sl-translate-y-10:hover{--tw-translate-y:40px}.hover\\:sl-translate-y-11:hover{--tw-translate-y:44px}.hover\\:sl-translate-y-12:hover{--tw-translate-y:48px}.hover\\:sl-translate-y-14:hover{--tw-translate-y:56px}.hover\\:sl-translate-y-16:hover{--tw-translate-y:64px}.hover\\:sl-translate-y-20:hover{--tw-translate-y:80px}.hover\\:sl-translate-y-24:hover{--tw-translate-y:96px}.hover\\:sl-translate-y-32:hover{--tw-translate-y:128px}.hover\\:sl-translate-y-40:hover{--tw-translate-y:160px}.hover\\:sl-translate-y-60:hover{--tw-translate-y:240px}.hover\\:sl-translate-y-80:hover{--tw-translate-y:320px}.hover\\:sl-translate-y-px:hover{--tw-translate-y:1px}.hover\\:sl-translate-y-0\\.5:hover{--tw-translate-y:2px}.hover\\:sl-translate-y-1\\.5:hover{--tw-translate-y:6px}.hover\\:sl-translate-y-2\\.5:hover{--tw-translate-y:10px}.hover\\:sl-translate-y-3\\.5:hover{--tw-translate-y:14px}.hover\\:sl--translate-y-0:hover{--tw-translate-y:0px}.hover\\:sl--translate-y-1:hover{--tw-translate-y:-4px}.hover\\:sl--translate-y-2:hover{--tw-translate-y:-8px}.hover\\:sl--translate-y-3:hover{--tw-translate-y:-12px}.hover\\:sl--translate-y-4:hover{--tw-translate-y:-16px}.hover\\:sl--translate-y-5:hover{--tw-translate-y:-20px}.hover\\:sl--translate-y-6:hover{--tw-translate-y:-24px}.hover\\:sl--translate-y-7:hover{--tw-translate-y:-28px}.hover\\:sl--translate-y-8:hover{--tw-translate-y:-32px}.hover\\:sl--translate-y-9:hover{--tw-translate-y:-36px}.hover\\:sl--translate-y-10:hover{--tw-translate-y:-40px}.hover\\:sl--translate-y-11:hover{--tw-translate-y:-44px}.hover\\:sl--translate-y-12:hover{--tw-translate-y:-48px}.hover\\:sl--translate-y-14:hover{--tw-translate-y:-56px}.hover\\:sl--translate-y-16:hover{--tw-translate-y:-64px}.hover\\:sl--translate-y-20:hover{--tw-translate-y:-80px}.hover\\:sl--translate-y-24:hover{--tw-translate-y:-96px}.hover\\:sl--translate-y-32:hover{--tw-translate-y:-128px}.hover\\:sl--translate-y-40:hover{--tw-translate-y:-160px}.hover\\:sl--translate-y-60:hover{--tw-translate-y:-240px}.hover\\:sl--translate-y-80:hover{--tw-translate-y:-320px}.hover\\:sl--translate-y-px:hover{--tw-translate-y:-1px}.hover\\:sl--translate-y-0\\.5:hover{--tw-translate-y:-2px}.hover\\:sl--translate-y-1\\.5:hover{--tw-translate-y:-6px}.hover\\:sl--translate-y-2\\.5:hover{--tw-translate-y:-10px}.hover\\:sl--translate-y-3\\.5:hover{--tw-translate-y:-14px}.sl-select-none{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.sl-select-text{-webkit-user-select:text;-moz-user-select:text;-ms-user-select:text;user-select:text}.sl-select-all{-webkit-user-select:all;-moz-user-select:all;user-select:all}.sl-select-auto{-webkit-user-select:auto;-moz-user-select:auto;-ms-user-select:auto;user-select:auto}.sl-align-baseline{vertical-align:initial}.sl-align-top{vertical-align:top}.sl-align-middle{vertical-align:middle}.sl-align-bottom{vertical-align:bottom}.sl-align-text-top{vertical-align:text-top}.sl-align-text-bottom{vertical-align:text-bottom}.sl-visible{visibility:visible}.sl-invisible{visibility:hidden}.sl-group:hover .group-hover\\:sl-visible{visibility:visible}.sl-group:hover .group-hover\\:sl-invisible{visibility:hidden}.sl-group:focus .group-focus\\:sl-visible{visibility:visible}.sl-group:focus .group-focus\\:sl-invisible{visibility:hidden}.sl-whitespace-normal{white-space:normal}.sl-whitespace-nowrap{white-space:nowrap}.sl-whitespace-pre{white-space:pre}.sl-whitespace-pre-line{white-space:pre-line}.sl-whitespace-pre-wrap{white-space:pre-wrap}.sl-w-0{width:0}.sl-w-1{width:4px}.sl-w-2{width:8px}.sl-w-3{width:12px}.sl-w-4{width:16px}.sl-w-5{width:20px}.sl-w-6{width:24px}.sl-w-7{width:28px}.sl-w-8{width:32px}.sl-w-9{width:36px}.sl-w-10{width:40px}.sl-w-11{width:44px}.sl-w-12{width:48px}.sl-w-14{width:56px}.sl-w-16{width:64px}.sl-w-20{width:80px}.sl-w-24{width:96px}.sl-w-32{width:128px}.sl-w-40{width:160px}.sl-w-60{width:240px}.sl-w-80{width:320px}.sl-w-auto{width:auto}.sl-w-px{width:1px}.sl-w-0\\.5{width:2px}.sl-w-1\\.5{width:6px}.sl-w-2\\.5{width:10px}.sl-w-3\\.5{width:14px}.sl-w-xs{width:20px}.sl-w-sm{width:24px}.sl-w-md{width:32px}.sl-w-lg{width:36px}.sl-w-xl{width:44px}.sl-w-2xl{width:52px}.sl-w-3xl{width:60px}.sl-w-1\\/2{width:50%}.sl-w-1\\/3{width:33.333333%}.sl-w-2\\/3{width:66.666667%}.sl-w-1\\/4{width:25%}.sl-w-2\\/4{width:50%}.sl-w-3\\/4{width:75%}.sl-w-1\\/5{width:20%}.sl-w-2\\/5{width:40%}.sl-w-3\\/5{width:60%}.sl-w-4\\/5{width:80%}.sl-w-1\\/6{width:16.666667%}.sl-w-2\\/6{width:33.333333%}.sl-w-3\\/6{width:50%}.sl-w-4\\/6{width:66.666667%}.sl-w-5\\/6{width:83.333333%}.sl-w-full{width:100%}.sl-w-screen{width:100vw}.sl-w-min{width:-moz-min-content;width:min-content}.sl-w-max{width:-moz-max-content;width:max-content}.sl-break-normal{overflow-wrap:normal;word-break:normal}.sl-break-words{overflow-wrap:break-word}.sl-break-all{word-break:break-all}.sl-z-0{z-index:0}.sl-z-10{z-index:10}.sl-z-20{z-index:20}.sl-z-30{z-index:30}.sl-z-40{z-index:40}.sl-z-50{z-index:50}.sl-z-auto{z-index:auto}.focus\\:sl-z-0:focus{z-index:0}.focus\\:sl-z-10:focus{z-index:10}.focus\\:sl-z-20:focus{z-index:20}.focus\\:sl-z-30:focus{z-index:30}.focus\\:sl-z-40:focus{z-index:40}.focus\\:sl-z-50:focus{z-index:50}.focus\\:sl-z-auto:focus{z-index:auto}:root{--font-prose:ui-sans-serif,system-ui,-apple-system,BlinkMacSystemFont,\"Segoe UI\",Roboto,\"Helvetica Neue\",Arial,\"Noto Sans\",sans-serif,\"Apple Color Emoji\",\"Segoe UI Emoji\",\"Segoe UI Symbol\",\"Noto Color Emoji\";--font-ui:Inter,ui-sans-serif,system-ui,-apple-system,BlinkMacSystemFont,\"Segoe UI\",Roboto,\"Helvetica Neue\",Arial,\"Noto Sans\",sans-serif,\"Apple Color Emoji\",\"Segoe UI Emoji\",\"Segoe UI Symbol\",\"Noto Color Emoji\";--font-mono:\"SF Mono\",ui-monospace,Menlo,Monaco,Consolas,\"Liberation Mono\",\"Courier New\",monospace;--font-code:var(--font-mono);--fs-paragraph-leading:22px;--fs-paragraph:16px;--fs-code:14px;--fs-paragraph-small:14px;--fs-paragraph-tiny:12px;--lh-paragraph-leading:1.875;--lh-paragraph:1.625;--lh-code:1.5;--lh-paragraph-small:1.625;--lh-paragraph-tiny:1.625;--color-code:var(--color-canvas-tint);--color-on-code:var(--color-text-heading)}.sl-aspect-ratio:before{content:\"\";display:block;height:0;padding-bottom:calc(1/var(--ratio)*100%)}.sl-aspect-ratio>:not(style){align-items:center;bottom:0;display:flex;height:100%;justify-content:center;left:0;overflow:hidden;position:absolute;right:0;top:0;width:100%}.sl-aspect-ratio>img,.sl-aspect-ratio>video{object-fit:cover}.sl-badge{align-items:center;border-width:1px;display:inline-flex;outline:2px solid transparent;outline-offset:2px}.sl-badge a{color:var(--color-text-muted)}.sl-badge a:hover{color:var(--color-text);cursor:pointer}.sl-button{align-items:center;display:inline-flex;line-height:0;outline:2px solid transparent;outline-offset:2px;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.sl-button-group>.sl-button:not(:first-child):not(:last-child){border-radius:0;border-right:0}.sl-button-group>.sl-button:first-child:not(:last-child){border-bottom-right-radius:0;border-right:0;border-top-right-radius:0}.sl-button-group>.sl-button:last-child:not(:first-child){border-bottom-left-radius:0;border-top-left-radius:0}.sl-image--inverted{filter:invert(1) hue-rotate(180deg);mix-blend-mode:screen}.Link,.Link>code{color:var(--color-link)}.Link:hover,.Link:hover>code{color:var(--color-link-dark)}.sl-link-heading:hover .sl-link-heading__icon{opacity:1}.sl-link-heading__icon{opacity:0}.sl-menu{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.sl-menu--pointer-interactions .sl-menu-item:not(.sl-menu-item--disabled):hover{background-color:var(--color-primary);color:var(--color-on-primary)}.sl-menu--pointer-interactions .sl-menu-item:not(.sl-menu-item--disabled):hover .sl-menu-item__description{color:var(--color-on-primary)}.sl-menu--pointer-interactions .sl-menu-item:not(.sl-menu-item--disabled):hover .sl-menu-item__icon{color:var(--color-on-primary)!important}.sl-menu-item__link-icon,.sl-menu-item__meta-text{opacity:.6}.sl-menu-item--disabled .sl-menu-item__title-wrapper{cursor:not-allowed;opacity:.5}.sl-menu-item--disabled .sl-menu-item__meta-text{cursor:not-allowed;opacity:.4}.sl-menu-item--focused{background-color:var(--color-primary);color:var(--color-on-primary)}.sl-menu-item--focused .sl-menu-item__link-icon,.sl-menu-item--focused .sl-menu-item__meta-text{opacity:1}.sl-menu-item--focused .sl-menu-item__description{color:var(--color-on-primary)}.sl-menu-item--focused .sl-menu-item__icon{color:var(--color-on-primary)!important}.sl-menu-item--submenu-active{background-color:var(--color-primary-tint)}.sl-menu-item__title-wrapper{max-width:250px}.sl-menu-item__description{-webkit-line-clamp:2;-webkit-box-orient:vertical;display:-webkit-box;overflow:hidden}.sl-popover{--tw-blur:var(--tw-empty,/*!*/ /*!*/);--tw-brightness:var(--tw-empty,/*!*/ /*!*/);--tw-contrast:var(--tw-empty,/*!*/ /*!*/);--tw-grayscale:var(--tw-empty,/*!*/ /*!*/);--tw-hue-rotate:var(--tw-empty,/*!*/ /*!*/);--tw-invert:var(--tw-empty,/*!*/ /*!*/);--tw-saturate:var(--tw-empty,/*!*/ /*!*/);--tw-sepia:var(--tw-empty,/*!*/ /*!*/);--tw-drop-shadow:var(--tw-empty,/*!*/ /*!*/);--tw-drop-shadow:drop-shadow(var(--drop-shadow-default1)) drop-shadow(var(--drop-shadow-default2));border-radius:2px;filter:var(--tw-blur) var(--tw-brightness) var(--tw-contrast) var(--tw-grayscale) var(--tw-hue-rotate) var(--tw-invert) var(--tw-saturate) var(--tw-sepia) var(--tw-drop-shadow)}.sl-popover>:not(.sl-popover__tip){border-radius:2px;position:relative;z-index:10}.sl-prose{-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale;--fs-paragraph:1em;--fs-paragraph-small:0.875em;--fs-code:0.875em;font-family:var(--font-prose);font-size:16px;line-height:var(--lh-paragraph)}.sl-prose>:first-child{margin-top:0}.sl-prose>:last-child{margin-bottom:0}.sl-prose h1{font-size:2.25em}.sl-prose>h1{margin-bottom:1.11em;margin-top:0}.sl-prose h2{font-size:1.75em;line-height:1.3333333}.sl-prose>h2{margin-bottom:1em;margin-top:1.428em}.sl-prose h3{font-size:1.25em}.sl-prose>h3{margin-bottom:.8em;margin-top:2em}.sl-prose h4{font-size:1em}.sl-prose>h4{margin-bottom:.5em;margin-top:2em}.sl-prose h2+*,.sl-prose h3+*,.sl-prose h4+*{margin-top:0}.sl-prose strong{font-weight:600}.sl-prose .sl-text-lg{font-size:.875em}.sl-prose p{color:var(--color-text-paragraph);font-size:var(--fs-paragraph);margin-bottom:1em;margin-top:1em}.sl-prose p:first-child{margin-top:0}.sl-prose p:last-child{margin-bottom:0}.sl-prose p>a>img{display:inline}.sl-prose caption a,.sl-prose figcaption a,.sl-prose li a,.sl-prose p a,.sl-prose table a{color:var(--color-link)}.sl-prose caption a:hover,.sl-prose figcaption a:hover,.sl-prose li a:hover,.sl-prose p a:hover,.sl-prose table a:hover{color:var(--color-link-dark)}.sl-prose caption a,.sl-prose figcaption a,.sl-prose li a,.sl-prose p a,.sl-prose table a{--color-link:var(--color-text-primary);--color-link-dark:var(--color-primary-dark)}.sl-prose hr{margin-bottom:1em;margin-top:1em}.sl-prose .sl-live-code{margin-bottom:1.25em;margin-left:-4px;margin-right:-4px;margin-top:1.25em;table-layout:auto;width:100%}.sl-prose .sl-live-code__inner>pre{margin-bottom:0;margin-top:0}.sl-prose .sl-callout{margin-bottom:1.5em;margin-top:1.5em}.sl-prose ol,.sl-prose ul{line-height:var(--lh-paragraph);margin-bottom:1.5em;margin-top:1.5em}.sl-prose ol li,.sl-prose ul li{padding-left:2em}.sl-prose ol li{position:relative}.sl-prose ol li:before{content:counter(list-item) \". \";font-variant-numeric:tabular-nums}.sl-prose ul:not(.contains-task-list) li{position:relative}.sl-prose ul:not(.contains-task-list) li:before{background-color:var(--color-text);border-radius:50%;content:\"\";height:.375em;left:.75em;opacity:.7;position:absolute;top:.625em;width:.375em}.sl-prose li{margin-bottom:4px;margin-top:4px;padding-left:1.75em}.sl-prose li p{display:inline-block;margin-bottom:.75em;margin-top:.75em}.sl-prose li>:first-child{margin-top:0}.sl-prose>ol p+:last-child,.sl-prose>ul p+:last-child{margin-bottom:.75em}.sl-prose ol ol,.sl-prose ol ul,.sl-prose ul ol,.sl-prose ul ul{margin-bottom:2px;margin-top:2px}.sl-prose ul.contains-task-list input{margin-left:-1.875em;margin-right:.625em;position:relative;top:1px}.sl-prose ul.contains-task-list p{margin-top:0}.sl-prose figure{margin-bottom:1.5em;margin-top:1.5em}.sl-prose figure figure,.sl-prose figure img,.sl-prose figure video{margin-bottom:0;margin-top:0}.sl-prose figure>figcaption,.sl-prose figure>figcaption p{color:var(--color-text-muted);font-size:var(--fs-paragraph-small);line-height:var(--lh-paragraph-small);margin-top:8px;padding-left:16px;padding-right:16px;text-align:center}.sl-prose blockquote p{margin-bottom:.5em;margin-top:.5em}.sl-prose table{font-size:var(--fs-paragraph-small);margin-bottom:1.5em;margin-left:-4px;margin-right:-4px;overflow-x:auto;table-layout:auto;width:100%}.sl-prose thead td,.sl-prose thead th{color:var(--color-text-muted);font-size:.857em;font-weight:500;padding:8px 12px;text-transform:uppercase}.sl-prose thead td:first-child,.sl-prose thead th:first-child{padding-left:4px}.sl-prose tbody{border-radius:5px;box-shadow:0 0 0 1px var(--color-border,currentColor)}.sl-prose tbody tr{border-top-width:1px}.sl-prose tbody tr:first-child{border-top:0}.sl-prose tbody tr:nth-child(2n){background-color:var(--color-canvas-tint)}.sl-prose td{margin:.625em .75em;padding:10px 12px;vertical-align:top}.sl-prose td:not([align=center],[align=right]),.sl-prose th:not([align=center],[align=right]){text-align:left}.sl-prose .mermaid{margin-bottom:1.5em;margin-top:1.5em}.sl-prose .mermaid>svg{border-radius:5px;border-width:1px;height:auto!important;padding:1.25em}.sl-prose .sl-code-group .mermaid,.sl-prose .sl-code-group pre{margin-top:0}.sl-svg-focus{filter:drop-shadow(0 0 1px hsla(var(--primary-h),80%,51%,.9))}.sl-radio-group__radio:hover{cursor:pointer}.sl-radio-group__radio--disabled{opacity:.6}.sl-radio-group__radio--disabled:hover{cursor:not-allowed}.sl-stack--horizontal.sl-stack--1>:not(style)~:not(style){margin-left:4px}.sl-stack--horizontal.sl-stack--2>:not(style)~:not(style){margin-left:8px}.sl-stack--horizontal.sl-stack--3>:not(style)~:not(style){margin-left:12px}.sl-stack--horizontal.sl-stack--4>:not(style)~:not(style){margin-left:16px}.sl-stack--horizontal.sl-stack--5>:not(style)~:not(style){margin-left:20px}.sl-stack--horizontal.sl-stack--6>:not(style)~:not(style){margin-left:24px}.sl-stack--horizontal.sl-stack--8>:not(style)~:not(style){margin-left:32px}.sl-stack--horizontal.sl-stack--10>:not(style)~:not(style){margin-left:40px}.sl-stack--horizontal.sl-stack--12>:not(style)~:not(style){margin-left:48px}.sl-stack--horizontal.sl-stack--14>:not(style)~:not(style){margin-left:56px}.sl-stack--horizontal.sl-stack--16>:not(style)~:not(style){margin-left:64px}.sl-stack--horizontal.sl-stack--20>:not(style)~:not(style){margin-left:80px}.sl-stack--horizontal.sl-stack--24>:not(style)~:not(style){margin-left:96px}.sl-stack--horizontal.sl-stack--32>:not(style)~:not(style){margin-left:128px}.sl-stack--vertical.sl-stack--1>:not(style)~:not(style){margin-top:4px}.sl-stack--vertical.sl-stack--2>:not(style)~:not(style){margin-top:8px}.sl-stack--vertical.sl-stack--3>:not(style)~:not(style){margin-top:12px}.sl-stack--vertical.sl-stack--4>:not(style)~:not(style){margin-top:16px}.sl-stack--vertical.sl-stack--5>:not(style)~:not(style){margin-top:20px}.sl-stack--vertical.sl-stack--6>:not(style)~:not(style){margin-top:24px}.sl-stack--vertical.sl-stack--8>:not(style)~:not(style){margin-top:32px}.sl-stack--vertical.sl-stack--10>:not(style)~:not(style){margin-top:40px}.sl-stack--vertical.sl-stack--12>:not(style)~:not(style){margin-top:48px}.sl-stack--vertical.sl-stack--14>:not(style)~:not(style){margin-top:56px}.sl-stack--vertical.sl-stack--16>:not(style)~:not(style){margin-top:64px}.sl-stack--vertical.sl-stack--20>:not(style)~:not(style){margin-top:80px}.sl-stack--vertical.sl-stack--24>:not(style)~:not(style){margin-top:96px}.sl-stack--vertical.sl-stack--32>:not(style)~:not(style){margin-top:128px}.sl-switch .sl-switch__indicator{transition:background-color .1s cubic-bezier(.4,1,.75,.9)}.sl-switch .sl-switch__indicator .sl-switch__icon{visibility:hidden}.sl-switch .sl-switch__indicator:before{background-color:var(--color-canvas);border-radius:50%;content:\"\";height:calc(100% - 4px);left:0;margin:2px;position:absolute;transition:left .1s cubic-bezier(.4,1,.75,.9);width:calc(50% - 4px)}.sl-switch input:checked:disabled~.sl-switch__indicator{background-color:var(--color-primary-light)}.sl-switch input:checked~.sl-switch__indicator{background-color:var(--color-primary)}.sl-switch input:checked~.sl-switch__indicator .sl-switch__icon{visibility:visible}.sl-switch input:checked~.sl-switch__indicator:before{left:50%}.sl-tooltip{--tw-blur:var(--tw-empty,/*!*/ /*!*/);--tw-brightness:var(--tw-empty,/*!*/ /*!*/);--tw-contrast:var(--tw-empty,/*!*/ /*!*/);--tw-grayscale:var(--tw-empty,/*!*/ /*!*/);--tw-hue-rotate:var(--tw-empty,/*!*/ /*!*/);--tw-invert:var(--tw-empty,/*!*/ /*!*/);--tw-saturate:var(--tw-empty,/*!*/ /*!*/);--tw-sepia:var(--tw-empty,/*!*/ /*!*/);--tw-drop-shadow:var(--tw-empty,/*!*/ /*!*/);--tw-drop-shadow:drop-shadow(var(--drop-shadow-default1)) drop-shadow(var(--drop-shadow-default2));border-radius:2px;filter:var(--tw-blur) var(--tw-brightness) var(--tw-contrast) var(--tw-grayscale) var(--tw-hue-rotate) var(--tw-invert) var(--tw-saturate) var(--tw-sepia) var(--tw-drop-shadow);font-size:11px;max-width:300px;padding:4px 6px}.sl-tooltip>:not(.sl-tooltip_tip){position:relative;z-index:10}input{background-color:initial}.sl-focus-ring{--tw-ring-color:hsla(var(--primary-h),80%,61%,var(--tw-ring-opacity)) ;;--tw-ring-opacity:0.5;--tw-ring-offset-shadow:var(--tw-ring-inset) 0 0 0 var(--tw-ring-offset-width) var(--tw-ring-offset-color);--tw-ring-shadow:var(--tw-ring-inset) 0 0 0 calc(3px + var(--tw-ring-offset-width)) var(--tw-ring-color);border-radius:2px;box-shadow:var(--tw-ring-offset-shadow),var(--tw-ring-shadow),var(--tw-shadow,0 0 #0000)}";

const GLOBAL_CSS_ID = 'mosaic-global';
const GLOBAL_CSS_THEME_ID = 'mosaic-theme';
const injectStyles = ({
  mode
} = {}) => {
  // do not attempt if we are not in a browser environment
  if (typeof document === 'undefined') return;
  appendCss(GLOBAL_CSS_ID, css);
  return subscribeTheme({
    mode
  });
};
const subscribeTheme = ({
  mode: initialMode
} = {}) => {
  // do not attempt if we are not in a browser environment
  if (typeof document === 'undefined') return; // allow user to force a starting theme mode if they so desire

  if (initialMode) {
    useThemeStore.getState().setMode(initialMode);
  }

  const {
    theme,
    mode
  } = useThemeStore.getState();
  /**
   * If user did not init theme earlier, do so now
   */

  const dataTheme = document.documentElement.getAttribute('data-theme');

  if (!dataTheme) {
    document.documentElement.setAttribute('data-theme', getResolvedThemeMode(mode));
  }

  injectTheme(theme, mode);
  const unsub = useThemeStore.subscribe(state => {
    try {
      injectTheme(state.theme, state.mode);
    } catch (e) {
      // noop, usually due to in flight theme change while user is editing
      console.warn('Error computing and applying theme', e);
    }
  }, s => ({
    mode: s.mode,
    theme: s.theme
  }), shallow);
  return unsub;
};

const injectTheme = (theme, mode) => {
  const {
    setColorValues,
    setInvertedColorValues
  } = useThemeStore.getState();

  if (typeof document !== 'undefined') {
    const userMode = getResolvedThemeMode(mode);
    document.documentElement.setAttribute('data-theme', userMode);
  }

  const {
    css: lightCss
  } = computeTheme(theme, 'light');
  const {
    css: darkCss
  } = computeTheme(theme, 'dark');
  replaceCss(`${GLOBAL_CSS_THEME_ID}-light`, lightCss);
  replaceCss(`${GLOBAL_CSS_THEME_ID}-dark`, darkCss);
  const {
    colorValues,
    invertedColorValues
  } = computeTheme(theme, mode);
  setColorValues(colorValues);
  setInvertedColorValues(invertedColorValues);
};

const InlineStyles = () => {
  return jsxs(Fragment, {
    children: [jsx("style", {
      id: GLOBAL_CSS_ID,
      type: "text/css",
      dangerouslySetInnerHTML: {
        __html: css
      }
    }, void 0), jsx(InlineTheme, {}, void 0)]
  }, void 0);
};

const InlineTheme = () => {
  const {
    theme
  } = useThemeStore();
  return jsxs(Fragment, {
    children: [jsx("style", {
      id: `${GLOBAL_CSS_THEME_ID}-light`,
      type: "text/css",
      dangerouslySetInnerHTML: {
        __html: computeTheme(theme, 'light').css
      }
    }, void 0), jsx("style", {
      id: `${GLOBAL_CSS_THEME_ID}-dark`,
      type: "text/css",
      dangerouslySetInnerHTML: {
        __html: computeTheme(theme, 'dark').css
      }
    }, void 0)]
  }, void 0);
};
/**
 * Small snippet to set the basics re theme as early as possible during rendering, to avoid major flashes of white etc.
 */


const INIT_THEME_JS = `try {
  var query = window.matchMedia("(prefers-color-scheme: dark)");

  var preference = window.localStorage.getItem('${THEME_STORAGE_KEY}');
  preference = preference ? JSON.parse(preference) : { mode: "${DEFAULT_THEME_MODE}" };

  var theme = (preference.mode === "system" && query.matches) || preference.mode === "dark" ? "dark" : "light";
  document.documentElement.setAttribute('data-theme', theme);
} catch (e) {
  console.warn('problem setting initial theme mode', e);
}`;
const InitTheme = () => {
  return jsx("script", {
    dangerouslySetInnerHTML: {
      __html: INIT_THEME_JS
    }
  }, void 0);
};

export { Article, AspectRatio, Avatar, Badge, Box, _Button as Button, ButtonGroup, Callout, Card, Code, Container, _CopyButton as CopyButton, DEFAULT_THEME_MODE, DismissButton, Divider$2 as Divider, EntityName, _FieldButton as FieldButton, Flex, GLOBAL_CSS_ID, GLOBAL_CSS_THEME_ID, Grid, HStack, Heading, INIT_THEME_JS, Icon, Image, InitTheme, InlineStyles, Input, InvertTheme, InvertThemeContext, Link, LinkHeading, ListBox, ListBoxItem, Menu, Modal, NoSsr, _Overlay as Overlay, Panel, Paragraph, Popover, PressResponder, Pressable, ProductImage, Prose, MosaicProvider as Provider, Radio, RadioGroup, _Select as Select, Stack, Step, Steps, Switch, THEME_STORAGE_KEY, Tab, TabImpl, TabList, TabPanel, TabPanels, Tabs, Text, Textarea, Tooltip, TreeItem, VStack, WithDomRef, __DEV__, accumulateCollectionKeysByProp, appendCss, borderPropNames, borderProps, colorPropNames, colorProps, computeTheme, containerSizes, defaultTheme, error, findCss, flexPropNames, flexProps, getContrastColor, getCssVariable, getInteractionModality, getResolvedThemeMode, injectStyles, interactivityPropNames, interactivityProps, isArray, isDefined, isEmpty, isEmptyArray, isEmptyObject, isFunction, isIconDefinition, isIconProp, isInputEvent, isNil, isNotEmptyObject, isNotNumber, isNull, isNumber, isNumeric, isObject, isString, isUndefined, layoutPropNames, layoutProps, marginProps, noop, once, paddingProps, parseHsl, positionPropNames, positionProps, prefersDarkMode, replaceCss, ringPropNames, ringProps, runIfFn, shadowPropNames, shadowProps, sizePropNames, sizeProps, spacingPropNames, splitBoxProps, splitProps, stringifyHsl, subscribeTheme, transformPropNames, transformProps, typographyPropNames, typographyProps, useClipboard, useCollectionKeyAccumulator, useControllableProp, useControllableState, useIconStore, useId, useInteractionModality, useIsSSR, useModalState, useMosaicContext, useOverlay, useOverlayPosition, useSSRSafeId, useTheme, useThemeIsDark, useThemeIsInverted, useThemeMode, useThemeStore, warn };
//# sourceMappingURL=core.esm.js.map
