"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.mergeParameters = exports.getOperationParameters = exports.getPathItemParameters = exports.getOperation = exports.getPath = void 0;
const jsonpointer_1 = require("./jsonpointer");
function getPath(oas, path) {
    // TODO ref
    console.log(jsonpointer_1.find);
    return oas.paths[path];
}
exports.getPath = getPath;
function getOperation(oas, path, method) {
    // TODO ref
    return oas.paths[path][method];
}
exports.getOperation = getOperation;
function getPathItemParameters(oas, pathItem) {
    const paramsOrRefs = pathItem.parameters ?? [];
    return paramsOrRefs.map((paramOrRef) => {
        if ("$ref" in paramOrRef) {
            return extractRef(oas, paramOrRef.$ref);
        }
        return paramOrRef;
    });
}
exports.getPathItemParameters = getPathItemParameters;
function getOperationParameters(oas, operation) {
    const paramsOrRefs = operation.parameters ?? [];
    return paramsOrRefs.map((paramOrRef) => {
        if ("$ref" in paramOrRef) {
            return extractRef(oas, paramOrRef.$ref);
        }
        return paramOrRef;
    });
}
exports.getOperationParameters = getOperationParameters;
function mergeParameters(path, operation) {
    const parameters = [...path, ...operation];
    const result = { query: [], header: [], path: [], cookie: [] };
    for (const parameter of parameters) {
        // FIXME check for parameters with the same name and override
        // this can happen when path parameters have been defined on both
        // path level and operation level
        result[parameter.in].push(parameter);
    }
    return result;
}
exports.mergeParameters = mergeParameters;
function extractRef(oas, ref) {
    const target = (0, jsonpointer_1.find)(oas, ref);
    return target;
}
//# sourceMappingURL=index.js.map